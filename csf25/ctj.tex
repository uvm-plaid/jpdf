\section{Confidentiality Types}

It is well-known that adding or subtracting a sample from a uniform
distribution in a finite field yields a value in a uniform
distribution, meaning that samples can be used as one-time-pads with
perfect secrecy \cite{barthe2019probabilistic,darais2019language}.
In our type system for confidentiality, we aim to approximate
distributions by tracking which program variables an expression
may depend on. But we also want to capture this fundamental mechanism
of encryption.

For example, given a message send such as:
$$
\xassign{\mx{x}{1}}{\secret{x} \ftimes \flip{x}}{2}
$$
we would assign the following type to denote that $\mx{x}{1}$ is dependent on
both $\sx{x}{2}$ and $\rx{x}{2}$:
$$
\mx{x}{1} : \setit{\sx{x}{2}, \rx{x}{2}}
$$
But in the case of 2-party reconstructive sharing:
$$
\xassign{\mx{x}{1}}{\secret{x} \fminus \flip{x}}{2}
$$
we want the type of $\mx{x}{1}$ to be an ``encrypted'' type
that is by itself independent of $\sx{x}{2}$. However, we also
want to track the dependence of $\mx{x}{2}$ and $\rx{x}{2}$.
In short, we assign $\mx{x}{1}$ a ``ciphertext type'':
$$
\mx{x}{1} : \cty{\rx{x}{2}}{\sx{x}{2}}
$$
indicating that $\mx{x}{1}$ is an encryption of a value
dependent on $\sx{x}{2}$ with $\rx{x}{2}$ and as long as client 1
does not subsequently receive messages that are dependent on $\rx{x}{2}$, the
value $\sx{x}{2}$ remains hidden.

Of course, there are other methods for encrypting values
in MPC protocols-- but we can observe that many are algebraically
equivalent to this fundamental schema. For example, in
Yao's Garbled Circuits (YGC) in $\mathbb{F}_{2}$, the ``garbler'' represents
encrypted wire values as random samples, and the ``evaluator''
obtains the wire value for its input via OT. The evaluator shares 
the initial encrypted wire value of one of its input secrets as
a selection bit-- assuming that client
2 is the garbler and client 1 is the evaluator, we can
write this as:
$$
\xassign{\mx{x}{1}}{\mux{\secret{x}}{\neg\flip{x}}{\flip{x}}}{2}
$$
where for all $\be_1,\be_2,\be_3$:
$$
\mux{\be_1}{\be_2}{\be_3} \defeq (\neg\be_1 \ftimes \be_2) \fplus (\be_1 \ftimes \be_3)
$$
and letting this protocol be $\prog$ the following is valid:
\begin{mathpar}
%\toeq{\xassign{\mx{x}{1}}{\OT{\secret{x}}{1}{\neg\flip{x}}{\flip{x}}}{2}}
   \toeq{\prog} \models \mx{x}{1} \eop \sx{x}{2} \fplus \rx{x}{2}
\end{mathpar}
This allows us to assign the same ciphertext type to $\mx{x}{1}$ as
above-- that is, $\cty{\rx{x}{2}}{\sx{x}{2}}$.
  
$$
\begin{array}{rcl@{\hspace{2mm}}r}
  t &::=& x \mid \cty{x}{T} \\
  \ty & \in & 2^{t}\\
  \Gamma &::=& \varnothing \mid \Gamma; x : \ty
\end{array} 
$$

\begin{definition}
  $R_1;R_2 = R_1 \cup R_2$ iff $R_1 \cap R_2 = \varnothing$.
\end{definition}

\begin{mathpar}
  \inferrule[DepTy]
  {}
  {\eqj{\varnothing}{\eqs}{\phi}{\vars(\phi)}}
  
  \inferrule[Encode]
  {\eqs \models \phi \eop \phi' \oplus \rx{w}{\cid} \\
   \oplus \in \{ \fplus,\fminus \}\\
   \eqj{R}{\eqs}{\phi'}{\ty}}
  {\eqj{R;\{ \rx{w}{\cid} \}}{\eqs}{\phi}{\setit{\cty{\rx{w}{\cid}}{\ty}}}}
\end{mathpar}

\begin{mathpar}
  \inferrule[Send]
            {\eqj{R}{\eqs}{\phi}{\ty}}
            {\cpj{R}{\eqs}{x \eop \phi}{(x : \ty)}}
            
  \inferrule[Seq]
            {\cpj{R_1}{\eqs}{\phi_1}{\Gamma_1}\\
             \cpj{R_2}{\eqs}{\phi_2}{\Gamma_2}}
            {\cpj{R_1;R_2}{\eqs}{\phi_1 \wedge \phi_2}{\Gamma_1;\Gamma_2}}
\end{mathpar}

\begin{definition}
  Given preprocessing predicate $\eqspre$ and protocol $\prog$ we say
  $\cpj{R}{\eqs}{\eqspre \wedge \toeq{\prog}}{\Gamma}$ is \emph{valid} iff it is derivable and
  $\eqspre \wedge \toeq{\prog} \models \eqs$.
\end{definition}

\begin{mathpar}
  \inferrule
      {\cid \in C}
      {\leakj{\Gamma}{C}{\Gamma(\mx{w}{\cid})}}

  \inferrule
      {\leakj{\Gamma}{C}{T_1 \cup T_2}}
      {\leakj{\Gamma}{C}{T_1}}

  \inferrule
      {\leakj{\Gamma}{C}{\setit{ \mx{w}{\cid} }}}
      {\leakj{\Gamma}{C}{\Gamma(\mx{w}{\cid})}}

  \inferrule
      {\leakj{\Gamma}{C}{\setit{ \rx{w}{\cid} }} \\ \leakj{\Gamma}{C}{\setit{ \cty{\rx{w}{\cid}}{\ty} }} }
      {\leakj{\Gamma}{C}{\ty}}
\end{mathpar}

\begin{theorem}
  If $\cpj{R}{\eqs}{\eqspre \wedge \toeq{\prog}}{\Gamma}$ is valid and there exists no $H,C$ 
  and  $\sx{w}{\cid}$ for $\cid \in H$ with $\leakj{\Gamma}{C}{\setit{\sx{w}{\cid}}}$,
  then $\prog$ satisfies gradual release.
\end{theorem}

\subsection{Examples}

\begin{verbatimtab}
m[s1]@2 := (s[1] - r[local] - r[x])@1
m[s1]@3 := r[x]@1

// m[s1]@2 : { c(r[x]@1, { c(r[local]@1, {s[1]@1} ) }
// m[s1]@3 : { r[x]@1 }
\end{verbatimtab}

\begin{verbatimtab}
m[x]@1 := s2(s[x],-r[x],r[x])@2

// m[x]@1 == s[x]@2 + -r[x]@2 
// m[x]@1 : { c(r[x]@2, { s[x]@2 }) } 

m[y]@1 := OT(s[y]@1,-r[y],r[y])@2

// m[y]@1 == s[y]@1 + -r[y]@2
// m[y]@1 : { c(r[y]@2, { s[y]@1 }) } 
\end{verbatimtab}

$$
\select{x}{y}{z}
$$
