\section{The $\minicat$ Protocol Language}

\begin{fpfig}[t]{Top-to-bottom: Basic $\minifed$ syntax, expression interpretation, and reduction rules.}{fig-minifed}
  {
    $$
    \begin{array}{rcl@{\hspace{8mm}}r}
      \multicolumn{4}{l}{v \in \mathbb{Z}_p,\ w \in \mathrm{String},\ \cid \in \mathrm{Clients} \subset  \mathbb{N} }\\[2mm] %, \bop \in \{ \eand, \eor, \exor \}} \\[2mm]
      \be &::=& v \mid \flip{w} \mid \secret{w} \mid \mesg{w} \mid \rvl{w} \mid \be \fminus \be \mid \be \fplus \be \mid \be \ftimes \be \mid f \mid \be\,\be & \textit{expressions}\\[2mm]
      x &::=& \elab{\flip{w}}{\cid} \mid \elab{\secret{w}}{\cid} \mid \elab{\mesg{w}}{\cid} \mid \rvl{w} \mid \out{\cid} & \textit{protocl variables} \\[2mm]
      %& &  \select{\be}{\be}{\be} \mid \ctxt{v}{k} \mid \key{w} \mid \sk{\be}(\be) \mid \pk{\be}{\be}(\be) \mid \pk{\be}{\be} \\[2mm]
      %& &  \select{\fp(\be)}{\be}{\be} \ctxt{v,\be}{k}  \mid \sk{\be}(\be) \mid \pk{\be}{\be}(\be) \mid \pk{\be}{\be} \\[2mm]
      \instr &::=& \eassign{\mesg{w}}{\cid}{\be}{\cid} \mid
      \reveal{w}{e}{\cid} \mid \pubout{\cid}{\be}{\cid} & \textit{commands} \\[2mm]
      \prog &::=& \varnothing \mid \instr; \prog & \textit{protocols}
    \end{array}
    $$
  
  \rule{130mm}{0.5pt}

  $$
  \begin{array}{c@{\hspace{5mm}}c}
  \begin{array}{rcl}
    \lcod{\store, v}{\cid} &=& v\\
    \lcod{\store, \be_1 \fplus \be_2}{\cid} &=& \fcod{\lcod{\store, \be_1}{\cid} \fplus \lcod{\store, \be_2}{\cid}}\\ 
    \lcod{\store, \be_1 \fminus \be_2}{\cid} &=& \fcod{\lcod{\store, \be_1}{\cid} \fminus \lcod{\store, \be_2}{\cid}}\\ 
    \lcod{\store, \be_1 \ftimes \be_2}{\cid} &=& \fcod{\lcod{\store, \be_1}{\cid} \ftimes \lcod{\store, \be_2}{\cid}}
  \end{array} & 
  \begin{array}{rcl}
    \lcod{\store, \flip{w}}{\cid} &=& \store(\elab{\flip{w}}{\cid})\\
    \lcod{\store, \secret{w}}{\cid} &=& \store(\elab{\secret{w}}{\cid})\\
    \lcod{\store, \mesg{w}}{\cid} &=& \store(\elab{\mesg{w}}{\cid})\\
    \lcod{\store, \rvl{w}}{\cid} &=& \store(\rvl{w})\\
    \lcod{\store, f\,e_1\,\cdots\, e_n}{\cid} &=& \delta(f,\lcod{\store, e_1}{\cid},\ldots,\lcod{\store,e_n}{\cid})
  \end{array}
  \end{array}
  $$

  \vspace{4mm}
  
  \rule{130mm}{0.5pt}

  \begin{mathpar}
    (\store, \eassign{\mesg{w}}{\cid_1}{\be}{\cid_2};\prog) \redx (\extend{\store}{\mesg{w}_{\cid_1}}{\lcod{\store,\be}{\cid_2}}, \prog)
    
    (\store, \reveal{w}{\be}{\cid};\prog) \redx (\extend{\store}{\rvl{w}}{\lcod{\store,\be}{\cid}}, \prog)
    
    (\store, \pubout{\cid}{\be}{\cid};\prog) \redx (\extend{\store}{\out{\cid}}{\lcod{\store,\be}{\cid}}, \prog)
  \end{mathpar}
  }
\end{fpfig}

The $\minifed$ language provides a simple model of synchronous
protocols between a federation of \emph{clients} exchanging values in
the binary field. We will identify clients by natural numbers, and
federations- finite sets of clients- are always given statically.
As we will see, our threat model assumes a partition of the federation
into \emph{honest} $H$ and \emph{corrupt} $C$ subsets.

We model probabilistic programming via a \emph{random tape}
semantics. That is, we will assume that programs can make reference to
values chosen from a uniform random distributions defined in the
initial program memory.  Programs aka protocols execute
deterministically given the random tape.

\subsection{Syntax} The syntax of $\minifed$, defined in
Figure \ref{fig-minifed}, includes values $v$ and standard
operations of addition, subtraction, and multiplication in
a finite field $\mathbb{Z}_p$ with $p$ prime. 
Protocols are given input secret values $\secret{w}$
as well as random samples $\flip{w}$ on the input
tape, both of which are distinguished by
strings $w$. Protocols are sequences of assignment
commands of three different forms:
\begin{itemize}
\item $\eassign{\mesg{w}}{\cid_2}{\be}{\cid_1}$: This
  is a \emph{message send} where expression $\be$ is computed
  by client $\cid_1$ and sent to client $\cid_2$ as message
  $\mesg{w}$.
\item $\reveal{w}{\be}{\cid}$: This
  is a \emph{public reveal} where expression $\be$ is computed
  by client $\cid$ and broadcast to the federation.
\item $\pubout{\cid}{\be}{\cid}$: This
  is an \emph{output} where expression $\be$ is computed
  by client $\cid$ and reported as its output.
\end{itemize}
Both messages $\mesg{w}$ and reveals $\rvl{w}$ can be
referenced in expressions, once they've been assigned.

We let $x$ range over \emph{variables}  which are identifiers
where client ownership is specified- e.g., $\elab{\mesg{\mathit{foo}}}{\cid}$
is a message $\mathit{foo}$ that was sent to $\cid$. We let $X$
range over sets of variables, and more specifically, $S$ ranges over sets of secret variables $\elab{\secret{w}}{\cid}$, $R$ ranges over sets of random variables $\elab{\flip{w}}{\cid}$, $M$ ranges over sets of message variables $\elab{\mesg{w}}{\cid}$, $P$ ranges over sets of public variables $\rvl{w}$, and $O$ ranges over sets of output variabels $\out{\cid}$.
Given a program $\prog$, we write $\iov(\prog)$ to
denote the set of $S \cup M \cup P \cup O$ of variables in $\prog$
with ownership made explicit, and we write $\flips(\prog)$ to
denote the set $R$ of random samplings in $\prog$ with ownership
made explicit. We write
$\vars(\prog)$ to denote $\iov(\prog) \cup \flips(\prog)$. For any set
of variables $X$ and parties $P$, we write $X_P$ to denote the subset
of $X$ owned by any party in $P$, in particular we write $X_H$ and $X_C$ to
denote the subsets belonging to honest and corrupt parties,
respectively.

\subsubsection{Library Functions} $\minifed$ expression syntax also supports
calls to library functions $f$ which can be applied to muliple arguments in a
curried style. This allows encapsulation and separate
definition of primitive operations such as one-time-pads and message
authentication, as we will illustrate with examples. This approach is
useful since it parameterizes these definitions, and 
supports verification of behavior specified with types, as we
discuss in Section \ref{section-types}.

\subsection{Semantics}

\emph{Memories} are fundamental to the semantics of $\fedcat$ and
provide random tape and secret inputs to protocols, and also record
message sends, public broadcast, and client outputs. Memories $\store$ are finite
(partial) mapping from variables $x$ to values $v \in \mathbb{Z}_p$. The \emph{domain} of a
memory is written $\dom(\store)$ and is the finite set of variables on
which the memory is defined. We write $\store\{ x \mapsto v\}$ for
$x\not\in\dom(\store)$ to denote the memory $\store'$ such that
$\store'(x) = v$ and otherwise $\store'(y) = \store(y)$ for all $y
\in \dom(\store)$. We write $\store \subseteq \store'$ iff
$\dom(\store) \subseteq \dom(\store')$ and $\store(x) =
\store'(x)$ for all $x \in \dom(\store)$. We write $\store \cap
\store'$ to denote the combination of $\store$ and $\store'$
assuming $\store(x) = \store'(x)$ for all $x \in \dom(\store)
\cap \dom(\store')$, otherwise $\store \cap \store'$ is undefined.
We write $\store \subseteq \store'$ iff $\store \cap \store'
= \store$.

Given a set of variables $X$, we write $\store_X$ to denote the
memory $\store$ restricted to the domain $X$, and we define
$\mems(X)$ as the set of all memories with domain $X$:
$$
\mems(X) \defeq \{ \store \mid \dom(\store) = X \}
$$
Thus, given a protocol $\prog$, the set of all random tapes for
$\prog$ is $\mems(\flips(\prog))$.
%We let $\stores$ range
%over sets of memories with the same domain, and abusing notation
%we write $\dom(\stores)$ to denote the common domain,
%and $\stores_X \defeq \{ \store_X | \store \in \stores \}$.

Given a variable-free expression $\be$, we write $\cod{\be}$ to denote
the standard interpretation of $\be$ in the arithmetic field
$\mathbb{Z}_{p}$. With the introduction of variables to expressions,
we need to interpret variables with respect to a specific memory, and
all variables used in an expression must belong to a specified client.
Thus, we denote interpretation of expressions $\be$ computed on a
client $\cid$ as $\lcod{\store,\be}{\cid}$. This interpretation is
defined in Figure \ref{fig-minifed}. It is also parameterized by
$\delta$ which defines the semantics of library functions $f$.

The small-step reduction relation $\redx$ is then defined in Figure
\ref{fig-minifed} to evaluate commands. Reduction is a relation on
\emph{configurations} $(\store, \prog)$ where all three command forms-
message send, broadcast, and output- are implemented as updates to the
memory $\store$. We write $\redxs$ to denote the reflexive, transitive
closure of\ $\redx$. 

\subsection{Example: Passive Secure Addition}

Shamir addition leverages homomorphic properties of addition in
arithmetic fields to implement secret addition. If a field value $v_1$
is in a uniform random distribution with other variables in a program,
then $v_1 \fplus v_2$ is an encryption of $v_2$ where $v_1$ is an
information theoretically secure one-time-pad, which is exploited for
secret sharing. Of course, $\fplus$ is also a meaningful operation
over any two field values regardless of their distributions.

To capture this distinction we introduce a function $\otp$
with the following specification:
$$
\delta(\otp,v_1,v_2) \defeq v_1 \fplus v_2
$$
Although the semantics are the same as addition, the use of $\otp$
makes a declarative distinction, but more importantly we will be
able to assign a type to $\otp$ that enforces the one-time discipline
on its first argument via type linearity as will be discussed in Section
\ref{section-types}.

To sum their secret values $\secret{\cid}$, each client $\cid$ in
the federation $\{ 1, 2, 3 \}$  samples a value $\locflip$
that can be used as a one-time pad in summation with another
random sample $\flip{x}$ and $\secret{\cid}$. This yields
two secret shares communicated as messages to the other clients,
while each client keeps $\locflip$ as its own share.
$$
\begin{array}{lll}
  \elab{\mesg{s1}}{2} &:=& \elab{(\otp\ \locflip\ (\flip{x} \fplus \secret{1})}{1} \\ 
  \elab{\mesg{s1}}{3} &:=& \elab{\flip{x}}{1} \\ 
  \elab{\mesg{s2}}{1} &:=& \elab{(\otp\ \locflip\ (\flip{x} \fplus \secret{2})}{2} \\ 
  \elab{\mesg{s2}}{3} &:=& \elab{\flip{x}}{2} \\ 
  \elab{\mesg{s3}}{1} &:=& \elab{(\otp\ \locflip\ (\flip{x} \fplus \secret{3})}{3} \\ 
  \elab{\mesg{s3}}{2} &:=& \elab{\flip{x}}{3}
\end{array}
$$
Due to field properties of $\fplus$ this scheme guarantees that messages
are viewed as random noise by any observer 
besides $\cid$ \cite{barthe2019probabilistic}. Next, each client
publicly reveals the sum of all of its shares, including its local
share. This does reveal information about secrets. Further there
is no one-time-pad to use in this summation.
$$
\begin{array}{lll}
  \rvl{1} &:=& \elab{(\locflip \fplus \mesg{s2} \fplus \mesg{s3})}{1} \\ 
  \rvl{2} &:=& \elab{(\mesg{s1} \fplus \locflip \fplus \mesg{s3})}{2} \\
  \rvl{3} &:=& \elab{(\mesg{s1} \fplus \mesg{s2} \fplus \locflip)}{3} 
\end{array}
$$
Finally, each client outputs the sum of each sum of shares, yielding
the sum of secrets. Note that this stage exposes no more information
than the previous public reveals. 
$$
%\elab{\mesg{o1}}{2} &:=& \elab{(\locflip \fplus \mesg{s2} \fplus \mesg{s3})}{1} \\ 
  %\elab{\mesg{o1}}{3} &:=& \elab{(\locflip \fplus \mesg{s2} \fplus \mesg{s3})}{1} \\ 
  %\elab{\mesg{o2}}{1} &:=& \elab{(\mesg{s1} \fplus \locflip \fplus \mesg{s3})}{2} \\
  %\elab{\mesg{o2}}{3} &:=& \elab{(\mesg{s1} \fplus \locflip \fplus \mesg{s3})}{2} \\ 
  %\elab{\mesg{o3}}{1} &:=& \elab{(\mesg{s1} \fplus \mesg{s2} \fplus \locflip)}{3} \\ 
  %\elab{\mesg{o3}}{2} &:=& \elab{(\mesg{s1} \fplus \mesg{s2} \fplus \locflip)}{3}\\ 
  %\pubout{1} &:=& \elab{(\locflip \fplus \mesg{s2} \fplus \mesg{s3} + \mesg{o2} + \mesg{o3})}{1}
\begin{array}{lll}
  \out{1} &:=& \elab{(\rvl{1} \fplus \rvl{2} + \rvl{3})}{1}\\
  \out{2} &:=& \elab{(\rvl{1} \fplus \rvl{2} + \rvl{3})}{2}\\
  \out{3} &:=& \elab{(\rvl{1} \fplus \rvl{2} + \rvl{3})}{3}
\end{array}
$$
It is well-known that additive secret sharing is passive
secure. That is, any adversarial observer can gain no more information
from the messages exchanged in the protocol than what is exposed by
the output alone. However, malicious adversaries can corrupt this
protocol by injecting ``fake'' sums of shares in their public reveals.

\subsection{Example: Malicious Secure Product}

$$
\begin{array}{rcl@{\hspace{8mm}}r}
  \multicolumn{3}{l}{m,k \in \mathbb{Z}_p \qquad \macv ::= (v,[m_1,\ldots,m_n])} &\\[2mm]
  %\textit{MACed\ values}\\[2mm]
  \be &::=& \cdots \mid \macv \mid \be \macplus \be \mid \be \mactimes \be \mid \be \macminus \be\\[2mm]
  x &::=& \cdots \mid \macx{\secret{w}}{\cid} \mid \macx{\flip{w}}{\cid} \mid \mack{x}{\cid}
\end{array}
$$

\begin{mathpar}
  \fcod{(v^1, [m_1^1,\ldots,m^1_n]) \macplus (v^2, [m_1^2,\ldots,m^2_n])} =
  (v^1 \fplus v^2, [m_1^1 \fplus m_1^2 ,\ldots,m^1_n \fplus m_n^2])

  \lcod{\store, \be_1 \macplus \be_2}{\cid} =
  \fcod{\lcod{\store,\be_1}{\cid} \macplus \lcod{\store,\be_2}{\cid}}
\end{mathpar}

\begin{mathpar}
  \inferrule
      {\store(x) = v \\ \store(\macx{x}{\cid_1}) = (v_1,\ldots)\  \cdots\ 
        \store(\macx{x}{\cid_n}) = (v_n,\ldots)}
      {v = \fcod{v_1 \fplus \cdots \fplus v_n}}
      
  \inferrule
      {\store(\macx{x}{\cid'}) = (v,[m_1,\ldots,m_n]) \\  \cid \in [1..n]}
      {m_\cid = \fcod{\store(\mack{x}{\cid}) \fplus (\store(\elab{\flip{\ttt{delta}}}{\cid'}) \ftimes v)}}

  \store(\elab{\secret{c}}{\Oracle}) = \lcod{\store,\flip{a} \ftimes \flip{b}}{\Oracle}
\end{mathpar}

$$
m_\cid = k_\cid + (k_\Delta * v)
$$

$$
\delta(\macotp,v_1,v_2) \defeq v_1 \macplus v_2
$$

$$
\delta(\macauth, (v, [\ldots,m_\cid,\ldots]), k_\cid) \defeq
     (v, [\ldots,m_\cid,\ldots]) \text{\ if\ } m_i = k_i + (k_\Delta * v)
$$

$$
\begin{array}{lcl}
  \elab{\mesg{a}}{2} &:=&
  \elab{(\macotp\ \macgv{\elab{\secret{x}}{1}}\ \macgv{\elab{\flip{a}}{\Oracle}})}{1}\\
  \elab{\mesg{a}}{1} &:=&
  \elab{(\macotp\ \macgv{\elab{\secret{x}}{1}}\ \macgv{\elab{\flip{a}}{\Oracle}})}{2}\\
  \elab{\mesg{b}}{2} &:=&
  \elab{(\macotp\ \macgv{\elab{\secret{y}}{2}}\ \macgv{\elab{\flip{b}}{\Oracle}})}{1}\\
  \elab{\mesg{b}}{1} &:=&
  \elab{(\macotp\ \macgv{\elab{\secret{y}}{2}}\ \macgv{\elab{\flip{b}}{\Oracle}})}{2}\\
  \elab{\mesg{d}}{1} &:=&
  \elab{(\macauth(\mesg{a}, \mack{\macx{\secret{x}}{1}}{2} \fminus \mack{\macx{\flip{a}}{\Oracle}}{2}) \macplus (\macgv{\elab{\secret{x}}{1}}\macminus\macgv{\elab{\flip{a}}{\Oracle}}))}{1}\\
  \elab{\mesg{e}}{1}&:=&
  \elab{(\macauth(\mesg{b}, \mack{\macx{\secret{y}}{2}}{2} \fminus \mack{\macx{\flip{b}}{\Oracle}}{2}) \macplus (\macgv{\elab{\secret{y}}{2}}\macminus\macgv{\elab{\flip{b}}{\Oracle}}))}{1}\\
  \rvl{1} &:=&
  \elab{( (\mesg{d} \mactimes \mesg{e}) \macplus
          (\mesg{d} \mactimes \macgv{\elab{\flip{b}}{\Oracle}}) \macplus
          (\mesg{e} \mactimes \macgv{\elab{\flip{a}}{\Oracle}}) \macplus \macgv{\elab{\secret{c}}{\Oracle}}
    )}{1}\\
  \elab{\mesg{d}}{2} &:=&
  \elab{(\macauth(\mesg{a}, \mack{\macx{\secret{x}}{1}}{1} \fminus \mack{\macx{\flip{a}}{\Oracle}}{1}) \macplus (\macgv{\elab{\secret{x}}{1}}\macminus\macgv{\elab{\flip{a}}{\Oracle}}))}{2}\\
  \elab{\mesg{e}}{2}&:=&
  \elab{(\macauth(\mesg{b}, \mack{\macx{\secret{y}}{2}}{1} \fminus \mack{\macx{\flip{b}}{\Oracle}}{1}) \macplus (\macgv{\elab{\secret{y}}{2}}\macminus\macgv{\elab{\flip{b}}{\Oracle}}))}{2}\\
  \rvl{2} &:=&
  \elab{( (\mesg{d} \mactimes \mesg{e}) \macplus
          (\mesg{d} \mactimes \macgv{\elab{\flip{b}}{\Oracle}}) \macplus
          (\mesg{e} \mactimes \macgv{\elab{\flip{a}}{\Oracle}}) \macplus \macgv{\elab{\secret{c}}{\Oracle}}
    )}{2}\\
  \out{1} &:=& \elab{(\rvl{1} \macplus \macauth(\rvl{2},\ldots))}{1} \\
  \out{2} &:=& \elab{(\macauth(\rvl{1},\ldots) \macplus \rvl{2})}{2}
\end{array}
$$


