\renewcommand{\flip}[1]{\ttt{r[}#1\ttt{]}}
\newcommand{\locflip}{\ttt{r[}\mathit{local}\ttt{]}}
\renewcommand{\secret}[1]{\ttt{s[}#1\ttt{]}}
\newcommand{\key}[1]{\ttt{k[}#1\ttt{]}}
\newcommand{\mesg}[1]{\ttt{m[}#1\ttt{]}}
\newcommand{\out}[1]{\ttt{out[}#1\ttt{]}}
\renewcommand{\oracle}[1]{\ttt{H[}#1\ttt{]}}
\newcommand{\elab}[2]{#1_{#2}}
\renewcommand{\eassign}[4]{\elab{#1}{#2} := \elab{#3}{#4}}
\newcommand{\sk}[1]{\mathrm{sk}[#1]}
\newcommand{\pk}[2]{\mathrm{pk}[#1,#2]}
\newcommand{\kgen}[1]{\mathit{kgen}(#1)}
\newcommand{\adversary}{\mathcal{A}}
\newcommand{\aredx}{\redx_{\adversary}}
\newcommand{\aredxs}{\redxs_{\adversary}}
\newcommand{\arewrite}{\mathit{rewrite}_{\adversary}}
\newcommand{\cinputs}{M_{C \rhd H}}
\newcommand{\houtputs}{M_{H \rhd C}}
\newcommand{\aruns}{\mathit{runs}_\adversary}
\newcommand{\att}{\mathrm{AD}}
\newcommand{\support}{\mathit{support}}
\renewcommand{\store}{\sigma}
\newcommand{\ctxt}[2]{\{ #1 \}_{#2}}
\newcommand{\cpub}{\mathit{pub}}
\renewcommand{\runs}{\mathit{runs}}
\newcommand{\pattern}[1]{\lfloor #1 \rfloor}
\newcommand{\fcod}[1]{\lcod{#1}{}}
\renewcommand{\flips}{\mathit{rands}}
\newcommand{\kmat}{\kappa}
\renewcommand{\Oracle}{\mathbb{O}}
\newcommand{\afilter}{\mathit{afilter}}
\renewcommand{\select}[3]{\mathtt{if}\ #1\ \mathtt{then}\ #2\ \mathtt{else}\ #3}
\newcommand{\fp}{\mathit{P}}
\newcommand{\ftimes}{*}
\newcommand{\fplus}{+}
\newcommand{\fminus}{-}
\newcommand{\mactimes}{\hat{\ftimes}}%{\otimes}
\newcommand{\macplus}{\hat{\fplus}}%\oplus}
\newcommand{\macminus}{\hat{\fminus}}%{\ominus}
\newcommand{\macv}[1]{\langle #1 \rangle}
\newcommand{\mack}[2]{\langle #1 \rangle.\ttt{k}_{#2}}
\newcommand{\macshare}[1]{\langle #1 \rangle.\ttt{share}}
\newcommand{\macauth}{\mathrm{auth}}
\newcommand{\fieldty}{\mathrm{F}}
\newcommand{\cipherty}{\mathit{c}}
\newcommand{\macty}{\hat{\fieldty}}%_{\mathit{mac}}}}
\renewcommand{\unity}[1]{\mathit{U}(#1)}
\renewcommand{\labty}[3]{#1^{#2}_{#3}}
\newcommand{\memenv}{\mathcal{M}}
\newcommand{\tensor}{\multimap}
\newcommand{\lib}{\mathcal{L}}
\newcommand{\okt}{\mathit{OK}}
\newcommand{\vty}{t}
\newcommand{\disty}{\dot{\vty}}
\newcommand{\tlev}[1]{\mathcal{T}(#1)}

\begin{fpfig}[t]{Top-to-bottom: $\minifed$ expression interpretation, source code restrictions on keys, and reduction rules.}{fig-minifed}
  {\small
    $$
    \begin{array}{rcl@{\hspace{8mm}}r}
      \multicolumn{4}{l}{v \in \mathbb{Z}_p,\ k \in \mathrm{Key},\ w \in \mathrm{String},\ \cid \in \mathrm{Clients} \subset  \mathbb{N} }\\[2mm] %, \bop \in \{ \eand, \eor, \exor \}} \\[2mm]
      \be &::=& v \mid \flip{w} \mid \secret{w} \mid \key{w} \mid \mesg{w} \mid \elab{\be}{\Oracle} \mid \fminus \be \mid \be \fplus \be \mid \be \ftimes \be \mid & \textit{expressions}\\[1mm]
      %& &  \select{\be}{\be}{\be} \mid \ctxt{v}{k} \mid \key{w} \mid \sk{\be}(\be) \mid \pk{\be}{\be}(\be) \mid \pk{\be}{\be} \\[2mm]
      & &  \select{\fp(\be)}{\be}{\be} \ctxt{v,\be}{k}  \mid \sk{\be}(\be) \mid \pk{\be}{\be}(\be) \mid \pk{\be}{\be} \\[2mm]
      \instr &::=& \eassign{\mesg{w}}{\cid}{\be}{\cid} & \textit{message send} \\[2mm]
      \prog &::=& \varnothing \mid \instr; \prog & \textit{protocols}
    \end{array}
    $$
  
  \rule{130mm}{0.5pt}

  $$
  \begin{array}{rcl}
    \lcod{\store, v}{\cid} &=& v\\
    \lcod{\store, \fminus \be}{\cid} & = &  \fcod{\fminus \lcod{\store, \be}{\cid}}\\ 
    \lcod{\store, \be_1 \fplus \be_2}{\cid} &=& \fcod{\lcod{\store, \be_1}{\cid} \fplus \lcod{\store, \be_2}{\cid}}\\ 
    \lcod{\store, \be_1 \ftimes \be_2}{\cid} &=& \fcod{\lcod{\store, \be_1}{\cid} \ftimes \lcod{\store, \be_2}{\cid}}\\
    \lcod{\store, \select{\fp(v)}{\be_2}{\be_3}}{\cid} &=&
    %\begin{cases}
      \lcod{\store, \be_2}{\cid}\ \text{if}\ \fcod{\fp(v)}\ \text{valid}, 
      \text{otherwise}\ \lcod{\store, \be_3}{\cid}\\
    %\end{cases}
    \lcod{\store, \select{\fp(\be_1)}{\be_2}{\be_3}}{\cid} &=& \lcod{\store, \select{\fp(\lcod{\be_1}{\cid})}{\be_2}{\be_3}}{\cid}\\
    \lcod{\store, \flip{w}}{\cid} &=& \store_\cid(\flip{w})\\
    \lcod{\store, \secret{w}}{\cid} &=& \store_\cid(\secret{w})\\
    \lcod{\store, \mesg{w}}{\cid} &=& \store_\cid(\mesg{w})\\
    \lcod{\store, \key{w}}{\cid}  &=&  \store_\cid(\key{w})\\
    \lcod{\store, \elab{\flip{w}}{\Oracle}}{\cid} &=& \store_\Oracle(\flip{w})\\
    \lcod{\store, \elab{\key{w}}{\Oracle}}{\cid} &=& \store_\Oracle(\key{w})\\
    \lcod{\store, \sk{k}(\ctxt{v,\_}{k})}{\cid} &=& v\\
    \lcod{\store, \sk{\be_1}(\be_2)}{\cid} &=& \lcod{\store, \sk{\lcod{\store,\be_1}{\cid}}(\lcod{\store, \be_2}{\cid})}{\cid}\\
    \lcod{\store, \pk{k}{\_}(v)}{\cid} &=& \ctxt{v,\elab{\flip{\mathit{fresh}}}{\Oracle}}{k}\\
    \lcod{\store, \pk{\be_1}{\be_2}(\be_3)}{\cid} &=&  
       \lcod{\store, \pk{\lcod{\store,\be_1}{\cid}}{\lcod{\store, \be_2}{\cid}}(\lcod{\store, \be_3}{\cid})}{\cid}\\
    \lcod{\store, \pk{k}{v}}{\cid} &=& \pk{k}{v}\\
    \lcod{\store, \pk{\be_1}{\be_2}}{\cid} &=& \lcod{\store, \pk{\lcod{\store,\be_1}{\cid}}{\lcod{\store, \be_2}{\cid}}}{\cid}
  \end{array} 
  $$

  \vspace{4mm}
  
  \rule{130mm}{0.5pt}
  \begin{mathpar}
    \sk{\key{w}}

    \pk{\key{w}}{\elab{\flip{w}}{\Oracle}}

    \pk{\elab{\key{w}}{\Oracle}}{\elab{\flip{w}}{\Oracle}}
  \end{mathpar}  
  \rule{130mm}{0.5pt}

  \begin{mathpar}
    (\store, \eassign{\mesg{w}}{\cid_1}{\be}{\cid_2};\prog) \redx (\extend{\store}{\mesg{w}_{\cid_1}}{\lcod{\store,\be}{\cid_2}}, \prog)
  \end{mathpar}
  }
\end{fpfig} 


\section{$\minicat$ Protocol Language}

\begin{example}[Passive Secure Oblivous Transfer]
  \label{exampl-ot}
  Assume that $p = 2$, i.e., that we are working in the binary field, with operators $\enot$,
  $\exor$, and $\eand$ under the usual interpretation. %We define the following syntactic sugar:
  %$$
  %\select{\be_1}{\be_2}{\be_3} \defeq (\be_1\ \eand\ \be_2)\ \exor\ (\enot\ \be_1\ \eand\ \be_2)
  %$$
  Here is an oblivious tranfer protocol with a sender $s$ and receiver $r$.
  $$
  \begin{array}{rcl}
    \elab{\mesg{k_1}}{s} &:=&
    \elab{(\select{\secret{choice} = 1}{\pk{\elab{\flip{z}}{\Oracle}}{\key{z}}}{\pk{\elab{\flip{z}}{\Oracle}}{\elab{\key{z}}{\Oracle}}})}{r};\\
    \elab{\mesg{k_2}}{s} &:=&
    \elab{(\select{\secret{choice} = 0}{\pk{\elab{\flip{z}}{\Oracle}}{\key{z}}}{\pk{\elab{\flip{z}}{\Oracle}}{\elab{\key{z}}{\Oracle}}})}{r};\\
    \elab{\mesg{c_1}}{r} &:=& \elab{(\mesg{k_1}(\flip{x}))}{s};\\
    \elab{\mesg{c_0}}{r} &:=& \elab{(\mesg{k_2}(\enot\ \flip{x}))}{s};\\
    \elab{\mesg{\mathit{recv}}}{r} &:=& \elab{(\select{\secret{choice} = 1}{\sk{\key{z}}(\mesg{c_1})}{\sk{\key{z}}(\mesg{c_0})})}{r}
  \end{array}
  $$
\end{example}

%  Passive-secure OT
%
%  m(k1)_1 := select(s[choice],pk[f[foo],k[foo]],pk[Hf[foo],Hk[foo]])_2
%  m(k0)_1 := select(not s[choice],pk[f[foo],k[foo]],pk[Hf[foo],Hk[foo]])_2
%  m(c1)_2 := m(k1)(s[s1])_1
%  m(c0)_2 := m(k0)(s[s0])_1
%  out_0 := select(s[choice],sk[k[foo]](m(c1)_2),sk[k[foo]](m(c0)_2)_2


\section{View Distributions}


\begin{definition}[Patterns]
  $$
  \keys_{\cid}(\store \cup \kmat) =
  \begin{cases}
    \{ \kmat_\cid(\key{w}) \mid \key{w} \in \dom(\kmat_\cid) \} \qquad \text{if} \ \cid \in H \\
    \{ \kmat_\cid'(\key{w}) \mid \elab{\key{w}}{\cid'} \in \dom(\kmat_C)  \} \quad\ \text{if}\ \cid \in C
  \end{cases}
  $$
  \begin{eqnarray*}
    \pattern{\store \cup \{ \mesg{w}_{\cid} \mapsto \ctxt{v,\_}{k} \}} &=&
    \pattern{\store} \cup \{ \mesg{w}_{\cid} \mapsto v \} \qquad k \in \keys_{\cid}(\store)\\
    \pattern{\store \cup \{ \mesg{w}_{\cid} \mapsto \ctxt{\_,v}{k} \}} &=&
    \pattern{\store} \cup \{ \mesg{w}_{\cid} \mapsto v \} \qquad k \not\in \keys_{\cid}(\store)\\
    \pattern{\store \cup \{ \mesg{w}_{\cid} \mapsto \pk{\_}{v}\}} &=&
    \pattern{\store} \cup \{ \mesg{w}_{\cid} \mapsto v \} \\
    \pattern{\store \cup \{ \mesg{w}_{\cid} \mapsto v\}} &=&
    \pattern{\store} \cup \{ \mesg{w}_{\cid} \mapsto v \} 
  \end{eqnarray*}
\end{definition}

\begin{definition}
  \label{def-progtt}
  \label{definition-progtt}
  Given fairly distributed key material $\kmat$ and program $\prog$ with $\iov(\prog) = (S,M)$ and $\flips(\prog) = R$,
  define $\runs$ as:
  $$
  \runs \defeq \{ \store \cup \kmat \cup \pattern{\store'} \mid (\dom(\store) = S \cup R) \wedge (\store \cup \kmat,\prog) \redxs
  (\store \cup \kmat \cup \store',\varnothing) \}
  $$
  %We note immediately that $|\runs| = 2^{S \cup F}$ given the (deterministic) definition of $\redx$. 
  Define $\progtt(\prog)$ as the program's \emph{basic distribution} such that for all
  $\store \in \mems(S \cup M \cup R)$:
  $$
  \progtt(\prog)(\store \cup \kmat) =  1 / |\runs| \ \text{if}\ \store \cup \kmat \in \runs, \text{otherwise}\ 0
  $$
  %\begin{cases}
  %  1 / |\runs| & \text{if}\ \store \in \runs\\
  %  0 & \text{otherwise}
  %\end{cases}
  %$$
  %Then the \emph{program distribution of $\prog$}, denoted $\progd(\prog)$, is the
  %marginal distribution of $S \cup V$ in $\prog$'s basic distribution, i.e., 
  %$
  %\progd(\prog) \defeq  \margd{\pmf}{S\cup V}
  %$.
  In some cases, we will also be concerned with the (joint)
  probabilities of expression interpretation given a preceding program
  execution, and we write $\progtt(\prog, \elab{\be}{\cid})$ to denote the program
  distribution $\progtt(\prog;\eassign{\itv}{\cid}{\be}{\cid})$ where $\itv$ is a
  special variable that is never used in programs.
\end{definition}

\section{Passive Security}

\begin{definition}[Passive Confidentiality]
  \label{definition-NIMO}
  We say that a program $\prog$ satisfies \emph{passive confidentiality}
  iff for all $H$ and $C$ with $|C|\le|H|$ and 
  $\store_1,\store_2 \in \mems(S)$ we have:
  $$
  (\store_1 =_C \store_2 \ \wedge \ 
  (\condd{\progtt(\prog)}{\{ \outv \}}{\store_1} = \condd{\progtt(\prog)}{\{ \outv \}}{\store_2}))
  \implies 
  (\condd{\progtt(\prog)}{\houtputs}{\store_1} = \condd{\progtt(\prog)}{\houtputs}{\store_2})
  $$
  where $\iov(\prog) = (S,M)$.
\end{definition}

\section{Malicious Security}

$$
\begin{array}{rclr}
  (\store, \eassign{\mesg{w}}{\cid_1}{\be}{\cid_2};\prog) &\aredx&
  (\extend{\store}{\mesg{w}_{\cid_1}}{\lcod{\store,\be}{\cid_2}}, \prog) & \cid_2 \in H\\
  (\store, \eassign{\mesg{w}}{\cid_1}{\be}{\cid_2};\prog) &\aredx&
  (\extend{\store}{\mesg{w}_{\cid_1}}{\lcod{\arewrite(\store_C,\be)}{\cid_2}}, \prog) & \cid_2 \in C
\end{array}
$$

\begin{definition}
  \label{def-progtt}
  \label{definition-progtt}
  Given fairly distributed key material $\kmat$, program $\prog$ with $\iov(\prog) = (S,M)$ and $\flips(\prog) = R$,
  and adversary $\adversary$, define $\runs_\adversary$ as:
  $$
  \runs_\adversary \defeq \{ \store \cup \kmat \cup \pattern{\store'} \mid (\dom(\store) = S \cup R) \wedge (\store \cup \kmat,\prog) \aredxs
  (\store \cup \kmat \cup \store',\varnothing) \}
  $$
  %We note immediately that $|\runs| = 2^{S \cup F}$ given the (deterministic) definition of $\redx$. 
  Define $\progtt(\prog, \adversary)$ as the distribution such that for all
  $\store \in \mems(S \cup M \cup R)$:
  $$
  \progtt(\prog,\adversary)(\store \cup \kmat) =  1 / |\aruns| \ \text{if}\ \store \cup \kmat \in \runs_\adversary, \text{otherwise}\ 0
  $$
\end{definition}

\begin{definition}[Corrupt Inputs, Honest Outputs]
  Given a program $\prog$ with $\iov(\prog) = (S,M)$ , define $\cinputs$ as the
  messages in $M$ sent from corrupt to honest parties:
  $$
  \cinputs = \{\ \elab{\mesg{w}}{\cid}\ \mid\  \elab{\mesg{w}}{\cid} \in M \wedge \eassign{\mesg{w}}{\cid}{\be}{\cid'} \in \prog
  \wedge \cid \in H \wedge \cid' \in C \ \} 
  $$
  and similarly define $\houtputs$ as the messages in $M$ sent from honest to corrupt parties.
  %Define also $(\afilter\ \prog)$ as $\prog$ with all instructions of the form $\eassign{\mesg{w}}{\cid}{\be}{\cid'}$ removed
  %where $\cid \in H \wedge \cid' \in C$.
\end{definition}

\begin{definition}
  We say that a protocol $\prog$ with $\iov(\prog) = (S,M)$ satisfies \emph{active confidentiality} iff the following conditions hold
  for all adversaries $\adversary$:
  \begin{enumerate}
  \item $\ \,\forall \store \in \mems(S_H) \ .\ \support(\progtt(\prog)(\{ \outv \}|\store)) =
    \support(\progtt(\prog,\adversary)(\{ \outv \}|\store))$
  \item $\begin{array}[t]{l}\forall \store_1, \store_2 \in \mems(S_H), \store \in \mems(\cinputs)\ . \\
    \quad
    \condd{\progtt(\prog,\adversary)}{\{ \outv \}}{\store_1 \cup \store} =
    \condd{\progtt(\prog,\adversary)}{\{ \outv \}}{\store_2 \cup \store} \\
    \qquad \implies\\
    \quad
    \condd{\progtt(\prog,\adversary)}{\houtputs}{\store_1 \cup \store} =
    \condd{\progtt(\prog,\adversary)}{\houtputs}{\store_2 \cup \store}\end{array}$
  \end{enumerate}
\end{definition}

\begin{theorem}
  If $\prog$ satisfies active confidentiality for all $H,C$ then it is malicious secure.
\end{theorem}

\begin{definition}
  We say that a protocol $\prog$ with $\iov(\prog) = (S,M)$ satisfies \emph{robust declassification} iff for all $\adversary_1,\adversary_2$ and
  for all $\store \in \mems(S_H)$ with: %and $\store_1,\store_2 \in \cinputs$ with:
  $$
  \condd{\progtt(\prog,\adversary_1)}{\{ \outv \}}{\store} =
  \condd{\progtt(\prog,\adversary_2)}{\{ \outv \}}{\store}
  $$
  we have:
  $$
  \condd{\progtt(\prog,\adversary_1)}{\houtputs}{\store} =
  \condd{\progtt(\prog,\adversary_2)}{\houtputs}{\store}
  $$
\end{definition}

\begin{definition}
  We say that a protocol $\prog$ with $\iov(\prog) = (S,M)$ satisfies \emph{transparent endorsement} iff for all $\adversary$ and $\store_1, \store_2 \in \mems(S_H)$ with:
  $$
  %\begin{array}[t]{l}
    \condd{\progtt(\prog,\adversary)}{\{ \outv \}}{\store_1} =
    \condd{\progtt(\prog,\adversary)}{\{ \outv \}}{\store_2}
  $$
  we have:  
  %  \qquad \implies\\
  $$
  \condd{\progtt(\prog,\adversary)}{\cinputs}{\store_1} =
    \condd{\progtt(\prog,\adversary)}{\cinputs}{\store_2}
  $$
\end{definition}

\begin{definition}
  A protocol $\prog$ with $\iov(\prog) = (S,M)$ is \emph{malicious correct} iff:
  $$
  \forall \adversary, \store \in \mems(S_H) \ .\ \support(\progtt(\prog)(\{ \outv \}|\store)) =
    \support(\progtt(\prog,\adversary)(\{ \outv \}|\store))
  $$
\end{definition}

\begin{theorem}
  If a protocol satisfies robust confidentiality and transparent endorsement, then it is
  malicious correct.
\end{theorem}
\begin{proof}
  This is a lazy Sunday morning conjecture that I believe is true, but need to think
  about.
\end{proof}

\begin{theorem}
  If a protocol is passive secure with robust confidentiality and
  transparent endorsement, then it is malicious secure.
\end{theorem}

\begin{lemma}
  A protocol $\prog$ with $\iov(\prog) = (S,M)$ satisfies robust declassification iff for all $\adversary$
  and $\store \in \runs_\adversary(\prog)$:
  $$
  \condd{\progtt(\prog,\adversary)}{\houtputs}{\outv} =
  \condd{\progtt(\prog,\adversary)}{\houtputs}{\outv \cup \store_{\cinputs}}
  $$
\end{lemma}


%\begin{lemma}
%  For all $\prog$ with $\iov(\prog) = (S,M)$, $\adversary_1$, $\adversary_2$, and
%  $\store \in \mems(S_H)$ we have:
%  $$
%  %\begin{array}{c}
%  \condd{\progtt(\prog,\adversary_1)}{\houtputs}{\store} =
%  \condd{\progtt(\prog,\adversary_2)}{\houtputs}{\store} \\
%  $$
%  iff:
%  $$
%  \forall \store^1 \in \runs_{\adversary_1},\store^2 \in \runs_{\adversary_2} . 
%  \condd{\progtt(\prog,\adversary_1)}{\houtputs}{\store \cup \store^1_{\cinputs}} =
%  \condd{\progtt(\prog,\adversary_2)}{\houtputs}{\store \cup \store^2_{\cinputs}}
%  %\end{array}
%  $$
%\end{lemma}

%\begin{lemma}
%  \label{lemma-aruns}
%  Given $\prog$ where $\iov(\prog) = S \cup V$ and $\flips(\prog) = F$. Then:
%  $$
%  \mathit{foldl}\ {tt}\ \mems((S \cup F)_H \cup \cinputs)\ (\mathit{afilter}\ \prog\ \cinputs) = \bigcup_\adversary  \aruns(\prog)
%  $$
%\end{lemma}


$$
\begin{array}{lll}
  \elab{\mesg{s1}}{2} &:=&
  \elab{(\macv{\elab{\secret{x}}{1}}\macplus\macv{\elab{\secret{y}}{2}}
    \macplus\macv{\elab{\secret{z}}{3}})}{1}\\
  \elab{\mesg{s1}}{3} &:=&
  \elab{(\macv{\elab{\secret{x}}{1}}\macplus\macv{\elab{\secret{y}}{2}}
    \macplus\macv{\elab{\secret{z}}{3}})}{1}\\[1mm]
  \elab{\mesg{s2}}{1} &:=&
  \elab{(\macv{\elab{\secret{x}}{1}}\macplus\macv{\elab{\secret{y}}{2}}
    \macplus\macv{\elab{\secret{z}}{3}})}{2}\\
  \elab{\mesg{s2}}{3} &:=&
  \elab{(\macv{\elab{\secret{x}}{1}}\macplus\macv{\elab{\secret{y}}{2}}
    \macplus\macv{\elab{\secret{z}}{3}})}{2}\\[1mm]
  \elab{\mesg{s3}}{1} &:=&
  \elab{(\macv{\elab{\secret{x}}{1}}\macplus\macv{\elab{\secret{y}}{2}}
    \macplus\macv{\elab{\secret{z}}{3}})}{3}\\
  \elab{\mesg{s3}}{2} &:=&
  \elab{(\macv{\elab{\secret{x}}{1}}\macplus\macv{\elab{\secret{y}}{2}}
    \macplus\macv{\elab{\secret{z}}{3}})}{3}\\[1mm]
  \out{1} &:=&(
  \begin{array}[t]{l}
  \macshare{\macauth(\mesg{s2},\mack{\elab{\secret{x}}{1}}{2}\fplus\mack{\elab{\secret{y}}{2}}{2}
    \fplus\mack{\elab{\secret{z}}{3}}{2})}\ \fplus\\
  \macshare{\macauth(\mesg{s3},\mack{\elab{\secret{x}}{1}}{3}\fplus\mack{\elab{\secret{y}}{2}}{3}
    \fplus\mack{\elab{\secret{z}}{3}}{3})}\ \fplus\\
  \macshare{\elab{\secret{x}}{1}}\fplus \macshare{\elab{\secret{y}}{2}}
    \fplus \macshare{\elab{\secret{z}}{3}}\qquad )_1
  \end{array}\\
  \out{2} &:=&(
  \begin{array}[t]{l}
  \macshare{\macauth(\mesg{s1},\mack{\elab{\secret{x}}{1}}{1}\fplus\mack{\elab{\secret{y}}{2}}{1}
    \fplus\mack{\elab{\secret{z}}{3}}{1})}\ \fplus\\
  \macshare{\macauth(\mesg{s3},\mack{\elab{\secret{x}}{1}}{3}\fplus\mack{\elab{\secret{y}}{2}}{3}
    \fplus\mack{\elab{\secret{z}}{3}}{3})}\ \fplus\\
  \macshare{\elab{\secret{x}}{1}}\fplus \macshare{\elab{\secret{y}}{2}}
    \fplus \macshare{\elab{\secret{z}}{3}}\qquad )_2
  \end{array}\\
  \out{3} &:=&(
  \begin{array}[t]{l}
  \macshare{\macauth(\mesg{s1},\mack{\elab{\secret{x}}{1}}{1}\fplus\mack{\elab{\secret{y}}{2}}{1}
    \fplus\mack{\elab{\secret{z}}{3}}{1})}\ \fplus\\
  \macshare{\macauth(\mesg{s2},\mack{\elab{\secret{x}}{1}}{2}\fplus\mack{\elab{\secret{y}}{2}}{2}
    \fplus\mack{\elab{\secret{z}}{3}}{2})}\ \fplus\\
  \macshare{\elab{\secret{x}}{1}}\fplus \macshare{\elab{\secret{y}}{2}}
    \fplus \macshare{\elab{\secret{z}}{3}}\qquad )_3
  \end{array}\\
\end{array}
$$


\begin{mathpar}
  \labty{\unity{\macty}}{\latel_1}{\latel_2} <  \labty{\macty}{\,\latel_1}{\latel_2}
  
  \labty{\unity{\fieldty}}{\latel_1}{\latel_2} <  \labty{\fieldty}{\,\latel_1}{\latel_2} 
  
  \labty{\vty}{\lolab}{\latel} <  \labty{\vty}{\hilab}{\latel} 
  
  \labty{\vty}{\latel}{\hilab} <  \labty{\vty}{\latel}{\lolab} 
\end{mathpar}

\begin{mathpar}
  \inferrule
      {R, \memenv \vdash_{\cid} e : \tau' \\ \tau' \le \tau}
      {R, \memenv \vdash_{\cid} e : \tau}

  \inferrule
      {R_1, \memenv \vdash{\cid} \be_1 : \tau' \tensor \tau \\ R_2, \memenv \vdash{\cid} \be_2 : \tau' }
      {R_1;R_2 \vdash{\cid} \be_1\ \be_2 : \tau}
      
  \inferrule
      {}
      {\varnothing, \memenv \vdash_{\cid} f : \lib(f)}

  \inferrule   
      {}
      {\varnothing, \memenv \vdash_{\cid} v : \labty{\fieldty}{\lolab}{\tlev{\cid}}}

  \inferrule
      {}
      {\varnothing,\memenv \vdash_{\cid} \secret{w} : \labty{\fieldty}{\tlev{\cid}}{\tlev{\cid}}}
      
  \inferrule
      {}
      {\{ \flip{w} \},\memenv \vdash_{\cid} \flip{w} : \labty{\unity{\fieldty}}{\lolab}{\tlev{\cid}}}

  \inferrule
      {}
      {\varnothing,\memenv \vdash_{\cid} \flip{w} : \labty{\fieldty}{\lolab}{\tlev{\cid}}}
      
  \inferrule
      {}
      {\{ \locflip \},\memenv \vdash_{\cid} \locflip : \labty{\unity{\fieldty}}{\tlev{\cid}}{\tlev{\cid}}}

  \inferrule
      {}
      {\varnothing,\memenv \vdash_{\cid} \locflip : \labty{\fieldty}{\tlev{\cid}}{\tlev{\cid}}}

  \inferrule
      { R_1, \memenv \vdash_{\cid} \locflip : \labty{\unity{\fieldty}}{\hilab}{\latel_1} \\
        R_2, \memenv \vdash_{\cid} \be : \labty{\unity{\fieldty}}{\hilab}{\latel_2} }
      {R_1;R_2, \memenv \vdash_{\cid} \locflip \fplus \be : \labty{\unity{\fieldty}}{\lolab}{\latel_1 \wedge_i \latel_2}}

  \inferrule
      { R_1, \memenv \vdash_{\cid} \be_1 : \labty{\unity{\fieldty}}{\,\latel_1^c}{\latel^i_1} \\
        R_2, \memenv \vdash_{\cid} \be_2 : \labty{\fieldty}{\,\latel_2^c}{\latel^i_2} }
      {R_1;R_2, \memenv \vdash_{\cid} \be_1 \fplus \be_2 :
        \labty{\unity{\fieldty}}{\,\latel^c_1 \wedge_c \latel^c_2}{\latel^i_1 \wedge_i \latel^i_2}}

  \inferrule
      { R_1, \memenv \vdash_{\cid} \be_1 : \labty{\fieldty}{\,\latel_1^c}{\latel^i_1} \\
        R_2, \memenv \vdash_{\cid} \be_2 : \labty{\fieldty}{\,\latel_2^c}{\latel^i_2} }
      {R_1;R_2, \memenv \vdash_{\cid} \be_1 \fplus \be_2 :
        \labty{\fieldty}{\,\latel^c_1 \wedge_c \latel^c_2}{\latel^i_1 \wedge_i \latel^i_2}}

  \inferrule
      { R_1, \memenv \vdash_{\cid} \be_1 : \labty{\fieldty}{\,\latel_1^c}{\latel^i_1} \\
        R_2, \memenv \vdash_{\cid} \be_2 : \labty{\fieldty}{\,\latel_2^c}{\latel^i_2} }
      {R_1;R_2, \memenv \vdash_{\cid} \be_1 \ftimes \be_2 :
        \labty{\fieldty}{\,\latel^c_1 \wedge_c \latel^c_2}{\latel^i_1 \wedge_i \latel^i_2}}

  \inferrule
      { R_1, \memenv \vdash_{\cid} \be_1 : \labty{\fieldty}{\,\latel_1^c}{\latel^i_1} \\
        R_2, \memenv \vdash_{\cid} \be_2 : \labty{\fieldty}{\,\latel_2^c}{\latel^i_2} }
      {R_1;R_2, \memenv \vdash_{\cid} \be_1 \fminus \be_2 :
        \labty{\fieldty}{\,\latel^c_1 \wedge_c \latel^c_2}{\latel^i_1 \wedge_i \latel^i_2}}
\end{mathpar}


\begin{mathpar}
  \inferrule
      {\Gamma_1,C \vdash_{\cid_1} e_1 : \labty{\fieldty}{\latel^c}{\latel^i} \\
      \Gamma_2,C \vdash_{\cid_2} e_3 : \tau_2 \\ \Gamma_3,C \vdash_{\cid_2} e_3 : \tau_3 }
      {\Gamma_1;\Gamma_2;\Gamma_3, C \vdash
        \elab{\mesg{w}}{\cid_1} :=
        \elab{\OT{\be_1}{\be_2}{\be_3}}{\cid_2}\quad  \{ \elab{\mesg{w}}{\cid_1} :
        \tau_2 \oplus \tau_3\} }
      
  \inferrule
      {\Gamma_1, \memenv \vdash_{\cid_2} e : \tau \\ \Gamma_2, \memenv; \elab{\mesg{w}}{\cid_1} : \tau \vdash \prog : \okt \\ \cid_1,\cid_2 \not\in C}
      {\Gamma_1;\Gamma_2, \memenv \vdash \elab{\mesg{w}}{\cid_1} := \elab{e}{\cid_2}; \prog : \okt}
      
  \inferrule
      {\Gamma_1, \memenv \vdash_{\cid_2} e : \labty{\vty}{\lolab}{\latel} \\
        \Gamma_2, \memenv \vdash \prog : \okt \\ \cid_1 \in C \\ \cid_2 \not\in C }
      {\Gamma_1;\Gamma_2, \memenv \vdash \elab{\mesg{w}}{\cid_1} := \elab{e}{\cid_2}; \prog : \okt}

  \inferrule
      {\Gamma, \memenv; \elab{\mesg{w}}{\cid_1} : \labty{\disty}{\lolab}{\lolab} \vdash \prog : \okt \\ \cid_1 \not\in C \\ \cid_2 \in C}
      {\Gamma, \memenv \vdash \elab{\mesg{w}}{\cid_1} := \elab{e}{\cid_2}; \prog : \okt}

  \inferrule
      {\Gamma, \memenv \vdash \prog : \okt \\ \cid_1,\cid_2 \in C}
      {\Gamma, \memenv \vdash \elab{\mesg{w}}{\cid_1} := \elab{e}{\cid_2}; \prog : \okt}

  \inferrule
      {\Gamma_1, \memenv \vdash_{\cid} e : \labty{\vty}{\hilab}{\hilab} \\
        \Gamma_2, \memenv \vdash \prog : \okt \\ \cid \not\in C}
      {\Gamma_1;\Gamma_2, \memenv \vdash \out{w} := \elab{e}{\cid}; \prog : \okt}

  \inferrule
      {\Gamma, \memenv \vdash \prog : \okt \\ \cid \in C}
      {\Gamma, \memenv \vdash \out{w} := \elab{e}{\cid}; \prog : \okt}
\end{mathpar}


\begin{mathpar}
  \inferrule
      {}
      {\macv{\elab{\secret{w}}{\cid}} : \labty{\unity{\macty}}{\tlev{\cid}}{\tlev{\cid}}, \memenv \vdash_\cid \macv{\elab{\secret{w}}{\cid}} : \labty{\unity{\macty}}{\tlev{\cid}}{\tlev{\cid}}}
      
  \inferrule
      {}
      {\varnothing, \memenv \vdash_\cid \macv{\elab{\secret{w}}{\cid}} : \labty{\macty}{\tlev{\cid}}{\tlev{\cid}}}
      
  \inferrule
      {\cid \ne \cid'}
      {\macv{\elab{\secret{w}}{\cid}} : \labty{\unity{\macty}}{\hilab}{\hilab}, \memenv \vdash_{\cid'} \macv{\elab{\secret{w}}{\cid}} : \labty{\unity{\macty}}{\lolab}{\hilab}}

  \inferrule
      { \Gamma_1, \memenv \vdash_{\cid} \be_1 : \labty{\unity{\macty}}{\lolab}{\latel_1} \\
        \Gamma_2, \memenv \vdash_{\cid} \be_2 : \labty{\unity{\macty}}{\hilab}{\latel_2} }
      {\Gamma_1;\Gamma_2, \memenv \vdash_{\cid} \be_1 \macplus \be_2 : \labty{\unity{\macty}}{\lolab}{\latel_1 \wedge_i \latel_2}}

  \inferrule
      { \Gamma_1, \memenv \vdash_{\cid} \be_1 : \labty{\unity{\macty}}{\hilab}{\latel_1} \\
        \Gamma_2, \memenv \vdash_{\cid} \be_2 : \labty{\macty}{\,\hilab}{\latel_2} }
      {\Gamma_1;\Gamma_2, \memenv \vdash_{\cid} \be_1 \macplus \be_2 : \labty{\unity{\macty}}{\lolab}{\latel_1 \wedge_i \latel_2}}

  \inferrule
      { \Gamma_1, \memenv \vdash_{\cid} \be_1 : \labty{\macty}{\,\latel_1^c}{\latel^i_1} \\
        \Gamma_2, \memenv \vdash_{\cid} \be_2 : \labty{\macty}{\,\latel_2^c}{\latel^i_2} }
      {\Gamma_1;\Gamma_2, \memenv \vdash_{\cid} \be_1 \macplus \be_2 :
        \labty{\macty}{\,\latel^c_1 \wedge_c \latel^c_2}{\latel^i_1 \wedge_i \latel^i_2}}
\end{mathpar}

$$
\macauth : \labty{\macty}{\lolab}{\lolab}\ \tensor\ \labty{\unity{\fieldty}}{\hilab}{\hilab})\ \tensor\ 
\labty{\macty}{\lolab}{\hilab}
$$
