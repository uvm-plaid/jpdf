\renewcommand{\flip}[1]{\ttt{r[}#1\ttt{]}}
\renewcommand{\secret}[1]{\ttt{s[}#1\ttt{]}}
\newcommand{\key}[1]{\ttt{k[}#1\ttt{]}}
\newcommand{\mesg}[1]{\ttt{m[}#1\ttt{]}}
\renewcommand{\oracle}[1]{\ttt{H[}#1\ttt{]}}
\newcommand{\elab}[2]{#1_{#2}}
\renewcommand{\eassign}[4]{\elab{#1}{#2} := \elab{#3}{#4}}
\newcommand{\sk}[1]{\mathrm{sk}[#1]}
\newcommand{\pk}[2]{\mathrm{pk}[#1,#2]}
\newcommand{\kgen}[1]{\mathit{kgen}(#1)}
\newcommand{\adversary}{\mathcal{A}}
\newcommand{\aredx}{\redx_{\adversary}}
\newcommand{\aredxs}{\redxs_{\adversary}}
\newcommand{\arewrite}{\mathit{rewrite}_{\adversary}}
\newcommand{\cinputs}{M_{C \rhd H}}
\newcommand{\aruns}{\mathit{runs}_\adversary}
\newcommand{\att}{\mathrm{AD}}
\newcommand{\support}{\mathit{support}}
\renewcommand{\store}{\sigma}
\newcommand{\ctxt}[2]{\{ #1 \}_{#2}}
\newcommand{\cpub}{\mathit{pub}}
\renewcommand{\views}{\mathcal{V}}
\newcommand{\pattern}[1]{\lfloor #1 \rfloor}
\newcommand{\fcod}[1]{\lcod{#1}{}}
\renewcommand{\flips}{\mathit{rands}}
\newcommand{\kmat}{\kappa}
\renewcommand{\Oracle}{\mathbb{O}}
\newcommand{\afilter}{\mathit{afilter}}

\begin{fpfig}[t]{Top-to-bottom: $\minifed$ expression interpretation, source code restrictions on keys, and reduction rules.}{fig-minifed}
  {\small
    $$
    \begin{array}{rcl@{\hspace{8mm}}r}
      \multicolumn{4}{l}{v \in \mathbb{Z}_p,\ k \in \mathrm{Key},\ w \in \mathrm{String},\ \cid \in \mathrm{Clients} \subset  \mathbb{N} }\\[2mm] %, \bop \in \{ \eand, \eor, \exor \}} \\[2mm]
      \be &::=& v \mid \flip{w} \mid \secret{w} \mid \mesg{w} \mid \elab{\be}{\Oracle} \mid \ominus \be \mid \be \oplus \be \mid \be \otimes \be \mid & \textit{expressions}\\[1mm]
      %& &  \select{\be}{\be}{\be} \mid \ctxt{v}{k} \mid \key{w} \mid \sk{\be}(\be) \mid \pk{\be}{\be}(\be) \mid \pk{\be}{\be} \\[2mm]
      & &  \ctxt{v,\be}{k} \mid \key{w} \mid \sk{\be}(\be) \mid \pk{\be}{\be}(\be) \mid \pk{\be}{\be} \\[2mm]
      \instr &::=& \eassign{\mesg{w}}{\cid}{\be}{\cid} & \textit{message send} \\[2mm]
      \prog &::=& \varnothing \mid \instr; \prog & \textit{protocols}
    \end{array}
    $$
  
  \rule{130mm}{0.5pt}

  $$
  \begin{array}{rcl}
    \lcod{\store, v}{\cid} &=& v\\
    \lcod{\store, \ominus \be}{\cid} & = &  \fcod{\ominus \lcod{\store, \be}{\cid}}\\ 
    \lcod{\store, \be_1 \oplus \be_2}{\cid} &=& \fcod{\lcod{\store, \be_1}{\cid} \oplus \lcod{\store, \be_2}{\cid}}\\ 
    \lcod{\store, \be_1 \otimes \be_2}{\cid} &=& \fcod{\lcod{\store, \be_1}{\cid} \otimes \lcod{\store, \be_2}{\cid}}\\ 
    \lcod{\store, \flip{w}}{\cid} &=& \store_\cid(\flip{w})\\
    \lcod{\store, \secret{w}}{\cid} &=& \store_\cid(\secret{w})\\
    \lcod{\store, \mesg{w}}{\cid} &=& \store_\cid(\mesg{w})\\
    \lcod{\store, \key{w}}{\cid}  &=&  \store_\cid(\key{w})\\
    \lcod{\store, \elab{\flip{w}}{\Oracle}}{\cid} &=& \store_\Oracle(\flip{w})\\
    \lcod{\store, \elab{\key{w}}{\Oracle}}{\cid} &=& \store_\Oracle(\key{w})\\
    \lcod{\store, \sk{k}(\ctxt{v,\_}{k})}{\cid} &=& v\\
    \lcod{\store, \sk{\be_1}(\be_2)}{\cid} &=& \lcod{\store, \sk{\lcod{\store,\be_1}{\cid}}(\lcod{\store, \be_2}{\cid})}{\cid}\\
    \lcod{\store, \pk{k}{\_}(v)}{\cid} &=& \ctxt{v,\elab{\flip{\mathit{fresh}}}{\Oracle}}{k}\\
    \lcod{\store, \pk{\be_1}{\be_2}(\be_3)}{\cid} &=&  
       \lcod{\store, \pk{\lcod{\store,\be_1}{\cid}}{\lcod{\store, \be_2}{\cid}}(\lcod{\store, \be_3}{\cid})}{\cid}\\
    \lcod{\store, \pk{k}{v}}{\cid} &=& \pk{k}{v}\\
    \lcod{\store, \pk{\be_1}{\be_2}}{\cid} &=& \lcod{\store, \pk{\lcod{\store,\be_1}{\cid}}{\lcod{\store, \be_2}{\cid}}}{\cid}
  \end{array} 
  $$

  \vspace{4mm}
  
  \rule{130mm}{0.5pt}
  \begin{mathpar}
    \sk{\key{w}}

    \pk{\key{w}}{\elab{\flip{w}}{\Oracle}}

    \pk{\elab{\key{w}}{\Oracle}}{\elab{\flip{w}}{\Oracle}}
  \end{mathpar}  
  \rule{130mm}{0.5pt}

  \begin{mathpar}
    (\store, \eassign{\mesg{w}}{\cid_1}{\be}{\cid_2};\prog) \redx (\extend{\store}{\mesg{w}_{\cid_1}}{\lcod{\store,\be}{\cid_2}}, \prog)
  \end{mathpar}
  }
\end{fpfig} 


\section{$\minicat$ Protocol Language}

\begin{example}[Passive-Secure Oblivous Transfer]
  \label{exampl-ot}
  Assume that $p = 2$, i.e., that we are working in the binary field, with operators $\enot$,
  $\exor$, and $\eand$ under the usual interpretation. We define the following syntactic sugar:
  $$
  \select{\be_1}{\be_2}{\be_3} \defeq (\be_1\ \eand\ \be_2)\ \exor\ (\enot\ \be_1\ \eand\ \be_2)
  $$
  Here is an oblivious tranfer protocol with a sender $s$, receiver $r$, and a public client
  $\cpub$ to which the receiver outputs the transfered value. 
  $$
  \begin{array}{rcl}
    \elab{\mesg{k_1}}{s} &:=&
    \elab{\select{\secret{choice}}{\pk{\elab{\flip{x}}{\Oracle}}{\key{x}}}{\pk{\elab{\flip{x}}{\Oracle}}{\elab{\key{x}}{\Oracle}}}}{r};\\
    \elab{\mesg{k_2}}{s} &:=&
    \elab{\select{\enot\ \secret{choice}}{\pk{\elab{\flip{x}}{\Oracle}}{\key{x}}}{\pk{\elab{\flip{x}}{\Oracle}}{\elab{\key{x}}{\Oracle}}}}{r};\\
    \elab{\mesg{c_1}}{r} &:=& \elab{(\mesg{k_1}(\secret{secret_1}))}{s};\\
    \elab{\mesg{c_0}}{r} &:=& \elab{(\mesg{k_2}(\secret{secret_0}))}{s};\\
    \elab{\outv}{\cpub} &:=& \elab{\select{\secret{choice}}{\sk{\key{x}(\mesg{c_1})}}{\sk{\key{x}(\mesg{c_0})}}}{r}
  \end{array}
  $$
\end{example}

%  Passive-secure OT
%
%  m(k1)_1 := select(s[choice],pk[f[foo],k[foo]],pk[Hf[foo],Hk[foo]])_2
%  m(k0)_1 := select(not s[choice],pk[f[foo],k[foo]],pk[Hf[foo],Hk[foo]])_2
%  m(c1)_2 := m(k1)(s[s1])_1
%  m(c0)_2 := m(k0)(s[s0])_1
%  out_0 := select(s[choice],sk[k[foo]](m(c1)_2),sk[k[foo]](m(c0)_2)_2


\section{View Distributions}


\begin{definition}[Patterns]
  $$
  \keys_{\cid}(\store \cup \kmat) =
  \begin{cases}
    \{ k \mid \exists \key{x} \in \dom(\kmat_\cid) .  \kmat_\cid(\key{x}) = k\} \qquad\qquad \text{if} \ \cid \in H \\
    \{ k \mid \exists \elab{\key{x}}{\cid'} \in \cup_{\cid' \in C} . \dom(\kmat_\cid') .  \kmat_\cid'(\key{x}) = k \} \quad \text{if}\ \cid \in C
  \end{cases}
  $$
  \begin{eqnarray*}
    \pattern{\store \cup \{ \mesg{w}_{\cid} \mapsto \ctxt{v,\_}{k} \}} &=&
    \pattern{\store} \cup \{ \mesg{w}_{\cid} \mapsto v \} \qquad k \in \keys_{\cid}(\store)\\
    \pattern{\store \cup \{ \mesg{w}_{\cid} \mapsto \ctxt{\_,v}{k} \}} &=&
    \pattern{\store} \cup \{ \mesg{w}_{\cid} \mapsto v \} \qquad k \not\in \keys_{\cid}(\store)\\
    \pattern{\store \cup \{ \mesg{w}_{\cid} \mapsto \pk{\_}{v}\}} &=&
    \pattern{\store} \cup \{ \mesg{w}_{\cid} \mapsto v \} \\
    \pattern{\store \cup \{ \mesg{w}_{\cid} \mapsto v\}} &=&
    \pattern{\store} \cup \{ \mesg{w}_{\cid} \mapsto v \} 
  \end{eqnarray*}
\end{definition}

\begin{definition}
  \label{def-progtt}
  \label{definition-progtt}
  Given fairly distributed key material $\kmat$ and program $\prog$ with $\iov(\prog) = (S,M)$ and $\flips(\prog) = R$,
  define $\views$ as:
  $$
  \views \defeq \{ \store \cup \kmat \cup \pattern{\store'} \mid (\dom(\store) = S \cup R) \wedge (\store \cup \kmat,\prog) \redxs
  (\store \cup \kmat \cup \store',\varnothing) \}
  $$
  %We note immediately that $|\views| = 2^{S \cup F}$ given the (deterministic) definition of $\redx$. 
  Define $\progtt(\prog)$ as the program's \emph{basic distribution} such that for all
  $\store \in \mems(S \cup M \cup R)$:
  $$
  \progtt(\prog)(\store \cup \kmat) =  1 / |\views| \ \text{if}\ \store \cup \kmat \in \views, \text{otherwise}\ 0
  $$
  %\begin{cases}
  %  1 / |\views| & \text{if}\ \store \in \views\\
  %  0 & \text{otherwise}
  %\end{cases}
  %$$
  %Then the \emph{program distribution of $\prog$}, denoted $\progd(\prog)$, is the
  %marginal distribution of $S \cup V$ in $\prog$'s basic distribution, i.e., 
  %$
  %\progd(\prog) \defeq  \margd{\pmf}{S\cup V}
  %$.
  In some cases, we will also be concerned with the (joint)
  probabilities of expression interpretation given a preceding program
  execution, and we write $\progtt(\prog, \elab{\be}{\cid})$ to denote the program
  distribution $\progtt(\prog;\eassign{\itv}{\cid}{\be}{\cid})$ where $\itv$ is a
  special variable that is never used in programs.
\end{definition}

\section{Passive Security}

\begin{definition}[Noninterference Modulo Output]
  \label{definition-NIMO}
  We say that a program  $\prog$ satisfies \emph{confidentiality modulo output},
  iff for all $H$ and $C$ with $|C|\le|H|$ and 
  $\store_1,\store_2 \in \mems(S)$ we have:
  $$
  (\store_1 =_C \store_2 \ \wedge \ 
  (\condd{\progtt(\prog)}{\{ \outv \}}{\store_1} = \condd{\progtt(\prog)}{\{ \outv \}}{\store_2}))
  \implies 
  (\condd{\progtt(\prog)}{M_C}{\store_1} = \condd{\progtt(\prog)}{M_C}{\store_2})
  $$
  where $\iov(\prog) = (S,M)$.
\end{definition}

\section{Malicious Security}

$$
\begin{array}{rclr}
  (\store, \eassign{\mesg{w}}{\cid_1}{\be}{\cid_2};\prog) &\aredx&
  (\extend{\store}{\mesg{w}_{\cid_1}}{\lcod{\store,\be}{\cid_2}}, \prog) & \cid_2 \in H\\
  (\store, \eassign{\mesg{w}}{\cid_1}{\be}{\cid_2};\prog) &\aredx&
  (\extend{\store}{\mesg{w}_{\cid_1}}{\lcod{\arewrite(\store_C,\be)}{\cid_2}}, \prog) & \cid_2 \in C
\end{array}
$$

\begin{definition}
  \label{def-progtt}
  \label{definition-progtt}
  Given fairly distributed key material $\kmat$, program $\prog$ with $\iov(\prog) = (S,M)$ and $\flips(\prog) = R$,
  and adversary $\adversary$, define $\views$ as:
  $$
  \views \defeq \{ \store \cup \kmat \cup \pattern{\store'} \mid (\dom(\store) = S \cup R) \wedge (\store \cup \kmat,\prog) \aredxs
  (\store \cup \kmat \cup \store',\varnothing) \}
  $$
  %We note immediately that $|\views| = 2^{S \cup F}$ given the (deterministic) definition of $\redx$. 
  Define $\progtt(\prog, \adversary)$ as the distribution such that for all
  $\store \in \mems(S \cup M \cup R)$:
  $$
  \progtt(\prog,\adversary)(\store \cup \kmat) =  1 / |\views| \ \text{if}\ \store \cup \kmat \in \views, \text{otherwise}\ 0
  $$
\end{definition}

\begin{definition}[Corrupt Inputs]
  Given a program $\prog$, define:
  $$
  \cinputs = \{\ \elab{\mesg{x}}{\cid}\ \mid\  \elab{\mesg{x}}{\cid} \in M \wedge \eassign{\mesg{x}}{\cid}{\be}{\cid'} \in \prog
  \wedge \cid \in H \wedge \cid' \in C \ \} 
  $$
  Define also $\afilter\ \prog$ as $\prog$ with all instructions of the form $\eassign{\mesg{x}}{\cid}{\be}{\cid'}$ removed
  where $\cid \in H \wedge \cid' \in C$.
\end{definition}

\begin{definition}
  Given $\prog$ with $\iov(\prog) = S \cup V$ and $\flips(\prog) = F$:
  $$
  \aruns(\prog) \defeq \{ \store \in \mems(S\cup F \cup V) \mid \config{\store_{S \cup F}}{\prog} \aredxs \config{\store}{\varnothing} \}
  $$
  We write $\att(\prog)$ to denote the \emph{adversarial distribution} of
  $\prog$, where given $\iov(\prog) = S \cup V$ and $\flips(\prog) = F$
  we have for all $\store \in \mems(S \cup V \cup F)$:
  $$
  \att(\prog)(\store) =  1 / 2^{|(S\cup F)_H \cup \cinputs|} \ \text{if}\ \exists \adversary\ .\ \store \in \aruns(\prog), \text{otherwise}\ 0
  $$
\end{definition}

\begin{definition}
  We say that a protocol $\prog$ satisfies \emph{robust confidentiality} if the following conditions hold:
  \begin{enumerate}
  \item $\ \,\forall \store \in \mems(S_H) \ .\ \support(\progtt(\prog)(\{ \outv \}|m)) = \support(\att(\prog)(\{ \outv \}|m))$
  \item $\begin{array}[t]{l}\forall m_1, m_2 \in \mems(S_H), m \in \mems(\cinputs)\ . \\
    \quad \att(\prog)(\{ \outv \} |m_1 \cup m) = \att(\prog)(\{ \outv \}|m_2 \cup m) \\
    \qquad \implies\\
    \quad \att(\prog)(V_C|m_1 \cup m) = \att(\prog)(V_C|m_2 \cup m)\end{array}$
  \end{enumerate}
\end{definition}


\begin{theorem}
  If $\prog$ satisfies robust confidentiality for all $C$ then it is malicious secure.
\end{theorem}

\begin{lemma}
  \label{lemma-aruns}
  Given $\prog$ where $\iov(\prog) = S \cup V$ and $\flips(\prog) = F$. Then:
  $$
  \mathit{foldl}\ {tt}\ \mems((S \cup F)_H \cup \cinputs)\ (\mathit{afilter}\ \prog\ \cinputs) = \bigcup_\adversary  \aruns(\prog)
  $$
\end{lemma}
