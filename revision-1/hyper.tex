\section{Security Hyperproperties}

In this Section we formulate probabilistic versions of well-studied
hyperproperties of confidentiality and integrity, including noninterference,
gradual release, declassification, and robust declassification.
We demonstrate a soundness relation between noninterference and
passive security, and between robust declassification and malicious
security. We subsequently leverage this relation to enforce
malicious security using ``traditional'' security type methods
in Section \ref{section-types}. Previous work has explored
a similar approach to security type enforcement
\cite{6266151,almeida2018enforcing} but mainly
for aspects of passive security.

\subsection{Passive Security and Noninterference}

Since MPC protocols release some information about secrets through
outputs of $\idealf$, they do not enjoy strict noninterference.  As
discussed in Section \ref{section-lang}, public reveals and protocol
outputs are fundamentally forms of declassification.  But consistent
with other work \cite{8429300}, we can formulate a version of
probabilistic noninterence conditioned on output that is sound
for passive security. It says that if two low-equivalent secret
inputs generate the same output, then the distributions of corrupt
views are the same. 
\begin{definition}[Noninterference modulo output]
  \label{definition-NIMO}
  We say that a program $\prog$ satisfies \emph{noninterference modulo output}
  iff for all $H$ and $C$ and 
  $\store_1,\store_2 \in \mems(S)$ we have:
  $$
  (\store_1 =_C \store_2 \ \wedge \ 
  (\condd{\progtt(\prog)}{O}{\store_1} = \condd{\progtt(\prog)}{O}{\store_2}))
  \implies 
  (\condd{\progtt(\prog)}{\houtputs}{\store_1} = \condd{\progtt(\prog)}{\houtputs}{\store_2})
  $$
  where $\iov(\prog) = S \cup V \cup O$.
\end{definition}
Intuitively, this conditional noninterference property implies that
the simulator can just run the protocol in simulation to
reconstruct real world corrupt view distributions. But it requires
that the simulator can tractably ``pre-image'' a given output of
a functionality $\idealf$, to determine the inputs that
could have produced it. This pre-image is called a
\emph{kernel} in recent work \cite{XXX}.
\begin{definition}
  Given a functionality $\idealf$ and output value $v$, its
  \emph{kernel}, denoted $\ik(\idealf,v)$ is
  $
  \{ \store\ |\ \idealf(\store) = v \}
  $.
  We say that $\idealf$ is \emph{pre-imageable} iff $\ik(\idealf, v)$ for all
  $v$ can be computed tractably.
\end{definition}
A soundness result for passive security can then be stated as follows.
We prove this in a separate manuscript \cite{XXX}, and it is also
essentially the same as ``perfect passive NI security'' which
has a similar soundness property \cite{8429300}.  
\begin{restatable}{theorem}{nimosecure}
  \label{theorem-nimo}
  Assume given pre-imageable $\idealf$ and a protocol $\prog$ that
  correctly implements $\idealf$.  If $\prog$ satisfies noninference modulo output
  then $\prog$ is passive secure.
\end{restatable}

\subsection{Gradual Release as a Design Pattern}

Previous work has discussed how MPC security is not noninterference,
but rather how ideal functional sets an upper bound on
declassification \cite{6266151,almeida2018enforcing}. Nevertheless,
probabilistic noninterference is preserved by components of
cryptographic protocols generally, and can be expressed using
\emph{probabilistic independence} \cite{darais2019language,barthe2019probabilistic}
We introduce important notation to express independence:
\begin{definition}
%  We write $\vc{\pmf}{x}{y}$ iff $\pmf(\{ x \mapsto 0\}\ |\ \{ y \mapsto 0 \}) =
%  \pmf(\{ x \mapsto 1\}\ |\ \{ y \mapsto 1 \}) = 1$.
  We write $\sep{\pmf}{X}{Y}$ iff for all
    $\store \in \mems(X \cup Y)$ we have
  $\margd{\pmf}{X \cup Y}(\store) =
  \pmf(\store_X) * \pmf(\store_Y)$
\end{definition}

In fact, MPC protocols typically satisfy a \emph{gradual release}
property\cite{XXX}, where messages exchanged remain probabilistically separable
from secrets, with only declassification events (reveals and outputs)
releasing information about honest secrets. 
\begin{definition}
  Given $H,C$, a protocol $\prog$ with $\iov(\prog) = S \cup M \cup P \cup O$
  satisfies \emph{gradual release} iff
  $\sep{\progtt(\prog)}{\houtputs}{S_H}$.
\end{definition}

\subsection{Malicious Security and Robust Declassification}

\begin{definition}
  We say that a protocol $\prog$ with $\iov(\prog) = (S,M)$ satisfies \emph{active confidentiality} iff the following conditions hold
  for all adversaries $\adversary$:
  \begin{enumerate}
  \item $\ \,\forall \store \in \mems(S_H) \ .\ \support(\progtt(\prog)(\{ \outv \}|\store)) =
    \support(\progtt(\prog,\adversary)(\{ \outv \}|\store))$
  \item $\begin{array}[t]{l}\forall \store_1, \store_2 \in \mems(S_H), \store \in \mems(\cinputs)\ . \\
    \quad
    \condd{\progtt(\prog,\adversary)}{\{ \outv \}}{\store_1 \cup \store} =
    \condd{\progtt(\prog,\adversary)}{\{ \outv \}}{\store_2 \cup \store} \\
    \qquad \implies\\
    \quad
    \condd{\progtt(\prog,\adversary)}{\houtputs}{\store_1 \cup \store} =
    \condd{\progtt(\prog,\adversary)}{\houtputs}{\store_2 \cup \store}\end{array}$
  \end{enumerate}
\end{definition}

\begin{theorem}
  If $\prog$ satisfies active confidentiality for all $H,C$ then it is malicious secure.
\end{theorem}

\begin{definition}
  A protocol $\prog$ with has \emph{integrity} iff 
  $\forall \adversary . \runs_\adversary(\prog) \subseteq \runs(\prog)$.
\end{definition}

\begin{definition}
  A protocol $\prog$ with $\iov(\prog) = (S,M,O)$ is \emph{malicious correct} iff:
  $$
  \forall \adversary, \store \in \mems(S_H) \ .\ \support(\progtt(\prog)(O_H|\store)) =
    \support(\progtt(\prog,\adversary)(O_H|\store))
  $$
\end{definition}

\begin{theorem}
  If a protocol has integrity it is malicious correct.
\end{theorem}

\begin{theorem}
  If a protocol is passive secure with integrity, then it satisfies active confidentiality.
\end{theorem}

\begin{theorem}
  If a protocol is passive secure with integrity, then it is malicious secure.
\end{theorem}

\begin{definition}[Robust Declassification]
  A protocol satisfies \emph{robust declassification} iff it has integrity and
  satisfies gradual release. 
\end{definition}

\begin{theorem}
  Passive security with robust declassification implies malicious security.
\end{theorem}
