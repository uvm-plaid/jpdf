package plaid.prelude.cvc

import org.junit.Test
import io.github.cvc5._
import org.junit.Assert.{assertEquals, assertNotEquals}
import plaid.prelude.ast.{MessageExpr, Str}

class QuickstartTest {

  /** Are two numbers generated by two different term managers equal? */
  @Test
  @throws[Exception]
  def compareElements(): Unit = {
    val termManager1 = new TermManager()
    val termManager2 = new TermManager()

    val sort1 = termManager1.mkFiniteFieldSort("2", 10)
    val sort2 = termManager2.mkFiniteFieldSort("2", 10)
    val minusOne1 = termManager1.mkFiniteFieldElem("-1", sort1, 10)
    val minusOne2 = termManager2.mkFiniteFieldElem("-1", sort2, 10)
    assertEquals(minusOne1, minusOne2)
  }

  /** Are constants generated by two different term managers but having the same name equal? */
  @Test
  @throws[Exception]
  def compareTermsFromTwoTermManagers(): Unit = {
    val termManager1 = new TermManager()
    val termManager2 = new TermManager()

    val sort1 = termManager1.mkFiniteFieldSort("2", 10)
    val sort2 = termManager2.mkFiniteFieldSort("2", 10)

    val m_x_1 = termManager1.mkConst(sort1, "m_x")
    val m_x_2 = termManager2.mkConst(sort2, "m_x")

    assertNotEquals(m_x_1, m_x_2)
  }

  /** Using the same term manager, is a term equal to one constructed by TermFactory? */
  @Test
  @throws[Exception]
  def compareTermsFromTermManagers(): Unit = {
    val tm = new TermManager()
    val sort = tm.mkFiniteFieldSort("2", 10)
    val m_x_1 = tm.mkConst(sort, "m_x_1")

    val factory = new TermFactory(tm, sort)
    assertNotEquals(m_x_1, factory.toTerm(MessageExpr(Str("x")), 1))
  }

  @Test
  @throws[Exception]
  def printModel(): Unit = {
    val tm = new TermManager()
    val sort = tm.mkFiniteFieldSort("2", 10)
    val solver = new Solver(tm)
    solver.setOption("produce-models", "true")
    // solver.setOption("finite-model-find", "true")

    solver.setLogic("ALL")
    solver.resetAssertions()

    val m_x_1 = tm.mkFiniteFieldElem("1", sort, 10)
    val s_x_2 = tm.mkConst(sort, "s_x_2")
    val r_x_2 = tm.mkConst(sort, "r_x_2")

    val constraint1 = tm.mkTerm(Kind.EQUAL, m_x_1, tm.mkTerm(Kind.FINITE_FIELD_ADD, s_x_2, r_x_2))
    val minusOne = tm.mkFiniteFieldElem("-1", sort, 10)
    // val constraint1 = tm.mkTerm(Kind.EQUAL, m_x_1, tm.mkTerm(Kind.FINITE_FIELD_ADD, s_x_2, tm.mkTerm(Kind.FINITE_FIELD_MULT, r_x_2, minusOne)))

    solver.assertFormula(constraint1)

    val r = solver.checkSat()

    // get values for the memories that satisfy the constraint
    val m_x_1_val = solver.getValue(m_x_1)
    val s_x_2_val = solver.getValue(s_x_2)
    val r_x_2_val = solver.getValue(r_x_2)

    // convert the values to Java types
    val m_x_1_FiniteFieldValue = m_x_1_val.getFiniteFieldValue
    val s_x_2_FiniteFieldValue = s_x_2_val.getFiniteFieldValue
    val r_x_2_FiniteFieldValue = r_x_2_val.getFiniteFieldValue

    // Optionally print the values for debugging
    // println(s"m_x_1: $m_x_1_FiniteFieldValue, s_x_2: $s_x_2_FiniteFieldValue, r_x_2: $r_x_2_FiniteFieldValue")
  }
}
