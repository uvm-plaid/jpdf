\section{Compositional Properties: Garbled $\NIMO$}
\label{section-composition}

Using YGC as a case study, in this Section we will discuss
compositional properties that can be automatically verified on small
program components using techniques developed in Section
\ref{section-bruteforce}. These properties compose to yield $\NIMO$
and scale to arbitrary programs. We will express these properties
manually as pre-~and post-conditions on components, so our
general approach is in a proof assistance style. The properties
we use are refinements of $\NIMO$, and the overall technique is
enabled by the intensional character of our program distribution
formulation.

\subsection{A Library for Yao's Garbled Circuits}
\label{section-metalang-ygc}

\input{ygc}

In Figures \ref{fig-ygc-aux} and \ref{fig-ygc-gates} we define a
codebase for garbled circuits. This definition follows the
\emph{point-and-permute} method described in \cite{evans2018pragmatic} and elsewhere,
to which the reader is referred for more in-depth discussion.
In this implementation client 2 is the \emph{garbler} and
client 1 is the \emph{evaluator}. The garbler builds the garbled
tables and shares them with the evaluator, who then evaluates
the gate in an oblivious fashion until the final public output is
generated through decryption. This definition is well-typed,
with input type annotations for top-level functions listed in
Figure \ref{fig-ygc-types}. Well-typed programs using these
libraries are therefore guaranteed to yield safe $\minifed$
programs. 

\emph{Wire labels} are fundamental to YGC, and essentially represent
gate output values in an encrypted form. In our definition, wire
labels are represented by records $\ttt{\{ k = }\beta_1\ttt{; p =
}\beta_2\ttt{ \}}$, where $\ttt{k}$ is the \emph{key bit} and
$\ttt{p}$ is the \emph{pointer bit}, and $\beta_1$ and $\beta_2$ are
flips. Flips in each output wire label are owned by the garbler and
are unique per gate by definition of their identifying string, and the
representation of $0$ is the negation of $1$. For example, here is the
representation of 1 and 0 respectively in the output wire label for a
hypothetical gate 6:
\begin{mathpar}
  \ttt{\{ k = flip[2,gate:6.k]; p =  flip[2,gate:6.p]] \}}
    
  \ttt{\{ k = not flip[2,gate:6.k]; p =  not flip[2,gate:6.p]] \}}
\end{mathpar}
The pointer bits in wire labels are used to select permuted rows in
table garblings. The key bits are used to identify a unique key for
table row in each garbled gate. Intuitively, if $\beta_1$ and
$\beta_2$ are either key or pointer bits encoding 1 on two input wire
labels to a binary gate, rows and keys in the gate are enumerated in
the order:
$$
\neg\beta_1\neg\beta_2,\ \neg\beta_1\beta_2,\ \beta_1\neg\beta_2,\ \beta_1\beta_2
$$

In our implementation, gates are wired together using gate
identifiers, which are strings $w$. Top-level functionality in Figures
\ref{fig-ygc-aux} and \ref{fig-ygc-gates} includes the following:
\begin{itemize}
\item \ttt{andgate}: This defines a subprotocol for the garbler
  to define a garbled gate $\ttt{gid}$ with input wires from gates
  $\ttt{ga}$ and $\ttt{gb}$. The garbler generates keys and garbles
  the rows in YGC fashion, them with client $1$ in
  views in a standard form. For example, the view for
  a hypothetical gate 6, row 2 garbled truth table is $\ttt{v[1,gate:6tt2]}$.
  We note that garbled gates of other binary operators can be obtained with
  replacement of $\ttt{andtable}$ with appropriate garbled table definitions. 
\item \ttt{evalgate}: This defines a subprotocol for the evaluator to
  evaluate gate $\ttt{gid}$ given input wire values $\ttt{wva}$ and
  $\ttt{wvb}$.
\item \ttt{garbledecode} and \ttt{evaldecode}: The former function
  defines the garbler's protocol for encrypting the circuit
  output from final gate $\ttt{gid}$, and the latter defines
  the evaluator's output decryption protocol.
\item \ttt{encode}: This defines the initial phase of the protocol,
  where the evaluator receives the wire value from their own
  secret $\sx{1}{sa}$ via $\ttt{OT}$, and the garbler communicates
  the wire value for their own secret $\sx{2}{sb}$ directly.
\end{itemize}
\begin{example}
  \label{example-andcircuit}
The following program uses our YGC library to define
a circuit with a single and gate and input secrets $\ttt{s1}$ and
$\ttt{s2}$ from client's 1 and 2 respectively. 
\begin{verbatimtab}
  andgate(0,s1,s2);
  garbledecode(0);
  let secrets = encode(s1,s2) in
  v[0,output] := decode(evalgate(0, secrets.wv1, secrets.wv2))
\end{verbatimtab}
\end{example}
We have verified passive security of the $\fedprot$ protocol
generated by this and other small circuits using the
technique described in Lemma \ref{lemma-bruteforce-nimo}.
But large circuits with thousands of gates would be
intractable to verify with this method. In the next Section
we discuss compositional methods to address this issue.

\subsection{Verification of Pre-~and Post-Conditions}

A basic intuition about YGC is that garbled gates considered
individually are ``nearly'' passive secure, modulo the feature that
outputs of individual logic gates in circuits are encrypted. That is,
each gate enjoys an encrypted variant of $\NIMO$ such that the relevant
output is not in the clear but correlated flips sampled for the gate's
output wire label by the garbler, both key and pointer bits. We call
this \emph{Garbled $\NIMO$}, or $\gNIMO$. In the definition of
$\gNIMO$ we consider whether a given value $\itv$ correlates
positively or negatively to the flip chosen for a wire label, which
can be either $1$ or $0$ uniformly- recall that
Definition \ref{def-progd} posits a variable $\itv$ to refer to the
expression $\be$ when considering the distribution
$\progd(\prog,\be)$.
\begin{definition}[Garbled $\NIMO$]
  We write $\gNIMO(\prog,\{ \ttt{k} = \be_{\ttt{k}}; \ttt{p} =
  \be_{\ttt{p}}\}, g)$ with $\iov(\prog) = S \cup V$ iff for all $H$,
  $C$ with $|C| \le |H|$, for all $\store \in \mems(S_C \cup V_C)$,
  for both $w \in \{\ttt{p},\ttt{k}\}$, and for all $\stores$ with
  domain $X = S_C \cup V_C \cup \{ \itv, \flip{2}{\ttt{gate:}g.w} \}$
  such that:
  $$
  \stores = \{ \store' \mid \store \subset \store' \wedge 
  \store'(\itv) = \store'(\flip{2}{\ttt{gate:}g.w}) \} 
  $$
  or
  $$
  \stores = \{ \store' \mid \store \subset \store' \wedge 
  \store'(\itv) = \neg\store'(\flip{2}{\ttt{gate:}g.w}) \} 
  $$
  %where for any $\beta$:
  %$$\store^2 = \store\{ \flip{2}{\ttt{gate:}g.w} \mapsto \beta \}\{ \itv \mapsto \beta \}$$
  %or
  %$$
  %\store^2 = \store\{ \flip{2}{\ttt{gate:}g.w} \mapsto \beta \}\{ \itv \mapsto \neg\beta \}
  %$$
  we have:
  $$
  \margd{(\condd{\progd(\prog,\be_w)}{\stores_{X-{V_C}}})}{S_H} =
  \margd{(\condd{\progd(\prog,\be_w)}{\stores})}{S_H}
  $$
\end{definition}

\subsubsection{Verification Witnesses}

\cnote{Lemmas \ref{lemma-scope} and \ref{lemma-gnimo} in this Section may need some
refinement but I think the general argument is reasonably developed.}

Our aim is to demonstrated that $\gNIMO$ is preserved by gates within circuits,
where preservation is expressed via pre-~and post-conditions. We can use
techniques in Section \ref{section-bruteforce} to automatically verify postconditions
for components, using witness programs that satisfy preconditions prior to
component execution. For example, we can automatically verify that $\ttt{encode}$
generates a program and wire values the enjoy $\gNIMO$. Then, to verify
correctness of $\ttt{and}$ gate construction and evaluation- i.e., that it
preserves $\gNIMO$- we can verify
that the $\minifed$ program and wire value generated by the following program
$\metaprot$ program satisfies $\gNIMO$:
\begin{verbatimtab}
  let secrets = encode(s1,s2) in
  andgate(0,s1,s2); evalgate(secrets.wv1,secrets.wv2)
\end{verbatimtab}
However, we need to establish that $\ttt{encode(s1,s2)}$ is an
adequate witness, in that it ensures that automated verification generalizes to
arbitrary circuit contexts. 
  
An important part of this argument is probabilistic independence,
and in related reasoning we can leverage prior work on probabilistic
separation logic \cite{barthe2019probabilistic}. We will use an
analog of their separation formula, which we define in our setting as follows:
\begin{definition}
  We write $(\margd{\pdf{X}}{Y}) * (\margd{\pdf{X}}{X-Y})$ iff
  $\pdf{X}(\store) = \pdf{X}(\store_{Y}) * \pdf{X}(\store_{X-Y})$
  for all $\store \in \mems(X)$.
\end{definition}

\begin{definition}
  We say that $\prog$ \emph{covers} $X$ iff
  $\progd(\prog)(\store) > 0$ for all $\store\in\mems(X)$.
\end{definition}

We aim to show that gates are probabilistically independent of each
other (i.e., are separated), and this independence supports
correctness-preserving composition. A critical property is that
separation is preserved by safe (in the sense of Theorem
\ref{theorem-metalang-safety}) substitution of programs, assuming
disjointness of flips used in programs separated programs.
\begin{lemma}
  \label{lemma-scope}
  Let $X = \vars(\prog_1) \cap \vars(\prog_2)$.
  If $(\margd{\progd(\prog_1;\prog_2)}{\iov(\prog_1)}) *
  (\margd{\progd(\prog_1;\prog_2)}{\iov(\prog_2)})$ and $\prog_1$
  covers $X$, then 
  $(\margd{\progd(\prog_1';\prog_2)}{\iov(\prog_1)}) *
  (\margd{\progd(\prog_1';\prog_2)}{\iov(\prog_2)})$ for any
  $\prog_1'$ such that $\vars(\prog_1') \cap \vars(\prog_2) = X$ and
  $\prog_1';\prog_2$ is safe.
\end{lemma}
\begin{proof}
  Suppose on the contrary that there exists $\prog_1'$ that is not
  separable from $\prog_2$. By results in
  \cite{barthe2019probabilistic}, this implies that there
  exists $\store^n$ and $\store^n$ for $0 \le n \le 1$ such that
  $\store^1_X = \store^{1'}_X$ where:
  $$
  \config{\store^0}{\prog_1;\prog_2} \redxs \config{\store^1}{\prog_2} \redxs
  \config{\store^2}{\varnothing}
  $$
  and:
  $$
  \config{\store^{0}}{\prog_1;\prog_2} \redxs \config{\store^{1'}}{\prog_2} \redxs
  \config{\store^{2'}}{\varnothing}
  $$
  where $\store^2_{\vars(\prog_2)} \ne \store^{2'}_{\vars(\prog_2)}$, which is a
  contradiction.
%   This implies that there is some
%  $\store \in \mems(\vars(\prog_1';\prog_2))$ such that
%  $\store_{\vars{\prog_{1}'}} \in \runs{\prog_1'}$ and
%  \mems(\vars(\prog_1))$ with   
\end{proof}

We must also choose witnesses that allow us to generalize verification
of $\gNIMO$ preservation through gates. We need to consider separately
the definition of gates and their use. Our type discipline ensures that
gates can only be defined once, but it is also known that gate output
wire labels should only be used once \cite{nieminen2023breaking}, in which case we
say they are \emph{wired}. We return to this issue in more detail in
Section \ref{section-composition-copy}.
\begin{definition}
  We write $g \in \prog$ iff all views for $g$'s table are fully
  defined in $\prog$. We write $\wired(\prog)$ to denote the
  set of gates $g$ whose views occur on the rhs of an assignment
  in $\prog$.
  %$\view{1}{\ttt{gate:}g\ttt{tt}i} \in \iov(\prog)$
  %and $\view{1}{\ttt{gate:}g\ttt{pt}i} \in \iov(\prog)$ for all $0 < i \le 4$,
  %or  $\view{1}{\ttt{gate:}gi\ttt{.k}} \in \iov(\prog)$
  %and $\view{1}{\ttt{gate:}gi\ttt{.p}} \in \iov(\prog)$ for all $0 < i \le 2$.
\end{definition}
Given the above definition, the needed result follows by Lemma \ref{lemma-scope} and definition
of $\gNIMO$:
\begin{lemma}
  \label{lemma-gnimo}
  Let $X = \vars(\prog_1) \cap \vars(\prog_2)$.
  If $(\margd{\progd(\prog_1;\prog_2)}{\iov(\prog_1)}) * (\margd{\progd(\prog_1;\prog_2)}{\iov(\prog_2)})$
  and
  $\gNIMO(\prog_1;\prog_2,\{ \ttt{k} = \be_{\ttt{k}}; \ttt{p} = \be_{\ttt{p}}\}, g)$ for
  $g \in \prog_2$,
  then $\gNIMO(\prog_1';\prog_2,\{ \ttt{k} = \be_{\ttt{k}}; \ttt{p} = \be_{\ttt{p}}\}, g)$
  for any $\prog_1'$ where $\prog_1';\prog_2$ is safe and
  $\vars(\prog_1') \cap \vars(\prog_2) = X$.
\end{lemma}

\subsubsection{Pre-~ and Post-Conditions}
\label{section-pre-post}
Now we can establish relevant pre-~and post-conditions for the
top-level YGC functions defined in Figure \ref{fig-ygc-gates}. We note
that in addition to the automated verification mechanisms described in
Section \ref{section-bruteforce}, type safety in $\metaprot$ plays an
important role, in part by ensuring that gates are uniquely defined
(as views).

Our strategy is to consider input encoding, internal gates, and
output decoding separately. To begin, we show that input encoding
establishes generates a program and wire values that initialize
the $\gNIMO$ invariant in the circuit. There is no precondition
witness needed for this result, which holds in any type-safe
program context since the variables used by $\ttt{encode}$
are all fresh. 
\begin{lemma}[Input Encoding]
  \label{lemma-encode}
  Given well-typed $\prog_1;E[\ttt{encode}(s_1,s_2)]$ where:
  $$
  \config{\prog_1}{E[\ttt{encode}(s_1,s_2)]} \redxs
  \config{\prog_1;\prog_2}{E[\ttt{\{wv1=}v_1\ttt{;wv2=}v_2\ttt{\}}]}
  $$
  Then:
  $$\gNIMO(\prog_1;\prog_2,v_1,s_1) \wedge \gNIMO(\prog_1;\prog_2,v_2,s_2)$$
\end{lemma}

\begin{proof}
  We have automatically verified
  $\gNIMO(\prog_2,v_1,\ttt{s1})$ and $\gNIMO(\prog_2,v_1,\ttt{s1})$
  where:
  $$
  \config{\varnothing}{\ttt{encode(s1,s2)}} \redxs
  \config{\prog_2}{\ttt{\{wv1=}v_1\ttt{;wv2=}v_2\ttt{\}}}
  $$
  using the method described in Section \ref{section-bruteforce-tables}.
  Given arbitrary $\prog_1$ such that $\prog_1;\ttt{encode}(s_1,s_2)$
  is well-typed, hence $\prog_1;\prog_2$ is safe, 
  since $\ttt{encode}$ uses unique secrets and flips per gates and
  gates (views) are not redefined in safe programs,
  $(\iov(\prog_1) \cup \flips(\prog_1)) \cap (\iov(\prog_2) \cup
  \flips(\prog_2)) = \varnothing$. This implies 
  $(\margd{\progd(\prog_1;\prog_2)}{\iov(\prog_1)}) *
  (\margd{\progd(\prog_1;\prog_2)}{\iov(\prog_2)})$, so the result follows
  by Lemma \ref{lemma-gnimo}.
\end{proof}

One nuance in our results for internal gates and for decoding is that the relevant
compositional units are the complete related subprotocols, including both
the garbler's construction of the gates and the evaluator's evaluation of
them. We therefore make the following definitions. However, we note that
our formal results are applicable to the YGC style where the garbler shares
the entire circuit prior to evaluation, rather than gate-by-gate during
evaluation. 
\begin{definition}
  \label{ygc-modules}
  We define a composable internal \ttt{and} gate sharing and evaluation function
  called $\ttt{andgg}$, and an output decoder gate share and evaluation function called
  $\ttt{decode}$, as follows. 
\begin{verbatimtab}
  andgg(g, ga, gb, wva, wvb) { andgate(g, ga, gb); evalgate(g, wva, wvb) }
 
  decode(g, v) { garbledecode(g); evaldecode(v) }
\end{verbatimtab}
\end{definition}

Now we can demonstrate that our $\ttt{and}$ gate definition preserves
$\gNIMO$, and additionally that internale gates are probabilistically independent.
This latter fact is crucial to compositionality, and allows us for automatically
verify the circuit in isolation, with input encoding serving as an adequate input
witness for generalization. 
\begin{lemma}[Composition ($\eand$)]
  \label{lemma-compose}
Given well-typed $\prog_1;E[\ttt{andgg}(g,g_1,g_2,v_1,v_2)]$ where:
$$
\config{\prog_1}{E[\ttt{andgg}(g,g_1,g_2,v_1,v_2)]} \redxs \config{\prog_1;\prog_2}{E[v]}
$$
If the following preconditions hold:
\begin{enumerate}
\item $(\{ g_1 \} \sqcup \{ g_2 \}) \cap \wired(\prog_1) = \varnothing$
\item $\gNIMO(\prog_1,v_1,g_1) \wedge \gNIMO(\prog_1,v_2,g_2)$ 
\end{enumerate}
then we have as postconditions:
\begin{enumerate}
  \item $\gNIMO(\prog_1;\prog_2,v,g)$
  \item $(\margd{\progd(\prog_1;\prog_2)}{\iov(\prog_1)}) * (\margd{\progd(\prog_1;\prog_2)}{\iov(\prog_2)})$
\end{enumerate}
\end{lemma}
\begin{proof}
  We have automatically verified the postconditions (1) and (2) for the particular
  program $\prog_1;\prog_2$ resulting from execution of:
  $$e\quad \defeq\quad \ttt{let gs = encode(s1,s2) in andgg(0,s1,s2,gs.wv1,gs.wv2)}$$
  where:
  $$
  \config{\varnothing}{e} \redxs
  \config{\prog_1}{\ttt{andgg}(\ttt{0},\ttt{s1},\ttt{s2},v_1,v_2)} \redxs \config{\prog_1;\prog_2}{v}
  $$
  By Lemma \ref{lemma-encode} we have that
  $\gNIMO(\prog_1,v_1,\ttt{s1}) \wedge \gNIMO(\prog_1,v_2,\ttt{s2})$. 
  And since $\ttt{andgate}$ generates unique flips per gate, and well-typedness ensures
  uniqueness of gates, we can generalize the result to replace $\prog_1$ with arbitrary $\prog_1'$
  such that $\prog_1';\prog_2$ is safe,
  applying Lemma \ref{lemma-scope} to obtain postcondition (2) and Lemma \ref{lemma-gnimo}
  to obtain postcondition (1). 
\end{proof}
Finally, we can demonstrate that decoding correctly casts a garbled output into the
clear, and thus establishes $\NIMO$ for the garbled circuit that precedes it.
\begin{lemma}[Decoding]
  \label{lemma-decode}
Given well-typed $\prog_1;E[\ttt{decode}(g,v)]$ where
$$
\config{\prog_1}{E[\ttt{decode}(g,v)]} \redxs \config{\prog_1;\prog_2}{E[\be]}
$$
If $\gNIMO(\prog_1,v,g)$, then $\NIMO(\prog_1;\prog_2;\eassign{\outv}{\be})$.
\end{lemma}
\begin{proof}
  We have automatically verified $
  \progd(\prog,\be)(\{ \itv \mapsto 1 \}) = 1$ where:
  $$\config{\varnothing}{\ttt{decode(g,\{ k = flip[2, gate:g.k]; p = flip[2,gate:g.p] \})}}
    \redxs \config{\prog}{\be}$$
    and also $
  \progd(\prog,\be)(\{ \itv \mapsto 0 \}) = 1$ where:
  $$\config{\varnothing}{\ttt{decode(g,\{ k = not flip[2, gate:g.k]; p = not flip[2,gate:g.p] \})}}
    \redxs \config{\prog}{\be}$$
  The result follows by definition of $\gNIMO$ and $\NIMO$.
\end{proof}


\begin{fpfig}[t]{YGC copy gate definitions.}{fig-ygc-copy}
  {\footnotesize
    \begin{verbatimtab}
      sharetab2(gid, tid, k, p, b)
      {
        let r1 = k xor b in
        let r0 = (not k) xor (not b) in
        v[1,gate: || gid || tid || 1] := select(p,r1,r0);
        v[1,gate: || gid || tid || 2] := select(not p,r1,r0);
      }
      
      copygate(ca,cb,g)
      {
        let wl = owl(g) in
        let owl1 = owl(ca) in
        let owl2 = owl(cb) in
        sharetab2(ca,tt,wl.k,wl.p,owl1.k); sharetab2(ca,pt,wl.k,wl.p,owl1.p);
        sharetab2(cb,tt,wl.k,wl.p,owl2.k); sharetab2(cb,pt,wl.k,wl.p,owl2.p)
      }
      
      evalcopy(ca,cb,wv)
      {
        let wv1k = wv.k xor select(wv.p,v[1,gate: || ca || tt1], v[1,gate: || ca || tt2]) in
        let wv1p = wv.k xor select(wv.p,v[1,gate: || ca || pt1], v[1,gate: || ca || pt1]) in
        let wv2k = wv.k xor select(wv.p,v[1,gate: || cb || tt1], v[1,gate: || cb || tt2]) in
        let wv2p = wv.k xor select(wv.p,v[1,gate: || cb || pt1], v[1,gate: || cb || pt1]) in
        { wv1 = { k = wv1k; p = wv1p }; wv2 = { k = wv2k; p = wv2p } }  
      }

      copy(ca,cb,g,wv) { copygate(ca,cb,g); evalcopy(ca,cb,wv) } 
    \end{verbatimtab}
  }
\end{fpfig}

\subsection{Building and Extending Automatically Secure Circuits}
\label{section-composition-copy}

Our results in Section \ref{section-pre-post} and Theorem
\ref{theorem-nimo} imply that any well-typed program using
$\ttt{encode}$, $\ttt{andgg}$, and $\ttt{decode}$ will generate a
circuit that is passive secure, provided that gate outputs are
not used more than once. To add an $\ttt{or}$ gate to our
library, we can use $\ttt{andgg}$ as a template, in fact simple
modification of $\ttt{andtable}$ is all that would be needed. Thus,
this library embodies a Fairplay-like language where well-typedness
of metaprograms guarantees safety and security of generated protocols.

The requirements that output wire labels are not used more than once
reflects a known result, that naive copy gate output is unsound in
YGC- i.e., passive security fails. In fact, we are unable to
automatically verify $\gNIMO$ for $\ttt{andgg}$ without the assumption
that input wire lables are in independent uniform distributions. We
can capture the necessary fix as in Figure \ref{fig-ygc-copy}. The
garbler creates a copy gate with two new output wire labels in
independent uniform distributions (in \ttt{copygate}), and permutes
them using the input wire label pointer after encrypting with the
input wire label keys. The evaluator then recovers the encrypted
output wire values during evaluation (in \ttt{evalcopy}). Given an
$\ttt{orgg}$ gate defined as outlined abotve, we can then use
secure $\ttt{copy}$ as follows: 
\begin{verbatimtab}
  let s = encode(s1,s2) in
  let s1c = copy(c1s1,c2s1,s1,s.wv1) in
  let s2c = copy(c1s2,c2s2,s2,s.wv2) in
  let wv1 = andgg(1,c1s1,c1s2,s1c.wv1,s2c.wv1) in
  let wv2 = orgg(2,c2s1,c2s2,s1c.wv2,s2c.wv2) in
  decode(3,andgg(3,1,2,wv1,wv2))
\end{verbatimtab}
These definitions of $\ttt{copy}$ and $\ttt{orgg}$ have been
automatically verified as in Section \ref{section-pre-post} for
$\ttt{andgg}$. In general, any new gate form- such as optimized gates
\cite{XXX}- can be verified automatically in a similar way.

While the copy gate supports secure programming patterns, security
still relies on programmer discipline, i.e., not wiring a gate more
than once. However, we can keep track of wired gates in type effects,
similar to the manner in which we keep track of defined views- type
dependence in our system is able to accurately precisely track
gate identifiers. This is also reminiscent of the use of linearity
in other related systems for enforcing obliviousness \cite{darais2019language}. 
