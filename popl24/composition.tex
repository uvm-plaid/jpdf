\section{Compositional Properties: Garbled $\NIMO$}
\label{section-composition}

\subsection{A Library for Yao's Garbled Circuits}
\label{section-metalang-ygc}

\input{ygc}

In Figures \ref{fig-ygc-aux} and \ref{fig-ygc-gates} we define a
codebase for garbled circuits. This definition follows the
\emph{point-and-permute} method described in \cite{XXX} and elsewhere,
to which the reader is referred for more in-depth discussion.
In this implementation client 2 is the \emph{garbler} and
client 1 is the \emph{evaluator}. The garbler builds the garbled
tables and shares them with the evaluator, who then evaluates
the gate in an oblivious fashion until the final public output is
generated through decryption.

\emph{Wire labels} are fundamental to YGC, and essentially represent
gate output values in an encrypted form. In our definition, wire
labels are representated by records $\ttt{\{ k = }\beta_1\ttt{; p =
}\beta_2\ttt{ \}}$, where $\ttt{k}$ is the \emph{key bit} and
$\ttt{p}$ is the \emph{pointer bit}, and $\beta_1$ and $\beta_2$ are
flips. Flips in each output wire label are owned by the garbler and
are unique per gate by definition of their identifying string, and the
representation of $0$ is the negation of $1$. For example, here is the
representation of 1 and 0 respectively in the output wire label for a
hypothetical gate 6:
\begin{mathpar}
  \ttt{\{ k = flip[2,gate:6.k]; p =  flip[2,gate:6.p]] \}}
    
  \ttt{\{ k = not flip[2,gate:6.k]; p =  not flip[2,gate:6.p]] \}}
\end{mathpar}
The pointer bits in wire labels are used to select permuted rows in
table garblings. The key bits are used to identify a unique key for
table row in each garbled gate. Intuitively, if $\beta_1$ and
$\beta_2$ are either key or pointer bits encoding 1 on two input wire
labels to a binary gate, rows and keys in the gate are enumerated in
the order:
$$
\neg\beta_1\neg\beta_2,\ \neg\beta_1\beta_2,\ \beta_1\neg\beta_2,\ \beta_1\beta_2
$$

In our implementation, gates are wired together using gate
identifiers, which are strings $w$. Top-level functionality in Figures
\ref{fig-ygc-aux} and \ref{fig-ygc-gates} includes the following:
\begin{itemize}
\item \ttt{andgate}: This defines a subprotocol for the garbler
  to define a garbled gate $\ttt{gid}$ with input wires from gates
  $\ttt{ga}$ and $\ttt{gb}$. The garbler generates keys and garbles
  the rows in YGC fashion, them with client $1$ in
  views in a standard form. For example, the view for
  a hypothetical gate 6, row 2 garbled truth table is $\ttt{v[1,gate:6tt2]}$.
  We note that garbled gates of other binary operators can be obtained with
  replacement of $\ttt{andtable}$ with appropriate garbled  table definitions. 
\item \ttt{evalgate}: This defines a subprotocol for the evaluator to
  evaluate gate $\ttt{gid}$ given input wire values $\ttt{wva}$ and
  $\ttt{wvb}$.
\item \ttt{garbledecode} and \ttt{evaldecode}: The former function
  defines the garbler's protocol for encrypting the circuit
  output from final gate $\ttt{gid}$, and the latter defines
  the evaluator's output decryption protocol.
\item \ttt{encode}: This defines the initial phase of the protocol,
  where the evaluator receives the wire value from their own
  secret $\sx{1}{sa}$ via $\ttt{OT}$, and the garbler communicates
  the wire value for their own secret $\sx{2}{sb}$ directly.
\end{itemize}
Here is an example program that uses this library to define
a ciruit with a single and gate and input secrets $\ttt{s1}$ and
$\ttt{s2}$ from client's 1 and 2 respectively. 
\begin{verbatimtab}
  andgate(0,s1,s2);
  garbledecode(0);
  let secrets = encode(s1,s2) in
  v[0,output] := decode(evalgate(0, secrets.wv1, secrets.wv2))
\end{verbatimtab}
We have verified passive security of the $\fedprot$ protocol
generated by this and other small circuits using the
technique described in Lemma \ref{lemma-bruteforce-nimo}.
But obviously large circuits with thousands of gates would be
intractable to verify with this method. In the next Section
we discuss compositional methods to address this issue.

\subsection{Garbled $\NIMO$ as Pre-~and Post-Conditions}

\begin{verbatimtab}
andgg(g, wla, wlb, wlc, wva, wvb) {
andgate(g, wla, wlb, wlc);
evalgate(g, wva, wvb)
}
\end{verbatimtab}

\begin{definition}[Garbled $\NIMO$]
  We write $\gNIMO(\prog,\{ \ttt{k} = \be_{\ttt{k}}; \ttt{p} = \be_{\ttt{p}}\}, g)$ iff for all $H$, $C$,
  both $w \in \{\ttt{p},\ttt{k}\}$, and all 
  memories $\store \in \mems(\iov(\prog) \cup \{ \itv \})$ where
  $
  \store(\itv) = \store(\flip{2}{g.w})$ or $\store(\itv) = \neg\store(\flip{2}{g.w})
  $
  it is the case that:
  $$
  \margd{(\condd{\progd(\prog,\be_w)}{\store_{S_C \cup \{\itv \}}})}{S_H} =
  \margd{(\condd{\progd(\prog,\be_w)}{\store_{S_C \cup V_C \cup \{\itv \}}})}{S_H}
  $$
\end{definition}

\begin{definition}
  We write $\owl(\prog, \{ \ttt{k} = \be_{\ttt{k}}; \ttt{p} = \be_{\ttt{p}}\}, g)$
  iff for all $b$ and both $w \in \{\ttt{p},\ttt{k}\}$:
  $$
  (\margd{(\condd{\progd(\prog,\be_{w})}{\{ \flip{2}{g.w} \mapsto b \}})}{\itv})(\{ \itv \mapsto b\}) = 1
  $$
\end{definition}

\begin{lemma}[Input Encoding]
Assume given the following evaluation relation:
$$
\config{\prog_1}{E[\ttt{encode}(w,v_1,v_2)]} \redxs \config{\prog_1;\prog_2}{E[v]}
$$
If there exists gate identifiers $g_1, g_2$ such that:
\begin{enumerate}
  \item $g_1 \ne g_2 \wedge g_1,g_2 \not\in \gates(\prog_1)$
  \item $\owl(\prog_1,v_1,g_1) \wedge \owl(\prog_1,v_2,g_2)$
\end{enumerate}
then:
\begin{enumerate}
\item $g_1,g_2 \in  \gates(\prog_2)$
\item $\gNIMO(\prog_1;\prog_2,v.\ttt{wv1},g_1) \wedge \gNIMO(\prog_1;\prog_2,v.\ttt{wv2},g_2)$
\item $(\margd{\progd(\prog_1;\prog_2)}{\iov(\prog_1)}) * (\margd{\progd(\prog_1;\prog_2)}{\iov(\prog_2)})$
\end{enumerate}
\end{lemma}

\begin{lemma}[Composition ($\eand$)]
Assume given the following evaluation relation:
$$
\config{\prog_1}{E[\ttt{andgg}(g,v_1,\ldots,v_5)]} \redxs \config{\prog_1;\prog_2}{E[v_6]}
$$
If there exist gate identifiers $g_1, g_2$ such that:
\begin{enumerate}
  \item $g_1 \ne g_2 \ne g \wedge g_1,g_2 \in \gates(\prog_1) \wedge g \not\in \gates(\prog_1)$
  \item $\owl(\prog_1,v_1,g_1) \wedge \owl(\prog_1,v_2,g_2)$
  \item $\gNIMO(\prog_1,v_4,g_1) \wedge \gNIMO(\prog_1,v_5,g_2)$
\end{enumerate}
then:
\begin{enumerate}
  \item $g \in \gates(\prog_2) \wedge \owl(\prog_1;\prog_2,v_3,g)$
  \item $\gNIMO(\prog_1;\prog_2,v_6,g)$
  \item $(\margd{\progd(\prog_1;\prog_2)}{\iov(\prog_1)}) * (\margd{\progd(\prog_1;\prog_2)}{\iov(\prog_2)})$
\end{enumerate}
\end{lemma}

\begin{lemma}[Decoding]
Assume given the following evaluation relation:
$$
\config{\prog_1}{E[\ttt{decoder}(v_1,v_2)]} \redxs \config{\prog_1;\prog_2}{E[\be]}
$$
If there exists gate identifier $g \in \gates(\prog_1)$ such that:
\begin{enumerate}
  \item $\owl(\prog_1,v_1,g)$
  \item $\gNIMO(\prog_1,v_2,g)$
\end{enumerate}
Then $\NIMO(\prog_1;\prog_2;\eassign{x}{\be})$.
\end{lemma}

