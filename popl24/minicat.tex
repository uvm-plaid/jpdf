\section{The $\minifed$ Language}
\label{section-minicat}

The $\minifed$ language provides a simple model of synchronous
protocols between a federation of \emph{clients} exchanging values in
the binary field. We will identify clients by natural numbers, and
federations- finite sets of clients- are always given statically.
As we will see, our threat model assumes a partition of the federation
into \emph{honest} $H$ and \emph{corrupt} $C$ subsets.

We model probabilistic programming via the \emph{random tape}
approach. That is, we will assume that programs can make reference to
values chosen from a uniform random distribution- coin ``flips''- via
values arbitrarily assigned in the initial program memory.  Programs
execute deterministically given the random tape. The random tape
formulation supports our automated analysis as we discuss in
section 

\subsection{Syntax} The syntax of $\minifed$, defined in
Figure \ref{fig-minifed-syntax}, includes a standard boolean algebra
with $\eand$, $\eor$, $\exor$, and $\enot$ as primitives. In addition
programs have different kinds of variables, including \emph{secrets}
$\secret{\cid}{w}$, \emph{flips} $\flip{\cid}{w}$, and \emph{views}
$\view{\cid}{w}$.  Each of these variables are indexed by an ``owner''
client $\cid$ and distinguishing string $w$. So for example,
$\secret{\ttt{1}}{\ttt{foo}}$ is client $\ttt{1}$'s secret called
$\ttt{foo}$. All clients can make reference to the \emph{oracle}
through variables $\oracle{w}$- this is a form of shared randomness
that is standard in the MPC setting \cite{evans2018pragmatic}.  Each client can only
compute on their own variables in \emph{expressions} $\be$, and share
values with other clients by assignment to their views as in
$\eassign{\view{\cid}{w}}{\be}$.  A \emph{protocol} $\prog$ is a
possibly empty sequence of view assignments. We will generally omit
$\varnothing$ from example code, writing $\instr_1;\ldots;\instr_n$
instead of $\instr_1;\ldots;\instr_n;\varnothing$, and abusing notation we will
write $\prog_1;\prog_2$ to denote the concatenation of $\prog_1$
and $\prog_2$.



\begin{fpfig}[t]{$\minifed$ source code syntax.}{fig-minifed-syntax}
$$
\begin{array}{rcl@{\hspace{8mm}}r}
b &\in& \{ \etrue, \efalse \} \\
w &\in& \mathrm{String} \\ 
\cid &\in& \mathrm{Clients} \subset  \mathbb{N} \\[2mm]%\qquad  (\mathrm{Clients} \subset \mathbb{N} \text{\ in\ this\ presentation})\\[2mm]
\bop &\in& \{ \eand, \eor, \exor \} \\[2mm]
\be &::=& b \mid \flip{\cid}{w} \mid \secret{\cid}{w} \mid \view{\cid}{w} \mid \oracle{w} \mid & \textit{boolean expressions}\\
& &  \enot\ \be \mid \be\ \bop\ \be \mid \select{\be}{\be}{\be} \mid \OT{\be}{\be}{\be} \\[2mm]
\instr &::=& \eassign{\view{\cid}{w}}{\be} & \textit{view assignments} \\[2mm]
\prog &::=& \varnothing \mid \instr; \prog & \textit{protocols}
\end{array}
$$ 
\end{fpfig}

We let $X$ range over sets of variables and $S,V,F$ to range over sets
of secrets, views, and flips (including invocations of the oracle)
respectively. Given a program $\prog$, we write $\iov(\prog)$ to
denote $S \cup V$ where $S$ is the set of secret variables in $\prog$
and $V$ is the set of views in $\prog$, we write $\flips(\prog)$
to denote the set $F$ of flip variables in $\prog$, and we
write $\vars(\prog)$ to denote $\iov(\prog) \cup \flips(\prog)$. For any set of
variables $X$ and parties $P$, we write $X_P$ to denote the subset of
$X$ owned by any party in $P$, and we write $X_H$ and $X_C$ to denote
the subsets belonging to honest and corrupt parties, respectively.

Expressions forms include the convenience
$\select{\be_1}{\be_2}{\be_3}$ which is essentially a conditional
expression with:
$$
\select{\be_1}{\be_2}{\be_3} \equiv (\be_1\ \eand\ \be_2)\ \eor\ (\enot\ \be_1\ \eand\ \be_3)
$$
We also include \emph{oblivious transfer} $\OT{\be_1}{\be_2}{\be_3}$ as a primitive,
with semantics similar to $\ttt{select}$ but with important nuances
related to communication between clients as we discuss more below.
As we will demonstrate, it is not necessary to include $\ttt{OT}$
as a primitive since we can implement it in a provably secure
fashion. However its inclusion simplifies our presentation and is a useful
convenience.

\subsection{Semantics}

\emph{Memories} are fundamental to the semantics of $\fedcat$ and
provide the random tape and secret inputs to protocols, and record
view assignments. Memories $\store$ are finite (partial) mapping from
variables to binary values $\beta \in \{0,1\}$. The \emph{domain} of a
memory is written $\dom(\store)$ and is the finite set of variables on
which the memory is defined. We write $\store\{ x \mapsto \beta\}$ for
$x\not\in\dom(\store)$ to denote the memory $\store'$ such that
$\store'(x) = \beta$ and otherwise $\store'(y) = \store(y)$ for all $y
\in \dom(\store)$. We write $\store_1 \subseteq \store_2$ iff
$\dom(\store_1) \subseteq \dom(\store_2)$ and $\store_1(x) =
\store_2(x)$ for all $x \in \dom(\store_1)$. We write $\store_1 \cap
\store_2$ to denote the combination of $\store_1$ and $\store_2$
assuming $\store_1(x) = \store_2(x)$ for all $x \in \dom(\store_1)
\cap \dom(\store_2)$, otherwise $\store_1 \cap \store_2$ is undefined.

Given a set of variables $X$, we write $\store_X$ to denoted the
memory $\store$ restricted to the domain $X$, and and we define
$\mems(X)$ as the set of all memories with domain $X$:
$$
\mems(X) \defeq \{ \store \mid \dom(\store) = X \}
$$
Thus, given a protocol $\prog$, the set of all random tapes for
$\prog$ is $\mems(\flips(\prog))$. We let $\stores$ range
over sets of memories with the same domain, and abusing notation
we write $\dom(\stores)$ to denote the common domain,
and $\stores_X \defeq \{ \store_X | \store \in \stores \}$.

Given a variable-free boolean expression $\be$, we write $\cod{\be}$
to denote the standard interpretation of $\be$ in the binary field.
With the introduction of variables to expressions, we have two
concerns. First, we need to interpret variables with respect to a
specific memory, and second, we need to ensure that variables are used
``legally''. That is, since expressions define local computation, all
variables used in an expression must belong to the same client.  Thus,
we denote interpretation of expressions $\be$ possibly containing
variables as $\lcod{\store,\be}{\cid}$, where $\store$ associates
variables with values and all variables must be owned by client
$\cid$. This is defined in Figure \ref{fig-minifed-interp}.

\begin{fpfig}[t]{$\minifed$ expression interpretation.}{fig-minifed-interp}
\begin{eqnarray*}
\lcod{\store, \etrue}{\cid} &=& 1\\
\lcod{\store, \efalse}{\cid} &=& 0\\
\lcod{\store, \flip{\cid}{w}}{\cid} &=& \store(\flip{\cid}{w})\\
\lcod{\store, \secret{\cid}{w}}{\cid} &=& \store(\secret{\cid}{w})\\
\lcod{\store, \view{\cid}{w}}{\cid} &=& \store(\view{\cid}{w})\\
\lcod{\store, \oracle{w}}{\cid} &=& \store(\oracle{w})\\
\lcod{\store, \enot\ \be}{\cid} &=& \cod{\enot\ \lcod{\store,\be}{\cid}}\\
\lcod{\store, \be_1\ \mathit{binop}\ \be_2}{\cid} &=&
    \cod{\lcod{\store,\be_1}{\cid}\ \mathit{binop}\ \lcod{\store,\be_2}{\cid}}\\
\lcod{\store, \select{\be_1}{\be_2}{\be_3}}{\cid} &=&
             \begin{cases}
                \lcod{\store,\be_2}{\cid} & \text{if\ } \lcod{\store,\be_1}{\cid}\\
                \lcod{\store,\be_3}{\cid} & \text{if\ } \neg\lcod{\store,\be_1}{\cid}
             \end{cases}%\\
%\lcod{\store, \OT{\be_1}{\be_2}{\be_3}}{\cid} &=&
%             \begin{cases}
%                \lcod{\store,\be_2}{\cid'} & \text{if\ } \lcod{\store,\be_1}{\cid}\\
%                \lcod{\store,\be_3}{\cid'} & \text{if\ } \neg\lcod{\store,\be_1}{\cid}
%             \end{cases}
\end{eqnarray*}
\end{fpfig}

Evaluation of configurations is then defined via a small-step reduction relation $\redx$.
This is defined in the obvious manner for view assignments other than through
$\ttt{OT}$- however note that reduction requires that views are never reassigned. 
\begin{mathpar}
  (\store, \eassign{\view{\cid}{w}}{\be};\prog) \redx (\extend{\store}{\view{\cid}{w}}{\lcod{\store,\be}{\cid'}}, \prog)
\end{mathpar}
For view assignments through $\ttt{OT}$, we define a different reduction rule that
captures the appropriate semantics- that is, the selection bit is \emph{not} communicated
to the sender (through a view assignment), and only the selected bit is sent to the receiver:
\begin{mathpar}
  \inferrule
  {\beta = \text{if\ } \lcod{\store,\be_1}{\cid}  \text{\ then\ } \lcod{\store,\be_2}{\cid'} \text{\ else\ } \lcod{\store,\be_3}{\cid'}}
      {(\store, \eassign{\view{\cid}{w}}{\OT{\be_1}{\be_2}{\be_3}};\prog) \redx (\extend{\store}{\view{\cid}{w}}{\beta}, \prog)}
\end{mathpar}
We define $\redxs$ as the reflexive, transitive closure of $\redx$.

Given $\prog$ with $\iov(\prog) = S \cup V$ and $\flips(\prog) = F$,
any execution of $\prog$ is assumed to be an evaluation of a
configuration $\config{\store}{\prog}$ where $\store \in \mems(S \cup
F)$- that is, with secrets and the random tape as inputs- and where
$\config{\store}{\prog} \redxs \config{\store'}{\varnothing}$ it is
the case that $\store' \in \mems(S \cup F \cup V)$. We define a
program as \emph{safe} iff for all $\store \in \mems(S \cup F)$ there
exists $\store'$ where $\config{\store}{\prog} \redxs
\config{\store'}{\varnothing}$. Unsafe programs are those where views
are used before they're defined, or where expressions mix owners of
variables. As a sanity condition we will only consider safe 
programs in our presentation of $\fedprot$, though in Section
\ref{section-metalang} we define a type system that guarantees
program safety by construction, as demonstrated in Theorem
\ref{theorem-metalang-safety}.

\subsection{Examples}
\label{section-minicat-examples}

Here we introduce some examples to illustrate $\minifed$ and how it
can be used to model secure communication protocols for values in the
binary field. Most of these are translations (into $\minifed$) of
object examples in previous related work
\cite{barthe2019probabilistic,darais2019language}.  We will return to
these as running examples throughout the paper to illustrate various
concepts and advantages of our methods. In Section
\ref{section-metalang} we will formulate a larger example
implementation of Yao's Garbled Circuits (Example \ref{example-ygc}).
\begin{example}[One-Time Pad]
  \label{example-otp}
As observed in \cite{barthe2019probabilistic} and elsewhere, coin flips with $\exor$ can
be used to model one-time pad encryption in the binary field. On the
basis of this we can model secure communication between over an
insecure channel using symmetric key encryption. In the following
program, we assume $H = \{ 1,2 \}$ and $C = \{ 0 \}$. Client 1 first
shares the randomly generated ``key'' $\fx{1}{0}$ with client 2
through view $\view{2}{0}$. Then, client 1 encrypts its secret
$\sx{1}{0}$ and sends it to party 0, which relays the ciphertext in
$\vx{0}{0}$ to client 2. Finally, client 2 decrypts the the ciphertext
and stores the plaintext in $\vx{2}{2}$.
\begin{verbatimtab}
v[2,0] := f[1,0];
v[0,0] := f[1,0] xor s[1,0];
v[2,1] := v[0,0];
v[2,2] := v[2,1] xor v[2,0]
\end{verbatimtab}
Intuitively, this protocol is \emph{correct} because $\vx{2}{2}$ is
exactly correlated with the secret $\sx{1}{0}$, and it is
\emph{secure} because the corrupt view $\vx{0}{0}$ in isolation is
probabilistically independent of the secret $\sx{1}{0}$.
\end{example}

\begin{example}[$\lambda_{\mathrm{obliv}}$]
  \label{example-lambda-obliv}
  In \cite{darais2019language}, Figure 3, two examples are introduced that illustrate
  subtleties of probabilistic programming in
  $\lambda_{\mathrm{obliv}}$, a language for oblivious memory
  management. We consider their translations here where we
  assume $H = \{ 1 \}$ and $C = \{ 0 \}$. First, the following
  example shows that the reuse of coin flips can result in release of
  information, even though flips are chosen from a uniform
  distribution. This is because the adversary can deduce that
  $\secret{1}{s}$ is more likely to be 1 in case their views are the
  same value. We call this subexample $(a)$:
  \begin{verbatimtab}
    v[0,0] := select(s[1,s], flip[1,sx], flip[1,sy]);
    v[0,1] := flip[1,sx] \end{verbatimtab}
  In the next example, since the nested select is more likely to evaluate
  to $1$ than $0$, the adversary can deduce that $\secret{1}{s}$ is
  more likely to be 1 in case $\view{0}{0}$ is 1. We call this subexample $(b)$:
  \begin{verbatimtab}
  v[0,0] := select(s[1,s],select(flip[1,sx], flip[1,sx], flip[1,sy]),flip[1,z]) \end{verbatimtab}
  We note that these examples are considered ``bad'' in \cite{darais2019language} since there
  no information about honest secrets should be revealed to the adversary in
  their threat model. For this reason they disallow reuse of flips through a
  linear type discipline, which is a culprit in both of these examples. However,
  as we have shown in Example \ref{example-otp} the reuse of flips is useful in
  the modeling of symmetric key encryption, and generally we will not enforce
  the same linear type discipline on the use of flips.
\end{example}

\begin{example}[Oblivious Transfer]
  \label{example-OT}
  In \cite{barthe2019probabilistic} a protocol for $\ttt{OT}$ is defined that we recreate as
  follows, where client 2 is the receiver and client 1 is the sender. Whereas
  in \cite{barthe2019probabilistic} a trusted third party provides the sender and receiver with
  shared randomness, in our version both clients refer to the oracle $\ttt{H}$
  to obtain shared random values. 
\begin{verbatimtab}
  v[2, rd] := select(flip[2, d], H[r1], H[r0]);
  v[1, e] := s[2, c] xor flip[2, d];
  v[2, f0] := s[1, m0] xor select(v[1, e], H[r1], H[r0]);
  v[2, f1] := s[1, m1] xor select(not v[1, e], H[r1], H[r0]);
  v[2, mc] := select(s[2, c], v[2, f1], v[2, f0]) xor v[2, rd]
\end{verbatimtab}
Below we will discuss how to automatically verify security properties
of this protocol that correspond to the properties proven manually in
\cite{barthe2019probabilistic}, and additionally how to automatically verify its passive
security in the simulator model. With respect to our language primitives,
we note that this protocol is probabilistically equivalent to the
following:
\begin{verbatimtab}  
  v[2, mc] := OT(s[2, c], s[1, m1], s[1, m0])
\end{verbatimtab}
\end{example}

\begin{example}[Additive Secret Sharing]
    \label{example-he}
Additive secret sharing is an MPC protocol where $k$ parties split up
their secrets into \emph{shares}, with the property that all $k$
shares are required to reconstruct the secret and any fewer reveals
nothing. Additionally, this sharing enjoys additive homomorphism. In
the binary field it is well-known that we can extend our use
of $\ttt{xor}$ and flips to generate an arbitrary number of shares
with additive homomorphism. 

For example, to generate shares for three-party additive sharing,
clients 1,2, and 3 can break up and distribute their shares to
each other as follows:
\begin{verbatimtab}
  v[2,s1] := flip[1,1] xor flip[1,s1] xor s[1,1];
  v[3,s1] := flip[1,1];

  v[1,s2] := flip[2,1] xor flip[2,s2] xor s[2,1];
  v[3,s2] := flip[2,1];

  v[1,s3] := flip[3,1] xor flip[3,s3] xor s[3,1];
  v[2,s3] := flip[3,1];
\end{verbatimtab}
Then, assuming that party 0 is a ``public'' client, each party sums
its own shares, and then the sum of sum of shares is revealed
in the output view $\vx{0}{output}$. By additive homomorphism of
$\ttt{xor}$, this output is the sum of the 3 secrets.
\begin{verbatimtab}
  v[0,ss1] := v[1,s2] xor v[1,s3] xor flip[1,s1];
  v[0,ss2] := v[2,s1] xor v[2,s3] xor flip[2,s2];
  v[0,ss3] := v[3,s1] xor v[3,s2] xor flip[3,s3];

  v[0,output] := v[0,ss1] xor v[0,ss2] xor v[0,ss3]
\end{verbatimtab}
We note that, as for MPC protocols generally, the notion of
``secrecy'' here is subtle and not the same as for encryption as in
Example \ref{example-otp}, particularly when the threat model allows
protocol participants to be corrupt. For example, suppose that $1 \in C$, and
$\sx{1}{1}$ is $1$, and after running the protocol suppose that
$\vx{0}{output}$ is 0. Then the adversary knows that 2 and 3's secrets
are either 1 and 0, or 0 and 1, with 50/50 probability, and definitely
neither 0 and 0, nor 1 and 1. 
\end{example}
