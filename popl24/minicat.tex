\section{The $\minifed$ Language}


$$
\begin{array}{rcl@{\hspace{8mm}}r}
b &\in& \{ \etrue, \efalse \} \\
w &\in& \mathrm{String} \\ 
\cid &\in& \mathrm{Clients} \qquad  (\mathrm{Clients} \subset \mathbb{N} \text{\ in\ this\ presentation})\\[2mm]
\bop &\in& \{ \eand, \eor, \exor \} \\[2mm]
\be &::=& b \mid \flip{\cid}{w} \mid \secret{\cid}{w} \mid \view{\cid}{w} \mid \oracle{w} \mid & \textit{boolean expressions}\\
& &  \enot\ \be \mid \be\ \bop\ \be \mid \select{\be}{\be}{\be} \mid \OT{\be}{\be}{\be} \\[2mm]
\instr &::=& \eassign{\view{\cid}{w}}{\be} & \textit{view assignments} \\[2mm]
\prog &::=& \varnothing \mid \instr; \prog & \textit{protocols}
\end{array}
$$

\begin{definition}[Memories]
A \emph{memory}, aka \emph{store} $\store$ is a finite (partial) mapping from variables to values.
The \emph{domain} of a memory is written $\dom(\store)$ and is the finite
set of variables on which the memory is defined. We write $\store\{ x \mapsto v\}$
for  $x\not\in\dom(\store)$ to denote the memory $\store'$ such that $\store'(x) = v$ and otherwise
$\store'(y) = \store(y)$ for all $y \in \dom(\store)$.
\end{definition}


\begin{eqnarray*}
\lcod{\store, \etrue}{\cid} &=& \etrue\\
\lcod{\store, \efalse}{\cid} &=& \efalse\\
\lcod{\store, \flip{\cid}{w}}{\cid} &=& \store(\flip{\cid}{w})\\
\lcod{\store, \secret{\cid}{w}}{\cid} &=& \store(\secret{\cid}{w})\\
\lcod{\store, \view{\cid}{w}}{\cid} &=& \store(\view{\cid}{w})\\
\lcod{\store, \oracle{w}}{\cid} &=& \store(\oracle{w})\\
\lcod{\store, \enot\ \be}{\cid} &=& \cod{\enot\ \lcod{\store,\be}{\cid}}\\
\lcod{\store, \be_1\ \mathit{binop}\ \be_2}{\cid} &=&
    \cod{\lcod{\store,\be_1}{\cid}\ \mathit{binop}\ \lcod{\store,\be_2}{\cid}}\\
\lcod{\store, \select{\be_1}{\be_2}{\be_3}}{\cid} &=&
             \begin{cases}
                \lcod{\store,\be_2}{\cid} & \text{if\ } \lcod{\store,\be_1}{\cid}\\
                \lcod{\store,\be_3}{\cid} & \text{if\ } \neg\lcod{\store,\be_1}{\cid}
             \end{cases}%\\
%\lcod{\store, \OT{\be_1}{\be_2}{\be_3}}{\cid} &=&
%             \begin{cases}
%                \lcod{\store,\be_2}{\cid'} & \text{if\ } \lcod{\store,\be_1}{\cid}\\
%                \lcod{\store,\be_3}{\cid'} & \text{if\ } \neg\lcod{\store,\be_1}{\cid}
%             \end{cases}
\end{eqnarray*}

\begin{mathpar}
  (\store, \eassign{\view{\cid}{w}}{\be};\prog) \redx (\extend{\store}{\view{\cid}{w}}{\lcod{\store,\be}{\cid'}}, \prog)

  \inferrule
  {b = \text{if\ } \lcod{\store,\be_1}{\cid}  \text{\ then\ } \lcod{\store,\be_2}{\cid'} \text{\ else\ } \lcod{\store,\be_3}{\cid'}}
      {(\store, \eassign{\view{\cid}{w}}{\OT{\be_1}{\be_2}{\be_3}};\prog) \redx (\extend{\store}{\view{\cid}{w}}{b}, \prog)}
\end{mathpar}



\paragraph{Variable and Memory Conventions} Given a program $\prog$, we
write $\iov(\prog)$ to denote the pair $(S,V)$
where $S$ is the set of secret variables in $\prog$ and
$V$ is the set of views in $\prog$, and we write $\flips(\prog)$ to
denote the set $F$ of flip variables in $\prog$. For any set of variables $X$
and parties $P$, we write $X_P$ to denote the subset
of $X$ owned by any party in $P$, and we write $X_H$ and
$X_C$ to denote the subsets belonging to honest and
corrupt parties, respectively.

Given a set of variables $X$, we write $\store_X$ to mean the memory
$\store$ restricted to the domain $X$, and
and we define $\mems(X)$ as:
$$
\mems(X) \defeq \{ \store \mid \dom(\store) = X \}
$$
We will also write $\store_1 \cup \store_2$ to denote
the memory resulting by combining disjoint
memories $\store_1$ and $\store_2$, i.e.,
under the assumption that $\dom(\store_1) \cap \dom(\store_2) = \varnothing$.
