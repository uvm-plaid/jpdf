\section{Hyperproperties of MPC Passive Security}
\label{section-hyperprop}

As we've discussed in our section on Related Work
(\ref{section-related}), previous authors have noted connections
between the traditional formulation of the MPC security model- aka the
simulator security model- and hyperproperty-style formulations of
program trace behavior \cite{XXX} including probabilistic
noninterference. This formulation of hyperproperties that are at least
sound with respect to simulator security bridges a conceptual gap
between foundational approaches to security, and also motivates and
supports automated analysis \cite{XXX}. 

In this section, we formulate a new hyperproperty that we show is sound
for passive security in the real/ideal model, called
\emph{noninterference modulo output ($\NIMO$)}. We do not claim
completeness with respect to passive security, but soundness
guarantees that enforcement of $\NIMO$ in our analyses implies passive
security. In Section \ref{section-bruteforce} we show how $\NIMO$ can
be automatically enforced in a brute-force manner, and in Section
\ref{section-composition} we show how $\NIMO$ can be refined to obtain
compositional properties supporting efficient, scalable enforcement of
complex protocols that incorporate modular subprotocols, with a
specific use-case of Yao's Garbled Circuits (YGC) as an example where
garbled gates are the compositional units.  The latter methodology
demonstrates a particular advantage of our hyperproperty formulation.

\subsection{Passive Security and the Real/Ideal Model} \dnote{would shortening the background info on how simulator model works be a bad idea?} Here we
briefly summarize the formal definition of MPC security. For a
more detailed discussion the reader is referred to \cite{XXX}.
In this paper, we will consider the \emph{passive} aka
semi-honest aka honest-but-curious variant. In this threat
model, protocol participants can be corrupted, but all clients
follow the rules of the protocol- as opposed to the
\emph{active} aka malicious variant where participants
are allowed to break these rules. In the passive model, the
vulnerability is through information leaked to the adversary
through the views of corrupted participants. While the passive
model also assumes that any clients can potentially be
corrupted, it assumes that no more than half will be-
i.e., it assumes an \emph{honest majority}. 

The real/ideal model posits a \emph{simulator} that exists in an ideal
world, whose goal is to reconstruct observable information in a real
world run of a protocol $\prog$ that correctly implements an ideal
functionality $\idealf$- that is, execution of a configuration
$\config{\store}{\prog}$. We will assume that any protocol $\prog$
includes a public \emph{output view} $\outv$ where the result is
published, where $0$ is the ``public'' client and thus $\outv$
is of the form $\view{0}{w}$ for some $w$, i.e., is owned by 0.
Note that the protocol is \emph{correct} iff the resulting
memory contains $\outv \mapsto \idealf(\store_S)$, where $S$ are the
secret inputs (honest and corrupt) in $\prog$.

The simulator is given just the corrupt inputs to the run- that is,
$\store_{S_C}$- and the output of the protocol- that is,
$\idealf(\store)$- and aims to reconstruct the distribution of
adversarial views observed in the real world. The intuition here is
that the simulator is given the information that is necessarily
available to the adversary by observing a run of the protocol, and if
the simulator can reconstruct whatever information appears in the real
world adversarial views, by reconstructing their distributions, then
those views leak no additional information, i.e., they have no
additional dependencies on honest input secrets than what is revealed
by the output and conditionings on corrupt inputs.

The simulator is represented by a probabilistic algorithm $\SIM_C$,
aka a \emph{simulation}, that is parameterized by a corrupt inputs and
the output of an ideal functionality, and that returns a set of
adversarial views (as a memory) with some probability. Given
corrupt inputs $\store$ and ideal functionality output $v$,  
we write:
$$
\prob(\SIM_C(\store,v) = \store')
$$
to denote the probability that $\SIM_C(\store,v)$
returns corrupt views $\store'$ as a result. We can then define the
probability distribution of corrupt views reconstructed
by the simulator as follows:
\begin{definition}
  Given $C$, $\store$, and $v$, we write $\progd(\SIM_C(\store,v))$ to
  denote the distribution of corrupt views reconstructed by the
  simulation, which is a distribution $\pdf{V}$ where for
  all $\store' \in \mems(V)$:
  $$
  \pdf{V}(\store')\ \defeq\ \prob(\SIM_C(\store,v) = \store') 
  $$
\end{definition}

Then we can define passive security in the real/ideal
model as follows. 
\begin{definition}[Passive Security]
  Assume given a program $\prog$ that correctly implements an ideal
  functionality $\idealf$, with $\iov(\prog) = (S,V)$.  Then $\prog$
  is \emph{passive secure in the simulator model} iff for all
  partitions of the federation into honest and corrupt sets $H$ and $C$
  with $|C| < |H|$ and for all $\store \in \mems(S)$ there exists a
  simulation $\SIM_C$ such that:
  $$
  \progd(\SIM_C(\store_{S_C},\idealf(\store))) = \margd{(\condd{\progd(\prog)}{\store})}{V_C}
  $$
\end{definition}

\subsection{Probabilistic Noninterference}
\label{section-ni}
Previous work has noted
relations between probabilistic noninterference and security
properties such as memory trace obliviousness \cite{XXX} and passive
security \cite{XXX}. And above (Section \ref{section-pmf-examples}) we
have demonstrated that our basic encryption scheme enjoys a noninterference
property. To formulate probabilistic noninterference in
our setting we begin by defining low equivalence of memories.
\begin{definition}[Memory Low Equivalence]
  Given $\store^1$ and $\store^2$ with $\dom(\store^1) = \dom(\store^2) = X$,
  we write $\store^1 =_C \store^2$ iff $\store^1_{X_C} = \store^2_{X_C}$.
\end{definition}
Now, we can define probabilistic noninterference as a property of
programs ensuring that low-equivalent initial memories produce
the same low-observable trace (i.e., corrupt views) \emph{with the
same probability}. 
\begin{definition}[Probabilistic Noninterference]
  Given a program $\prog$ with $\iov(\prog) = (S,V)$, we say that
  $\prog$ satisfies \emph{probabilistic noninterference} iff for all
  $\store_1, \store_2 \in \mems(S)$:
  $$\store_1 =_C \store_2 \implies
    \margd{(\condd{\progd(\prog)}{\store_1})}{V_C} =
    \margd{(\condd{\progd(\prog)}{\store_2})}{V_C}$$
\end{definition}

Despite the intuitive resonance between noninterference
and passive security, since MPC
protocols implement an ideal functionality, they cannot generally satisfy
noninterference. We can easily demonstrate this by using
Example \ref{example-he} as a failure witness, where we'll
assume $C = \{0,2\}$ and $H = \{1,3\}$:
$$
(\progd(\prog_{\ref{example-he}}))({\outv \mapsto 1}|\{\{\sx{1}{1} \mapsto 0, \sx{2}{1} \mapsto 1, \sx{3}{1} \mapsto 0 \} \})
= 1
$$
whereas:
$$
(\progd(\prog_{\ref{example-he}}))({\outv \mapsto 1}|\{\{\sx{1}{1} \mapsto 1, \sx{2}{1} \mapsto 1, \sx{3}{1} \mapsto 0 \} \})
= 0
$$

Probabilistic noninterference can also be restated to formally capture a
basic intuition that noninterfering programs do not provide
the adversary with any clues about honest secrets through corrupt
views, as in the following Lemma. This is similar to asserting that
adversarial knowledge is not increased by the execution of a program as in formulations
of so-called gradual release \cite{XXX}. 
\begin{lemma}
  Given a program $\prog$ with $\iov(\prog) = (S,V)$, 
  $\prog$ satisfies probabilistic noninterference iff for all
  $\store \in \mems(S \cup V)$:
  $$\margd{(\condd{\progd(\prog)}{\store_{S_C}})}{S_H} =
    \margd{(\condd{\progd(\prog)}{\store_{(S\cup V)_C}})}{S_H} $$
\end{lemma}

\subsection{A Sound Hyperproperty for Passive Security}
\label{section-nimo}
The intuition that passive security means that the protocol releases
no more information than what is released by conditioning on the
public output and corrupt inputs suggests a
refinement of noninterference. That is, the set of low equivalent
initial memories \emph{that can produce the same output} should generate the
same distributions of adversarial views.
\begin{definition}[Noninterference Modulo Output]
  We say that a program  $\prog$ satisfies \emph{noninterference modulo output},
  written $\NIMO(\prog)$, iff for all $H$ and $C$ with $|C|\le|H|$ and 
  $\store_1,\store_2 \in \mems(S)$ we have:
  \begin{eqnarray*}
    & \store_1 =_C \store_2 \wedge
     (\margd{(\condd{\progd(\prog)}{\store_1})}{\{ \outv \}} =
     \margd{(\condd{\progd(\prog)}{\store_2})}{\{ \outv \}}) \\
    & \implies \\
    & \margd{(\condd{\progd(\prog)}{\store_1})}{V_C} =
    \margd{(\condd{\progd(\prog)}{\store_2})}{V_C}
  \end{eqnarray*}
where $\iov(\prog) = (S,V)$.
\end{definition}

From an information flow perspective, we can say that a $\NIMO$
protocol does not release information beyond what is declassified
via the public output. From a real/ideal perspective, we can
observe that $\NIMO$ implies that the simulator can use
the protocol itself to reconstruct the distribution of adversarial
views. That is, given the output of the ideal functionality
$\idealf(\store_S)$, the simulator can randomly choose any
$\store'$ such that $\store' =_C \store$ and $\idealf(\store'_S) =
\idealf(\store_S)$ and run the protocol with initial memory $\store'$-
$\NIMO$ guarantees ideal reconstruction of the real-world corrupt views. 
 However, there is a subtlety here in that the adversary
must be able to tractably reconstruct this knowledge. This is not
generally true, in particular, if $\idealf$ is a 1-way
function. Define:
\begin{definition}[Ideal Knowledge]
  Given a functionality $\idealf$ and output value $v$, the associated
  \emph{ideal knowledge}, denoted $\ik(\idealf,v)$ is:
  $$
  \{ \store\ |\ \idealf(\store) = v \}
  $$
  We say that $\idealf$ is \emph{invertible} iff $\ik(\idealf, v)$ for all
  $v$ can be computed tractably.
\end{definition}
Now we can show our main result, that noninterference modulo output,
together with the assumption that $\idealf$ is invertible, implies
passive security of a protocol.
\begin{theorem}
  \label{theorem-nimo}
  Assume given invertible $\idealf$ and a protocol $\prog$ that
  correctly implements $\idealf$.  If $\NIMO(\prog)$
  then $\prog$ is passive secure.
\end{theorem}

\begin{proof}
  Let $H$ and $C$ be an arbitrary partition of the federation and
  suppose $\prog$ satisfies noninterference modulo output. Let
  $\iov(\prog) = (V,S)$ and $\flips(\prog) = F$ with output view $x
  \in V$ and let $\store$ be an arbitrary member of $\mems(S \cup
  F)$. Then the distribution of adversarial views in the real world
  is, by definition:
  $$\margd{(\condd{\progd(\prog)}{\store_S})}{V_C}$$

  The simulator is given both $\store_{S_C}$ and
  $\idealf(\store_S)$.  The simulation $\SIM_C(\store_{S_C},
  \idealf(\store_S))$ can be defined as follows. First, some $\store'
  \in \ik(\idealf,\idealf(\store))$ is randomly chosen such that
  $\store' =_C \store_S$, as is a random tape $\store'' \in
  \mems(F)$\footnote{The real/ideal model allows consultation of a
  ``Random Oracle''.}. Then, the run of $(\store' \cup \store'',
  \prog)$ is evaluated in simulation, yielding $(\store^{\SIM},\varnothing)$.
  The simulation returns $\store^{\SIM}_{V_C}$ as a result.

  Now, since the random tape is selected in simulation from the same distribution
  that we assume for the real world, after selection of $\store'$ the
  probability that any particular $\store^{\SIM}_{V_C}$ is returned is by definition:
  $$
   (\margd{(\condd{\progd(\prog)}{\store'})}{V_C})(\store^{\SIM}_{V_C})
  $$
  Furthermore, since we assume that $\prog$ correctly implements $\idealf$, this
  means:
  $$
  \store_S =_C \store' \wedge
     (\margd{(\condd{\progd(\prog)}{\store_S})}{\{ x \}} =
      \margd{(\condd{\progd(\prog)}{\store'})}{\{ x \}})
  $$
  so by the definition of noninterference modulo output the choice
  any choice of $\store'$ yields the same distribution, i.e.:
  $$\margd{(\condd{\progd(\prog)}{\store_S})}{V_C}$$
  Thus, by definition:
  $$
   \progd(\SIM_C(\store_{S_C},\idealf(\store))) = \margd{(\condd{\progd(\prog)}{\store_S})}{V_C}
  $$
\end{proof}

As for noninterference, we can show that $\NIMO$ is equivalent
to saying that a given program does not change the probability
of honest secrets conditioned on corrupt secrets and views
(including the output view), as compared to conditioning on
just the corrupt secrets and input. In addition to providing
insights about $\NIMO$, this form is helpful for
verification techniques. 
\begin{lemma}
  \label{lemma-nimo}
  $\NIMO(\prog)$ iff for all $H$ and $C$ with $|C| \le |H|$ and
  $\store \in \mems(S \cup V)$:
  $$\margd{(\condd{\progd(\prog)}{\store_{(S \cup \{\outv\})_C}})}{S_H} =
  \margd{(\condd{\progd(\prog)}{\store_{(S\cup V)_C}})}{S_H} $$
  where  $\iov(\prog) = (S,V)$.
\end{lemma}
