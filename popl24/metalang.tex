\section{A Protocol Metalanguage}

$$
\begin{array}{rcl@{\hspace{8mm}}r}
b &\in& \{ \etrue, \efalse \} \\
w &\in& \mathrm{String} \\ 
\cid &\in& \mathrm{Clients} \qquad  (\mathrm{Clients} \subset \mathbb{N} \text{\ in\ this\ presentation})\\[2mm]
\bop &\in& \{ \eand, \eor, \exor \} \\[2mm]
\be &::=& b \mid \flip{\cid}{w} \mid \secret{\cid}{w} \mid \view{\cid}{w} \mid \oracle{w} \mid & \textit{boolean expressions}\\
& &  \enot\ \be \mid \be\ \bop\ \be \mid \select{\be}{\be}{\be} \\[2mm]
\instr &::=& \eassign{\view{\cid}{w}}{\be} \mid \eassign{\view{\cid}{w}}{\OT{\be}{\be}{\be}} & \textit{view assignments} \\[2mm]
\prog &::=& \instr \mid \instr; \prog & \textit{protocols}
\end{array}
$$

\begin{eqnarray*}
\lcod{\store, \etrue}{\cid} &=& \etrue\\
\lcod{\store, \efalse}{\cid} &=& \efalse\\
\lcod{\store, \flip{\cid}{w}}{\cid} &=& \store(\flip{\cid}{w})\\
\lcod{\store, \secret{\cid}{w}}{\cid} &=& \store(\secret{\cid}{w})\\
\lcod{\store, \view{\cid}{w}}{\cid} &=& \store(\view{\cid}{w})\\
\lcod{\store, \oracle{w}}{\cid} &=& \store(\oracle{w})\\
\lcod{\store, \enot\ \be}{\cid} &=& \cod{\enot\ \lcod{\store,\be}{\cid}}\\
\lcod{\store, \be_1\ \mathit{binop}\ \be_2}{\cid} &=&
    \cod{\lcod{\store,\be_1}{\cid}\ \mathit{binop}\ \lcod{\store,\be_2}{\cid}}\\
\lcod{\store, \select{\be_1}{\be_2}{\be_3}}{\cid} &=&
             \begin{cases}
                \lcod{\store,\be_2}{\cid} & \text{if\ } \lcod{\store,\be_1}{\cid}\\
                \lcod{\store,\be_3}{\cid} & \text{otherwise}
             \end{cases}
\end{eqnarray*}

\begin{mathpar}
  (\store, \eassign{\view{\cid}{w}}{\be};\prog) \redx (\extend{\store}{\view{\cid}{w}}{\lcod{\store,\be}{\cid}}, \prog)

  \inferrule
  {b = \text{if\ } \lcod{\store,\be_1}{\cid}  \text{\ then\ } \lcod{\store,\be_2}{\cid'} \text{\ else\ } \lcod{\store,\be_3}{\cid'}}
      {(\store, \eassign{\view{\cid}{w}}{\OT{\be_1}{\be_2}{\be_3}};\prog) \redx (\extend{\store}{\view{\cid}{w}}{b}, \prog)}
\end{mathpar}

$$
\begin{array}{rcl@{\hspace{8mm}}r}
\flab &\in& \mathrm{Field}\\
x &\in& \mathrm{EVar}\\
f &\in& \mathrm{FName}\\[2mm]
e &::=& b \mid \flip{e}{e} \mid \secret{e}{e} \mid \view{e}{e} \mid \oracle{e} \mid \enot\ e \mid e\ \eand\ e \mid e\ \exor\ e \mid & \textit{expressions}\\[0mm]
& & \select{e}{e}{e} \mid 
\send{\view{e}{e}}{e} \mid \send{\view{e}{e}}{\OT{e}{e}{e}} \mid e;e \mid \\[0mm]
& & x \mid \elet{x}{e}{e} \mid f(e,\ldots,e) \mid \{ \flab = e; \ldots; \flab = e \}
\mid e.\flab \mid e\ttt{||}e \mid (e) \\[2mm]
v &::=& w \mid b \mid \cid \mid \{ \flab = v;\ldots;\flab = v \} 
\mid (\,) & \textit{values}\\[2mm]
{fn} &::=& f(x,\ldots,x) \{ e \} & \textit{functions}
\end{array}
$$

\begin{definition}
A \emph{codebase} $\codebase$ is a list of function 
declarations. We write $ \codebase(f) = x_1,\ldots,x_n,\ e$
iff $f(x_1,\ldots,x_n) \{ e \} \in \codebase$.
A \emph{metaprogram}, aka \emph{mataprotocol} is a pair of a 
codebase and expression $\codebase, e$. We may omit
$\codebase$ if it is clear from context.  
\end{definition}

$$
\begin{array}{rcl@{\hspace{3mm}}r}
E &::=& [\,] \mid \enot\ E \mid E\ \bop\ e \mid v\ \bop\ E \mid & \textit{evaluation contexts}\\[1mm]
& & \flip{E}{e} \mid \secret{E}{e} \mid \view{E}{e} \mid \oracle{E} \mid  \\[1mm]
& & \flip{\cid}{E} \mid \secret{\cid}{E} \mid \view{\cid}{E} \mid \send{E}{e} \mid \send{\view{\cid}{w}}{E}\\[1mm]
& & \OT{E}{e}{e} \mid \OT{v}{E}{e} \mid \OT{v}{v}{E} \mid\\[1mm]
& & \select{E}{e}{e} \mid \select{v}{E}{e} \mid \select{v}{v}{E} \mid\\[1mm]
& & \elet{x}{E}{e} \mid f(v,\ldots,v,E,e,\ldots,e) \mid \\[1mm]
& & \{ \flab = v;\ldots;\flab = v;\flab = E;\flab = e;\ldots;\flab = e \} \mid E.\flab \mid E\ttt{||}e \mid v \ttt{||}E
\end{array}
$$

$$
\begin{array}{rcl@{\hspace{10mm}}r}
\config{\prog}{\elet{x}{v}{e}} &\redx& \config{\prog}{e[v/x]}\\
\config{\prog}{f(v_1,...,v_n)} &\redx&
\config{\prog}{e[v_1/x_1,\ldots,v_n/x_n]} & 
 \codebase(f) = x_1,\ldots,x_n,\ e\\
\config{\prog}{\{\ldots; \flab = v; \ldots\}.\flab} &\redx&
 \config{\prog}{v}\\
 \config{\prog}{w_1\ttt{||}w_2} &\redx& \config{\prog}{w_1w_2}\\
 \config{\prog}{v;e} &\redx& \config{\prog}{e}\\
\config{\prog}{\instr} &\redx& \config{\prog;\instr}{()}\\
\config{\prog}{E[e]} &\redx& \config{\prog'}{E[e']} & \text{if}\ \config{\prog}{e} \redx \config{\prog'}{e'} 
\end{array}
$$


