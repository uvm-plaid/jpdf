\section{A Protocol Metalanguage}
\label{section-metalang}

\begin{fpfig}[t]{Syntax of $\metaprot$.}{fig-metaprot-syntax}
$$
\begin{array}{rcl@{\hspace{8mm}}r}
\flab &\in& \mathrm{Field}\\
x &\in& \mathrm{EVar}\\
f &\in& \mathrm{FName}\\[2mm]
e &::=& b \mid \flip{e}{e} \mid \secret{e}{e} \mid \view{e}{e} \mid \oracle{e} \mid \enot\ e \mid e\ \eand\ e \mid e\ \exor\ e \mid & \textit{expressions}\\[0mm]
& & \select{e}{e}{e} \mid 
\send{\view{e}{e}}{e} \mid \send{\view{e}{e}}{\OT{e}{e}{e}} \mid e;e \mid \\[0mm]
& & x \mid \elet{x}{e}{e} \mid f(e,\ldots,e) \mid \{ \flab = e; \ldots; \flab = e \}
\mid e.\flab \mid e\concat e \mid (e) \\[2mm]
v &::=& w \mid \cid \mid \be \mid \{ \flab = v;\ldots;\flab = v \} 
\mid \ttt{()} & \textit{values}\\[2mm]
{fn} &::=& f(x,\ldots,x) \{ e \} & \textit{functions}
\end{array}
$$
\end{fpfig}

Large practical MPC computations are based on much larger protocols
than the examples we've considered so far. These larger protocols are
typically based on compositional units. An example of this is Yao's
Garbled Circuits (YGC), which are composed of so-called garbled gates.
Languages for defined garbled circuits, beginning with Fairplay \cite{269581},
treat gates as compositional units that are wired together by the programmer
to generate a complete circuit. The $\fedprot$ language is low-level
and does not include abstractions for defining composable elements. 

In this Section we introduce the $\metaprot$ language which includes
structured data and function definitions, which are sufficiently
expressive to define composable protocol elements such as garbled
gates. The $\metaprot$ language is a \emph{metalanguage}, in the sense
that it produces $\fedprot$ protocols as a result of computation. That
is, $\metaprot$ is a high-level language that generates low-level
protocol code.

\subsection{Syntax}

The syntax of $\metaprot$ is defined in Figure
\ref{fig-metaprot-syntax}.  It includes a syntax of function
definitions and records, and values include client ids, identifier
strings, and boolean expressions. Expression forms allow dynamic
construction of boolean expression forms and view assignments. When
$\metaprot$ programs construct a $\fedprot$ assignment, a side effect
occurs whereby the assignment is added to the end of the $\fedprot$
program accumulated during evaluation.

Formally, we consider a complete metaprogram to include both a
codebase and a ``main'' program that uses the codebase. 
\begin{definition}
A \emph{codebase} $\codebase$ is a list of function 
declarations. We write $ \codebase(f) = x_1,\ldots,x_n,\ e$
iff $f(x_1,\ldots,x_n) \{ e \} \in \codebase$.
A \emph{metaprogram}, aka \emph{mataprotocol} is a pair of a 
codebase and expression $\codebase, e$. We may omit
$\codebase$ if it is clear from context.  
\end{definition}

When we consider the example of YGC in detail below, our focus will be
on developing a codebase that can be used to define arbitrary
circuits, i.e., complete and concrete protocols. Since strings and
identifiers can be constructed manually, and expressions can occur
inside assignments and boolean expression forms, function definitions
can generalize over $\fedprot$-level patterns to obtain composable
program units. As a simple example, consider 3 party secret
sharing as illustrated in Example \ref{example-he}. We can
define a function $\ttt{share3}$ that abstracts the process
of splitting a given client's secret into 3 separate shares.
\begin{example} \label{example-share3} The function $\ttt{share3}$ 
  splits a client's secret into 3 shares returned as a record
  with fields $\ttt{s1-3}$:
  \begin{verbatimtab}
    share3(client, secretid)
    {
      let s1 = flip[client, share1] in
      let s2 = flip[client, share2] in
      let s3 = (s1 xor s2) xor s[client, s: || secretid] in
      {s1 = s1;s2 = s2;s3 = s3}
    } \end{verbatimtab}
  Here is $\metaprot$ program that uses this this function definition:
  \begin{verbatimtab}
    let shares = share3(1, mysecret) in
    v[2,s1] := shares.s2;
    v[3,s1] := shares.s3 \end{verbatimtab}
  which generates the following $\minifed$ program, as we formalize in Example \ref{example-share3-eval}
  below:
  \begin{verbatimtab}
    v[2,s1] := flip[1, share2];
    v[3,s1] := flip[1, share1] xor flip[1, share2] xor s[1, s:mysecret] \end{verbatimtab}
\end{example}

\subsection{Semantics}

\begin{fpfig}[t]{Evaluation contexts and operational semantics of $\metaprot$.}{fig-metaprot-semantics}
$$
\begin{array}{rcl@{\hspace{3mm}}r}
E &::=& [\,] \mid \enot\ E \mid E\ \bop\ e \mid v\ \bop\ E \mid  \flip{E}{e} \mid \secret{E}{e} \mid \view{E}{e} \mid \oracle{E} \mid  \\[1mm]
& & \flip{\cid}{E} \mid \secret{\cid}{E} \mid \view{\cid}{E} \mid \send{E}{e} \mid \send{\view{\cid}{w}}{E} \mid \OT{E}{e}{e} \\[1mm]
& & \mid \OT{v}{E}{e} \mid \OT{v}{v}{E} \mid \select{E}{e}{e} \mid \select{v}{E}{e} \mid \\[1mm]
& & \select{v}{v}{E} \mid \elet{x}{E}{e} \mid f(v,\ldots,v,E,e,\ldots,e) \mid \\[1mm]
& & \{ \flab = v;\ldots;\flab = v;\flab = E;\flab = e;\ldots;\flab = e \} \mid E.\flab \mid E\concat e \mid v \concat E
\end{array}
$$
\medskip
$$
\begin{array}{rcl@{\hspace{10mm}}r}
\config{\prog}{\elet{x}{v}{e}} &\redx& \config{\prog}{e[v/x]}\\
\config{\prog}{f(v_1,...,v_n)} &\redx&
\config{\prog}{e[v_1/x_1,\ldots,v_n/x_n]} & 
 \codebase(f) = x_1,\ldots,x_n,\ e\\
\config{\prog}{\{\ldots; \flab = v; \ldots\}.\flab} &\redx&
 \config{\prog}{v}\\
 \config{\prog}{w_1\concat w_2} &\redx& \config{\prog}{w_1w_2}\\
 \config{\prog}{v;e} &\redx& \config{\prog}{e}\\
\config{\prog}{\instr} &\redx& \config{\prog;\instr}{()}\\
\config{\prog}{E[e]} &\redx& \config{\prog'}{E[e']} & \text{if}\ \config{\prog}{e} \redx \config{\prog'}{e'} 
\end{array}
$$
\end{fpfig}

We define a small-step evaluation aka reduction relation $\redx$ in
Figure \ref{fig-metaprot-semantics}.  We write $\redxs$ to denote the
reflexive, transitive closure of $\redx$. Reduction is defined on
\emph{configurations} which are pairs of the form $\config{\prog}{e}$,
where $\prog$ is the $\minifed$ program accumulated during evaluation.
In this definition we write $e[v/x]$ to denote the substitution of $v$
for free occurences of $x$ in $e$. The rules are mostly standard,
except why a concrete $\minifed$ assignment is encountered it is added
to the end of $\prog$.

The rules rely on a definition of \emph{evaluation contexts} $E$
allowing computation within a larger program context, where $E[e]$
denotes an expression with $e$ in the hole $[]$ of $E$. Evaluation
contexts include boolean expression forms, allowing generalization
and instantiation of compositional program elements.
\begin{example}
  \label{example-share3-eval}
  Let $\codebase,e_{\ref{example-share3}}$ be the $\metaprot$ program and let 
  $\prog_{\ref{example-share3}}$ be the  $\minifed$ program defined
  in Example \ref{example-share3}. We refer to the latter as ``accumulated''
  by evaluation of the former in the sense that $\config{\varnothing}{e_{\ref{example-share3}}}
  \redxs \config{\prog_{\ref{example-share3}}}{\ttt{()}}$.
\end{example}

\subsection{Type Theory and Static Type Safety}

It is desirable to statically enforce safety of both $\metaprot$
programs and the safety of the $\fedprot$ programs they
generate. Although safety of the latter could be enforced
post-generation by a direct analysis, for large programs this can be
much more expensive and it is also better to not wast time on
resource-intensive compilation of programs with known errors
\cite{kreuter2012billion}. Some consequences of safety errors, for example accidental
reuse of one-time pads, can also undermine security.

The type syntax of $\metaprot$ is defined in Figure
\ref{fig-metaprot-tsyntax}. It includes a weak form of dependency:
string types $\stringty{e}$ and client types $\cidty{e}$
are parameterized by expressions $e$ that precisely reflect the
type of the value. Boolean expression forms have the type
$\bet{e}$ indexed by expressions $e$ indicating the client
id type of the expression. The dependency is weak in the
sense that expressions in types are a strict subset of
expression forms- for any $\stringty{e}$ the expression $e$
is either a variable, a string, or a concatenation form,
and for any $\cidty{e}$ or $\bet{e}$ the expression $e$
is either a variable or a client id $\cid$. 

Type judgements for expressions are of the form
$\tjudge{\viewst_1}{\gamma}{e}{\viewst_2}$ where the \emph{view
effect} $\viewst_1$ denotes the views that have been defined so far,
and $\viewst_2$ records new views defined as the effect of the
expression on the residual $\minifed$ program.  Type judgements are
syntax-directed- selected rules are shown in Figure
\ref{fig-metaprot-tjudge}. The $\TirName{AssignT}$ rule
captures the effect of new view definitions. The
$\TirName{And}$ rule illustrates how program safety is enforced,
by ensuring that subexpressions of boolean expressions have the
same owner.

The $\TirName{FnT}$ and $\TirName{Appt}$ rules apply to function
definition and application respectively, and rely on the
definition of function input type annotations $\tas$ and
type term substitutions $\sigma$. 
\begin{definition}
  A \emph{function input type annotation} $\tas$ is a mapping from
  function names $f$ to type products $\tau_1 * \cdots * \tau_n$.
  A \emph{type term substitution} $\sigma$ is a mapping from
  $\minifed$ variables $x$ to values, where $\sigma(\tau)$ denotes
  the replacement of occurences of $x$ in $\tau$ with $\sigma(x)$. 
\end{definition}
We assume that input type annotations $\tas$ are provided by the
programmer for all function definitions. This guarantees that
$\metaprot$ type checking is straightforward and efficient.
Function types are of the form:
$$
\tau_1 * \cdots * \tau_n \rightarrow \tau,\viewst
$$
where $\viewst$ denotes the effect of the function on the residual
program.  The function type can be understood as a dependent $\Pi$
type, with every term variable bound. When applied, these variables
are instantiated with a type term substitution $\sigma$. In our
implementation, we adapt \emph{synthesis} as defined in Dependent ML \cite{10.1145/292540.292560}
to obtain this $\sigma$- essentially this is a match on the syntactic
structure of types and expressions. 
\begin{example}
  Given $\ttt{share3}$ as defined in Example \ref{example-share3} and
  annotation:
  $$\tas(\ttt{share3}) =  \ttt{cid(client)}\ *\ \ttt{string(sid)}$$
  the type of $\ttt{share3}$ is $\tas(\ttt{share3}) \rightarrow \tau,\varnothing$
  where $\tau$ is:
  $$
  \ttt{\{ s1 : bool[client]; s2 : bool[client]; s3 : bool[client] \}}
  $$
\end{example}

\begin{fpfig}[t]{Type Syntax of $\metaprot$.}{fig-metaprot-tsyntax}
$$
\begin{array}{rcl@{\hspace{2mm}}r}
\srct &::=& \cidty{e} \mid \stringty{e} \mid \bet{e} \mid  & \gdesc{types}\\ 
 &&  \{ \flab : \srct;\ldots;\flab : \srct \} \mid \tau * \cdots * \tau \rightarrow \tau,\viewst \\[1mm]
\viewst  &::=& \view{e}{e};\viewst \mid \varnothing   & \gdesc{view effects}\\[1mm]
\Gamma &::=& \Gamma; x : \tau \mid \varnothing & \gdesc{type environments}    
\end{array}
$$
\end{fpfig}

\begin{fpfig}[t]{Selected $\metaprot$ type judgement rules.}{fig-metaprot-tjudge}
\begin{mathpar}
\inferrule[\TirName{VarT}]
{}
{\tjudge{\viewst}{\Gamma}{x}{\Gamma(x)}{\viewst}}

\inferrule[\TirName{CidT}]
{}
{\tjudge{\viewst}{\Gamma}{\cid}{\cidty{\cid}}{\viewst}}

\inferrule[\TirName{StringT}]
{}
{\tjudge{\viewst}{\Gamma}{w}{\stringty{w}}{\viewst}}

\inferrule[\TirName{ConcatT}]
{\tjudge{\viewst}{\Gamma}{e_1}{\stringty{e_1'}}{\viewst_1}\\
\tjudge{\viewst_1}{\Gamma}{e_2}{\stringty{e_2'}}{\viewst_2}
}
{\tjudge{\viewst}{\Gamma}{e_1||e_2}{\stringty{e_1' ||e_2'}}{\viewst_2}}

\inferrule[\TirName{BoolT}]
{}
{\tjudge{\viewst}{\Gamma}{\etrue}{\bet{\cid}}{\viewst}}

\inferrule[\TirName{OracleT}]
{\tjudge{\viewst}{\Gamma}{e}{\stringty{e'}}{\viewst'}}
{\tjudge{\viewst}{\Gamma}{\oracle{e}}{\bet{\cid}}{\viewst'}}

\inferrule[\TirName{SecretT}]
{\tjudge{\viewst}{\Gamma}{e_1}{\cidty{e_1'}}{\viewst_1}\\
\tjudge{\viewst_1}{\Gamma}{e_2}{\stringty{e_2'}}{\viewst_2}}
{\tjudge{\viewst}{\Gamma}{\secret{e_1}{e_2}}{\bet{e_1'}}{\views_2}}

\inferrule[\TirName{AndT}]
{
\tjudge{\viewst}{\Gamma}{e_1}{\bet{e}}{\viewst_1}\\
\tjudge{\viewst_1}{\Gamma}{e_2}{\bet{e}}{\viewst_2}
}
{\tjudge{\viewst}{\Gamma}{e_1\ \eand\ e_2}{\bet{e}}{\viewst_2}}

\inferrule[\TirName{AssignT}]
{
\tjudge{\viewst}{\Gamma}{e_1}{\cidty{e_1'}}{\viewst_1}\\
\tjudge{\viewst_1}{\Gamma}{e_2}{\stringty{e_2'}}{\viewst_2}\\
\tjudge{\viewst_2}{\Gamma}{e_3}{\bet{e_3'}}{\viewst_3}
}
{
\tjudge{\viewst}{\Gamma}{\eassign{\view{e_1}{e_2}}{e_3}}{\unity}{(\viewst_3 ; \view{e_1'}{e_2'} )}
}

\inferrule[AppT]
{\Gamma(f) =  
 \tau_1 * \cdots * \tau_n \rightarrow \tau, \viewst_f \\ 
 \tjudge{\viewst}{\Gamma}{e_1}{\sigma(\tau_1)}{\viewst_1}
 \ \cdots\  
 \tjudge{\viewst_{n-1}}{\Gamma}{e_n}{\sigma(\tau_n)}{\viewst_n}}
{\tjudge{\viewst}{\Gamma}{f(e_1,\ldots,e_n)}{\sigma(\tau)}{(\viewst_n ; \sigma(\viewst_f))}}

\inferrule[FnT]
{
  \codebase(f) = x_1,\ldots,x_n,\ e \\ \tas(f) = \tau_1 * \cdots * \tau_n \\
  \tjudge{\varnothing}{\Gamma; x_1 : \tau_1; \ldots; x_n : \tau_n}{e}{\tau}{\viewst_f}
}
{ \Gamma \vdash f : \tau_1 * \cdots * \tau_n \rightarrow \tau, \viewst_f }

\inferrule[ProgT]
{
\forall f \in \dom(\codebase)\ .\ \Gamma \vdash f : \Gamma(f) \\ \Gamma \vdash e : \tau, \view{\cid_1}{w_1};\ldots;\view{\cid_1}{w_1}
}
{
\Gamma \vdash \codebase,e : \tau,\{\view{\cid_1}{w_1}\} \sqcup \cdots \sqcup \{ \view{\cid_n}{w_n}\}
}
\end{mathpar}
\end{fpfig}

Top-level type judgements are of the form $\Gamma \vdash \codebase, e
: \tau, V$, where all the functions in $\codebase$ are well-typed in
$\Gamma$, the top level view effect $V$ is a set of concrete
$\fedprot$ views which are constructed by disjoint union of the views
in the effect of $e$- the disjointness requirement guarantees that
views are uniquely defined. Our $\metaprot$ type safety result is
formulated as follows. In addition to safe execution of the
metaprogram, it also guarantees safety of the residual $\fedprot$
program. Of course, it is important to note that ``safety'' here
means the usual type safety property that programs do not get stuck,
it does not imply any security hyperproperties. 
\begin{theorem}[$\metaprot$ Type Safety]
  \label{theorem-metalang-safety}
  Given $\codebase$, $e$, and $\Gamma$ with $\Gamma \vdash \codebase,e : \unity : V$,
  then $\config{\varnothing}{e} \redxs \config{\prog}{\ttt{()}}$ where
  $\prog$ is safe with $\iov(\prog) = S \cup V$ for some $S$.
\end{theorem}
