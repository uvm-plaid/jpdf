\section{A Protocol Metalanguage}
\label{section-metalang}

\begin{fpfig}[t]{Syntax of $\metaprot$.}{fig-metaprot-syntax}
$$
\begin{array}{rcl@{\hspace{8mm}}r}
\flab &\in& \mathrm{Field}\\
x &\in& \mathrm{EVar}\\
f &\in& \mathrm{FName}\\[2mm]
e &::=& b \mid \flip{e}{e} \mid \secret{e}{e} \mid \view{e}{e} \mid \oracle{e} \mid \enot\ e \mid e\ \eand\ e \mid e\ \exor\ e \mid & \textit{expressions}\\[0mm]
& & \select{e}{e}{e} \mid 
\send{\view{e}{e}}{e} \mid \send{\view{e}{e}}{\OT{e}{e}{e}} \mid e;e \mid \\[0mm]
& & x \mid \elet{x}{e}{e} \mid f(e,\ldots,e) \mid \{ \flab = e; \ldots; \flab = e \}
\mid e.\flab \mid e\concat e \mid (e) \\[2mm]
v &::=& w \mid \cid \mid \be \mid \{ \flab = v;\ldots;\flab = v \} 
\mid (\,) & \textit{values}\\[2mm]
{fn} &::=& f(x,\ldots,x) \{ e \} & \textit{functions}
\end{array}
$$
\end{fpfig}

Large practical MPC computations are based on much larger protocols
than the examples we've considered so far. These larger protocols are
typically based on compositional units. An example of this is Yao's
Garbled Circuits (YGC), which are composed of so-called garbled gates.
Languages for defined garbled circuits, beginning with Fairplay \cite{XXX},
treat gates as compositional units that are wired together by the programmer
to generate a complete circuit. The $\fedprot$ language is low-level
and does not include abstractions for defining composable elements. 

In this Section we introduce the $\metaprot$ language which includes
structured data and function definitions, which are sufficiently
expressive to define composable protocol elements such as garbled
gates. The $\metaprot$ language is a \emph{metalanguage}- it produces
$\fedprot$ protocols as a result of computation. That is, $\metaprot$ is
a high-level language that generates low-level protocol code. 

\subsection{Syntax}

The syntax of $\metaprot$ is defined in Figure
\ref{fig-metaprot-syntax}.  It includes a syntax of function
definitions and records, and values include client ids, identifier
strings, and boolean expressions.  Expression forms allow dynamic
construction of boolean expression forms and view assignments. When
$\metaprot$ programs construct a $\fedprot$ assignment, a side effect
occurs whereby the assignment is added to the end of the $\fedprot$
program accumulated during evaluation.

Formally, we consider a complete metaprogram to include both a
codebase and a ``main'' program that uses the codebase. 
\begin{definition}
A \emph{codebase} $\codebase$ is a list of function 
declarations. We write $ \codebase(f) = x_1,\ldots,x_n,\ e$
iff $f(x_1,\ldots,x_n) \{ e \} \in \codebase$.
A \emph{metaprogram}, aka \emph{mataprotocol} is a pair of a 
codebase and expression $\codebase, e$. We may omit
$\codebase$ if it is clear from context.  
\end{definition}

When we consider the example of YGC in detail below, our focus will be
on developing a codebase that can be used to define arbitrary
circuits, i.e., complete and concrete protocols. Since strings and
identifiers can be constructed manually, and expressions can occur
inside assignments and boolean expression forms, function definitions
can generalize over $\fedprot$-level patterns to obtain composable
program units. As a simple example, consider 3 party secret
sharing as illustrated in Example \ref{example-he}. We can
define a function $\ttt{share3}$ that abstracts the process
of splitting a given client's secret into 3 separate shares.
\begin{example} \label{example-share3} The function $\ttt{share3}$ 
  splits a client's secret into 3 shares returned as a record
  with fields $\ttt{s1-3}$:
  \begin{verbatimtab}
    share3(client, secretid)
    {
      let s1 = flip[client, share1] in
      let s2 = flip[client, share2] in
      let s3 = (s1 xor s2) xor s[client, s: || secretid] in
      {s1 = s1;s2 = s2;s3 = s3}
    } \end{verbatimtab}
  Here is $\metaprot$ program that uses this this function definition:
  \begin{verbatimtab}
    let shares = share3(1, mysecret) in
    v[2,s1] := shares.s2;
    v[3,s1] := shares.s3 \end{verbatimtab}
  which generates the following $\minifed$ program:
  \begin{verbatimtab}
    v[2,s1] := flip[1, share2];
    v[3,s1] := flip[1, share1] xor flip[1, share2] xor s[client, s:mysecret] \end{verbatimtab}
\end{example}


\subsection{Semantics}

\begin{fpfig}[t]{Evaluation contexts and operational semantics of $\metaprot$.}{fig-metaprot-semantics}
$$
\begin{array}{rcl@{\hspace{3mm}}r}
E &::=& [\,] \mid \enot\ E \mid E\ \bop\ e \mid v\ \bop\ E \mid  \flip{E}{e} \mid \secret{E}{e} \mid \view{E}{e} \mid \oracle{E} \mid  \\[1mm]
& & \flip{\cid}{E} \mid \secret{\cid}{E} \mid \view{\cid}{E} \mid \send{E}{e} \mid \send{\view{\cid}{w}}{E} \mid \OT{E}{e}{e} \\[1mm]
& & \mid \OT{v}{E}{e} \mid \OT{v}{v}{E} \mid \select{E}{e}{e} \mid \select{v}{E}{e} \mid \\[1mm]
& & \select{v}{v}{E} \mid \elet{x}{E}{e} \mid f(v,\ldots,v,E,e,\ldots,e) \mid \\[1mm]
& & \{ \flab = v;\ldots;\flab = v;\flab = E;\flab = e;\ldots;\flab = e \} \mid E.\flab \mid E\concat e \mid v \concat E
\end{array}
$$
\medskip
$$
\begin{array}{rcl@{\hspace{10mm}}r}
\config{\prog}{\elet{x}{v}{e}} &\redx& \config{\prog}{e[v/x]}\\
\config{\prog}{f(v_1,...,v_n)} &\redx&
\config{\prog}{e[v_1/x_1,\ldots,v_n/x_n]} & 
 \codebase(f) = x_1,\ldots,x_n,\ e\\
\config{\prog}{\{\ldots; \flab = v; \ldots\}.\flab} &\redx&
 \config{\prog}{v}\\
 \config{\prog}{w_1\concat w_2} &\redx& \config{\prog}{w_1w_2}\\
 \config{\prog}{v;e} &\redx& \config{\prog}{e}\\
\config{\prog}{\instr} &\redx& \config{\prog;\instr}{()}\\
\config{\prog}{E[e]} &\redx& \config{\prog'}{E[e']} & \text{if}\ \config{\prog}{e} \redx \config{\prog'}{e'} 
\end{array}
$$
\end{fpfig}

\subsection{An Implementation of Yao's Garbled Circuits}
\label{section-metalang-ygc}

\input{ygc}




