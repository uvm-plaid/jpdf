\section{Introduction}

Secure Multi-Party Computation (MPC) protocols support data privacy in
important modern, distributed applications such as privacy-preserving
machine learning and Zero-Knowledge proofs in blockchains \cite{XXX}
\cnote{Need some banger cites here, maybe more MPC hype.}. MPC methods
have been developed by the cryptography community for many years,
while receiving the attention of the programming languages community
only relatively recently. In contrast, information flow security has
received significant attention in PL theory and practice especially
since the turn of the century \cite{1159651}, including a menagerie of
variants, enforcement mechanisms, and programming frameworks. Much of
this has been enabled by the unified metatheory of
\emph{hyperproperties} \cite{10.5555/1891823.1891830} that establishes
a common conceptual framework for reasoning about and implementing
systems with information flow security.

Our goal is to explore and establish connections between the security
model of MPC-- the \emph{real/ideal} aka \emph{simulator security}
model -- and trace-based hyperproperties, and to leverage these
connections to obtain automated enforcement mechanisms for MPC
protocol development. Currently, proof methods for MPC protocol
development are well-studied \cite{Lindell2017} but manual and 
thus tedious and error-prone, and are also non-standardized and
unfamiliar to most PL theorists. Therefore our exploration will
make both theoretical and practical contributions by bridging a gap between
information flow and simulator security methodologies.

\subsection{The Analysis Challenge of MPC} MPC protocols involve communication
between a group of distributed participants called a \emph{federation}
that collaboratively compute and publish the result of some known
\emph{ideal functionality} $\idealf$, while keeping each party's input
``secret'', without the use of a trusted third party. This last part
is critical. For example, if we take $\idealf$ to be the majority vote
function, a protocol for computing $\idealf$ is MPC-secure if, given
any set of input votes, it correctly computes and publishes the voting
result but reveals no other information to the public or to other
participants. However, by publishing the result, some information
about individual votes may be implicitly declassified.  For example,
in the case of a majority vote in a federation of size 3, if the
motion carries and party 1 has voted no, then party 1 knows exactly
the votes of parties 2 and 3. This cannot be avoided due to the nature
of $\idealf$.

Security in the MPC setting thus means that protocols cannot reveal
any secret information other than what is impicitly declassified by
the publicized output of the ideal functionality. The security model
also assumes that some subset of participants can be corrupted and
collude adversarially to possibly infer more secret information. The
accepted method of demonstrating protocol security in this setting is
to define a \emph{simulation} algorithm that runs in the ``ideal''
world which, given just the inputs of corrupted parties and the output
of the ideal functionality, is able to reconstruct information that
corrupted parties receive in their so-called \emph{views} of the
protocol running in the real world.  This implies that adversarial
views provide no information beyond what is provided by the ideal
output alone. Simulation is defined probabilistically since MPC
protocols typically rely on cryptographic and probabilistic methods.

In Section \ref{section-hyperprop-passive} we formalize real/ideal
security, and we define and discuss simple examples of MPC protocols
in Section \ref{section-minicat-examples} and more complex ones in
Section \ref{section-composition}. But an immediate and main point in
relation to security hyperproperties is that, due to the potential for
information release in MPC, simulator security is \emph{not} a strict
probabilistic noninterference or trace obliviousness property, as we
show in Section \ref{section-hyperprop-ni}- rather, the public output
allows and sets an upper bound on declassification.

\subsection{Related Work}

We distinguish between \emph{extensional} vs.~\emph{intensional}
properties and analysis of MPC protocols. By extensional, we mean
simulator security itself as well as analysis concerned with the use
and interaction of complete secure protocols. By intensional, we mean
analysis and inner workings of protocols themselves. While the
probabilistic formulations we develop could conceivably used
extensionally, our main focus is on intensional properties of
protocols, both through whole-program analysis and compositional
properties of program components that support security.

Previous work on analysis for the SecreC language
\cite{almeida2018enforcing,10.1145/2637113.2637119} is concerned with
extensional properties of MPC, in particular the specification and
enforcement of declassification bounds in programs that use MPC in
subprograms. This work is explicitly reminiscent of information flow
approaches such as delimited information release
\cite{10.1007/978-3-540-37621-7_9} and downgrading policies and
relaxed noninterference \cite{10.1145/1040305.1040319}. However, their
program logic assumes correctness of the underlying MPC protocols.
The Wys$^\star$ language \cite{wysstar}, based on Wysteria
\cite{rastogi2014wysteria}, has similar goals and includes a
trace-based semantics for reasoning about the extensional interactions
of MPC protocols. Their compiler also enforces some intensional
properties, in particular that underlying multi-threaded protocols
enforce the single-threaded source language semantics.



\subsection{Contributions}

In this paper, we make the following contributions.
\begin{itemize}
\item A new probabilistic programming language $\minifed$ for defining
  synchronous distributed protocols over the binary field. We consider example
  protocols including oblivious transfer, communications encryption with one-time
  pads, and additive secret sharing (Section \ref{section-minicat}).
  \cnote{I'm hoping $\minifed$ hasn't been used already.}
\item A formulation of $\minifed$ program distributions, including
  distributions of secrets and views, supporting expression of security
  properties (Section \ref{section-pmf}). This intensional characterization
  is useful for expressing internal characteristics of protocols, and
  is needed for MPC due to the fact that obliviousness alone is not sufficient
  to capture characteristics of the real/ideal model, in particular, the
  allowance of some information leakage through public outputs. 
\item A novel hyperproperty of program execution traces, called
  \emph{noninterference modulo output ($\NIMO$)}, based on our
  formulation of program distributions, that implies passive security
  (Section \ref{section-hyperprop}).
\item A brute force mechanism for verifying passive security in
  $\minifed$ protocols, that is also amenable to HPC optimizations via
  translation of $\minifed$ protocols into Datalog (Section \ref{section-bruteforce}). 
\item A new metaprogramming language $\metaprot$ that dynamically
  generates $\minifed$ protocols. It includes control and data structures
  and is able to express logical protocol components, and enjoys a
  type safety result that guarantees that generated protocols
  are semantically well-defined (Section \ref{section-metalang}).
\item A formulation of Yao's Garbled Circuits, and a formulation of a
  compositional property of an extensible library of garbled gate
  components that is verifiable automatically. This property
  guarantees that any well-formed circuits using the library are
  passive secure (Section \ref{section-composition}).
\end{itemize}

