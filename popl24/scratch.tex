\subsection{Compositional Properties of GMW}

\input{gmw}
\cnote{Need to define type signatures.}

Our certification techniques are defined generally wrt implementations
of input encoding, decoding, and internal gates. In the following we
will refer to arbitrary decode, encode, and gate functions with the
restriction that any function in each of these categories has the same
valid type signature as $\ttt{decodegmw}$, $\ttt{encodegmw}$, and
$\ttt{andgmw}$ respectively.
\begin{definition}
  We write $\progtt(\prog)$ to denote the \emph{basic distribution} of
  $\prog$ as defined in Definition \ref{def-progd}. For any program $\prog =
  (\eassign{v_1}{\be_1};\ldots;\eassign{v_n}{\be_n})$, define
  $\vdefs(\prog) \defeq \{ v_1,\ldots,v_n \}$.
\end{definition}
We also need to formalize notions of probabilistic independence, aka
\emph{separation}, and correlation. We borrow the symbols $*$ and $\sim$
from \cite{barthe2019probabilistic} with the same denotations.
\begin{definition}
  We write $\vc{\pmf}{x}{y}$ iff $\pmf(\{ x \mapsto 0\}\ |\ \{ y \mapsto 0 \}) =
  \pmf(\{ x \mapsto 1\}\ |\ \{ y \mapsto 1 \}) = 1$.
  We write $\sep{\pmf}{Y}{Z}$ iff for all
    $\store \in \mems(X \cup Y)$:
  $$(\margd{\pmf}{Y \cup Z})(\store) =
  \pmf(\store_Y) * \pmf(\store_Z)$$ 
\end{definition}

\begin{lemma}
  \label{lemma-separation}
  The following properties hold:
  \begin{enumerate}
  \item $\sep{\pmf}{Y}{Z}$ iff $\sep{\pmf}{Z}{Y}$
  \item $\vc{\pmf}{x}{y}$ if  $\vc{\pmf}{y}{x}$
  \item $\vc{\pmf}{x}{y}$ and $\vc{\pmf}{y}{z}$ imply $\vc{\pmf}{x}{z}$
  \item ($\sep{\pmf}{X}{Y}$ and $\sep{\pmf}{X}{Z}$) iff $\sep{\pmf}{X}{(Y \cup Z)}$
  \item If $\prog_1;\prog_2$ is safe and $\vars(\prog_1) \cap \vars(\prog_2) = \varnothing$
    then $\sep{\progtt(\prog_1;\prog_2)}{\vars(\prog_1)}{\vars(\prog_2)}$.
  \end{enumerate}
\end{lemma}

\begin{definition}[GMW Gate Certification]
  \label{definition-gmwgate-certification}
  Let $\mathit{gate}$ be a gate function and let $e$ be the following
  $\metaprot$ program:
  $$
  \begin{array}{l}
    \ttt{let in1 = \{c1 = flip[1,s11];c2 = flip[2,s12]\} in}\\
    \ttt{let in2 = \{c1 = flip[1,s21];c2 = flip[2,s22]\} in}\\
    \mathit{gate}\ttt{(g,in1,in2)}
  \end{array}
  $$
  and let $
  \config{\varnothing}{e}\redxs\config{\prog}{\ttt{\{c1 = v[1,gout]; c2 = v[2,gout]\}}}
  $.
  Then $\mathit{gate}$ is \emph{certified} iff the following conditions hold:
  \begin{enumerate}[\hspace{5mm}i.]
  \item $\sep{\progtt(\prog)}{\ttt{\{flip[1,s11],flip[1,s21]\}}}{\ttt{\{v[2,gout]\}}}$
  \item $\sep{\progtt(\prog)}{\ttt{\{flip[2,s12],flip[2,s22]\}}}{\ttt{\{v[1,gout]\}}}$
  \item All variables in:$$\vars(\prog) - \{ \ttt{flip[1,s11],flip[1,s21],flip[2,s12],flip[2,s22]}\}$$
    are distinguished by $\ttt{g}$ (i.e., contain $\ttt{g}$ as an identifier substring). 
  \end{enumerate}
\end{definition}

\begin{lemma}
  \label{lemma-sepjoin}
  $\sep{\progtt(\prog)}{X}{Y}$ iff for all 
  $\store^1, \store^2 \in \runs(\prog)$ there exists
  $\store \in \runs(\prog)$ with
  $\store^1_{X} \cap \store^2_{Y} \subseteq \store$.
\end{lemma}

\begin{lemma}
  \label{lemma-presub}
  Given $\be_1$, $\be_2$, and $i$ where $\vars(\be_1) \cap
  \vars(\be_2) = \varnothing$ and $\lcod{\store_1,\be_1}{i} = \beta$
  with $\store_1(x) = \lcod{\store_2,\be_2}{i}$ and
  $\dom(\store_1) = \vars(\be_1)$ and $\dom(\store_2) = \vars(\be_2)$.
  Then $\lcod{\store_1\cap\store_2,\be_1[\be_2/x]}{i} = \beta$.
\end{lemma}
\begin{proof}
By straightforward structural induction on $\be$.
\end{proof}

\begin{lemma}[Substitution]
  \label{lemma-substitution}
  If $\sep{\progtt(\prog_2)}{\{ f \}}{\vdefs(\prog_2)}$ and
  $\prog_1;\prog_2[\be/f]$ is safe with $\vars(\prog_1,\be) \cap
  \vars(\prog_2) = \varnothing$ then
  $\sep{\progtt(\prog_1;\prog_2[\be/f])}{\vdefs(\prog_1)}{\vdefs(\prog_2[\be/f])}$.
\end{lemma}
\begin{proof}
  Suppose on the contrary it was not the case that
  $\sep{\progtt(\prog_1;\prog_2[\be/f])}{\vdefs(\prog_1)}{\vdefs(\prog_2[\be/f])}$.
  Then by Lemma \ref{lemma-sepjoin} there exists $\store_1,\store_2
  \in \runs(\prog_1;\prog_2[\be/f])$ with no $\store \in
  \runs(\prog_1;\prog_2[\be/f])$ such that $\store^1_{\vdefs(\prog_1)}
  \cap \store^2_{\vdefs(\prog_2)} \subseteq \store$.  But also by
  assumption and Lemma \ref{lemma-sepjoin} for any $\beta$ there
  exists $\store' \in \runs(\prog_2)$ with $\{ f \mapsto \beta \} \cap
  \store^2_{\vdefs(\prog_2)} \subseteq \store'$. So in particular, we
  have $\{ f \mapsto \lcod{\store^1_{\vdefs(\prog_1)},\be}{i} \} \cap
  \store^2_{\vdefs(\prog_2)} \subseteq \store'$ for any $i$. This, the
  assumption $\vars(\prog_1,\be) \cap \vars(\prog_2) = \varnothing$,
  and application of Lemma \ref{lemma-presub} leads to the consequence
  that there exists $\store \in \runs(\prog_1;\prog_2[\be/f])$ with
  $\store \supseteq \store^1_{\vdefs(\prog_1)} \cap
  \store^2_{\vdefs(\prog_2)}$ given the assumption $\vars(\prog_1,\be)
  \cap \vars(\prog_2) = \varnothing$, which is a contradiction.
\end{proof}

\begin{lemma}[GMW Gate Composition]
  \label{lemma-composition-gmw}
  Given well-typed $\prog_1;E[\mathit{gate}(\ttt{g},v_1,v_2)]$ and certified $\mathit{gate}$ where:
  $$
  \begin{array}{lcr}
   v_1 &=& \ttt{\{c1 = v[1,g1out]; c2 = v[2,g1out]\}}\\
   v_2 &=& \ttt{\{c1 = v[1,g2out]; c2 = v[2,g2out]\}}
  \end{array}
  $$
  for some $\ttt{g1}$ and $\ttt{g2}$ and:
  $$
  \config{\prog_1}{E[\mathit{gate}(\ttt{g},v_1,v_2)]} \redxs \config{\prog_1;\prog_2}{E[\ttt{\{c1 = v[1,gout]; c2 = v[2,gout]\}}]}
  $$
  Then the following postconditions hold:
  \begin{enumerate}
  \item $\sep{\progtt(\prog_1;\prog_2)}{\ttt{\{v[1,g1out],v[1,g2out]\}}}{\ttt{\{v[2,gout]\}}}$
  \item $\sep{\progtt(\prog_1;\prog_2)}{\ttt{\{v[2,g1out],v[2,g2out]\}}}{\ttt{\{v[1,gout]\}}}$
  \end{enumerate}
\end{lemma}

\begin{proof}
  Let $\prog$ be as defined in Definition \ref{definition-gmwgate-certification}.
  We observe:
  $$
  {\footnotesize
    \begin{array}{c}
      \prog_2 = \\
      \prog[\ttt{v[1,g1out]}/\ttt{flip[1,s11]}][\ttt{v[2,g1out]}/\ttt{flip[2,s12]}][\ttt{v[1,g2out]}/\ttt{flip[1,s21]}][\ttt{v[2,g2out]}/\ttt{flip[2,s22]}]
    \end{array}
  }
  $$
  The assumption of well-typedness of $\prog_1;E[\mathit{gate}(\ttt{g},v_1,v_2)]$ assures
  that $\ttt{g}$ has not been previously used as a gate identifier, since otherwise the
  views $\ttt{v[1,gout]}$ and $\ttt{v[1,gout]}$ would have been previously defined. This
  ensures $\vars(\prog_1,x) \cap
  \vars(\prog_2) = \varnothing$ for:
  $$x \in \{ \ttt{v[1,g1out]}, \ttt{v[2,g1out]}, \ttt{v[1,g2out]}, \ttt{v[2,g2out]}\}$$
  given condition (iii) in Definition \ref{definition-gmwgate-certification}.
  The result follows by Lemma \ref{lemma-substitution}. 
\end{proof}

\begin{lemma}[GMW Gate Invariance]
  \label{lemma-preservation-gmw}
  Given well-typed $\prog_1;E[\mathit{gate}(\ttt{g},v_1,v_2)]$ and certified $\mathit{gate}$ where
  for some $\ttt{g1}$ and $\ttt{g2}$, :
  $$
  \begin{array}{lcr}
   v_1 &=& \ttt{\{c1 = v[1,g1out]; c2 = v[2,g1out]\}}\\
   v_2 &=& \ttt{\{c1 = v[1,g2out]; c2 = v[2,g2out]\}}
  \end{array}
  $$
  and where $\iov(\prog_1) = S \cup V$ we have:
  $$
  \sep{\progd(\prog_1)}{S_{\{2\}}}{V_{\{1\}}}
  \quad \text{and} \quad \sep{\progd(\prog_1)}{S_{\{1\}}}{V_{\{2\}}}
  $$
  and:
  $$
  \config{\prog_1}{E[\mathit{gate}(\ttt{g},v_1,v_2)]} \redxs \config{\prog_1;\prog_2}{E[\ttt{\{c1 = v[1,gout]; c2 = v[2,gout]\}}]}
  $$
  then we have as a postcondition:
  %\begin{enumerate}
  $$\sep{\progd(\prog_1;\prog_2)}{S_{\{2\}}}{(V_{\{1\}} \cup \ttt{\{v[1,gout]\}})}
  \quad \text{and}\quad \sep{\progd(\prog_1;\prog_2)}{S_{\{1\}}}{(V_{\{2\}} \cup \ttt{\{v[2,gout]\}})}$$
  %\end{enumerate}
\end{lemma}

\begin{proof}
By Lemma \ref{lemma-composition-gmw} we have:
$$\sep{\progtt(\prog_1;\prog_2)}{\ttt{\{v[1,g1out],v[1,g2out]\}}}{\ttt{\{v[2,gout]\}}}$$
and
$$\sep{\progtt(\prog_1;\prog_2)}{\ttt{\{v[2,g1out],v[2,g2out]\}}}{\ttt{\{v[1,gout]\}}}$$
\end{proof}

\begin{definition}[GMW Encode Certification]
  Let $\mathit{encode}$ be an encoding function, and let:
  $$
  \config{\varnothing}{\ttt{encode(s1,s2)}} \redxs
  \config{\prog}{\ttt{\{shares1 = }v_1\ttt{; shares2 = }v_2\ttt{\}}}
  $$
  where:
  $$
  \begin{array}{rcl}
    v_1 &=& \ttt{\{ c1 = v[1,s1out]; c2 = v[2,s1out] \}}\\
    v_2 &=& \ttt{\{ c1 = v[1,s2out]; c2 = v[2,s2out] \}}
  \end{array}
  $$
  Then $\mathit{encode}$ is \emph{certified} iff each of the following conditions hold:
  \begin{enumerate}[\hspace{5mm}i.]
  \item $\sep{\progtt(\prog)}{\ttt{\{ s[1,s1] \}}}{\ttt{\{ v[2,s1out], v[2,s2out] \}}}$
  \item $\sep{\progtt(\prog)}{\ttt{\{ s[2,s2] \}}}{\ttt{\{ v[1,s1out], v[1,s2out] \}}}$
  \item All $x \in \vars(\prog)$ are distinguished by $\ttt{in1}$ or $\ttt{in2}$. 
  \end{enumerate}
\end{definition}

\begin{theorem}
  \label{theorem-gmw-NIMO}
  If $e$ is a well-typed GMW circuit definition using certified
  components and $\config{\varnothing}{e} \redxs
  \config{\prog}{\varnothing}$, then $\NIMO(\prog)$.
\end{theorem}
\begin{proof}
  Let $\iov(\prog) = S \cup (V \cup \outv)$. Noting that any encoding
  necessarily uses entirely fresh variables by Definition and type
  safety, by applying Lemmas \ref{lemma-compose-gmw} and
  \ref{lemma-wire-framing} and the frame rule of
  \cite{barthe2019probabilistic} we obtain:
  $$
  \sep{\progd(\prog)}{(S_{\{2\}}\cup\{\outv\})}{V_{\{1\}}}
  \quad \text{and} \quad \sep{\progd(\prog)}{(S_{\{1\}}\cup\{\outv\})}{V_{\{2\}}}
  $$
  That is, the marginal distribution of client 1's secrets and the output are independent
  of client 2's views, and vice-versa. The result follows. 
\end{proof}
