\section{Automated Hoare Logic for $\metaprot$}

\subsection{Corrections to $\metaprot$ Generalized Constraint Forms and Evaluation}

The syntax of $\notg{\eqs}$ in the ESOP paper was too complicated. It should simply be:
$$
\begin{array}{rcl@{\hspace{4mm}}r}
\notg{\eqs} &::=& e \eop e \mid \notg{\eqs} \wedge \notg{\eqs} 
\end{array}
$$
The semantics of generalized constraint evaluation can also be greatly simplified, as
follows:
\begin{mathpar}
  \inferrule
      {e_1 \redx \be_1 \\ e_2 \redx \be_2}
      {e_1 \eop e_2 \redx \toeq{\be_1} \eop \toeq{\be_2}}

  \inferrule
      {\notg{\eqs_1} \redx \eqs_1 \\ \notg{\eqs_2} \redx \eqs_2 }
      {\notg{\eqs_1} \wedge \notg{\eqs_2} \redx \eqs_1 \wedge \eqs_2}
\end{mathpar}
Given these changes, we also have some corrections to the $\TirName{Assert}$ and $\TirName{Mesg}$
rules below in the Hoare Logic, which referred to a syntactic form ``$\toeq{e}$'' which now seems meaningless.

The upshot is that evaluation of generalized constraints, mainly in the $\TirName{GenEntails}$
rule, can be defined very directly in terms of evaluation of $\metaprot$ expressions.

\subsection{$\minicat$ Hoare Logic}

\begin{mathpar}
  \inferrule[Assign]
            {}
            {\htrip{\eqs[\toeq{\elab{\be}{\cid_2}}/x]}{\xassign{x}{\be}{\cid_2}}{\eqs}}
  
  \inferrule[Assert]
            {E \models \toeq{\elab{\be_1}{\cid}} \eop \toeq{\elab{\be_2}{\cid}}}
            {\htrip{E}{\elab{\assert{\be_1 = \be_2}}{\cid}}{E}}

  %\reveal{w}{\be}{\cid}
  %
  %\pubout{\cid}{\be}{\cid}
  \inferrule[Seq]
      {\htrip{\eqs_1}{\prog_1}{\eqs_2} \\ \htrip{\eqs_2}{\prog_2}{\eqs_3} }
      {\htrip{\eqs_1}{\prog_1;\prog_2}{\eqs_3}}

  \inferrule[Consequence]
      {\htrip{\eqs_1'}{\prog}{\eqs_2'} \\ \eqs_1 \models \eqs_1' \\  \eqs_2' \models \eqs_2 }
      {\htrip{\eqs_1}{\prog}{\eqs_2}}

  \inferrule[Frame]
      {\htrip{\eqs_1}{\prog}{\eqs_2} \\ \vars(\eqs) \cap \avars(\prog) = \varnothing}
      {\htrip{\eqs_1 \wedge \eqs}{\prog}{\eqs_2 \wedge \eqs}}
\end{mathpar}

\subsection{$\metaprot$ Abstract Hoare Logic}

Adding basic types to command function declarations to support generalize pre/post conditions. 

$$
\begin{array}{rcl@{\hspace{4mm}}r}
\tau &::=& \fieldp{p} \mid \mathit{string} \mid \mathit{cid} \mid \{ \flab_1 : \tau_1; \ldots; \flab_n : \tau_n \} & \gdesc{basic types}\\[2mm]
\mathit{fn} &::=& f(y,\ldots,y) \{ e \} \mid  f(y : \tau,\ldots,y : \tau) \{ \cmd \} & \textit{functions}
\end{array}
$$
\medskip

\noindent This is the generalized rule for entailment:

$$
\inferrule[GenEntails]
          {\mv_1,\ldots,\mv_n = \fresh(\tau_1,\ldots,\tau_n) \\ \peq_1[\mv_1/y_n \cdots \mv_n/y_n] \redx \eqs_1 \\
           \peq_2[\mv_1/y_n \cdots \mv_n/y_n] \redx \eqs_2 \\ \eqs_1 \models \eqs_2}
          {\forall y_1:\tau_1,\ldots,y_n:\tau_n . \peq_1 \models \peq_2 }
$$

The following are generalized Hoare triple computations. Hard and soft pack rules allow for compositional
verification. Hardpack eliminates program variables, while softpack may require less programmer overhead. 
\begin{mathpar}
  \inferrule[Mesg]
            {}
            {\htrip{\eqtrue}{\xassign{e_1}{e_2}{e_3}}{e_1 \eop \elab{e_2}{e_3}}}

  %\inferrule[Encode]
  %          {\mx{e_1}{e_2} \redx x \\ \notg{\phi} \redx \phi \\
  %            \eqs \models x \eop \phi\\
  %            \atj{\phi}{R}{\ty}}
  %          {\mtj{\eqcast{\mx{e_1}{e_2}}{\notg{\phi}}}{\eqs}{(x : \ty)}{R}{\varnothing}{\eqs}}
  %
  \inferrule[Assert]
            {}
            {\htrip{\elab{e_1}{e_3} \eop \elab{e_2}{e_3}}{\elab{\assert{e_1 = e_2}}{e_3}}{\eqtrue}}

  \inferrule[Seq]          
            {\htrip{\peq_1^1}{\cmd_1}{\peq_2^1} \\ \htrip{\peq_1^2}{\cmd_2}{\peq_2^2}}
            {\htrip{\peq_1^1 \wedge \peq_1^2}{\cmd_1;\cmd_2}{\peq_2^1 \wedge \peq_2^2}}

  \inferrule[Let]
            {\htrip{\peq_1}{\cmd[e/y]}{\peq_2}}
            {\htrip{\peq_1}{\elet{y}{e}{\cmd}}{\peq_2}}

  \inferrule[App]
            {\htrip{\peq_1}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq_2}}
            {\htrip{\peq_1[e_1/y_1 \cdots e_n/y_n]}{f(e_1,\ldots,e_n)}{\peq_2[e_1/y_1 \cdots e_n/y_n]}}

  \inferrule[Fn]
            {\codebase(f) = y_1 : \tau_1, \ldots, y_n : \tau_n, \cmd \\ \htrip{\peq_1}{\cmd}{\peq_2}}
            {\htrip{\peq_1}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq_2}}
            
  \inferrule[Hardpack]
            {\precond(f) = \peq_1 \\ \postcond(f) = \peq_2 \\
              \htrip{\peq_1'}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq_2'} \\
              \forall y_1:\tau_1,\ldots,y_n:\tau_n . \peq_1 \wedge \peq_2' \models \peq_1' \wedge \peq_2 }
            {\htrip{\peq_1}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq_2}}

  \inferrule[Softpack]
            {\precond(f) = \peq_1 \\ \postcond(f) = \peq_2 \\
              \htrip{\peq_1'}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq_2'} \\
              \forall y_1:\tau_1,\ldots,y_n:\tau_n . \peq_1 \wedge \peq_1' \wedge \peq_2' \models \peq_2 }
            {\htrip{\peq_1' \wedge \peq_1}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq_2' \wedge \peq_2}}
\end{mathpar}


% Hoare logic for monadic functional language:
% https://tchajed.github.io/sys-verif-fa24/notes/hoare.html#example-consequences-of-bind-rule



\begin{proof}
  By induction on the structure of $\cmd$.

  \textit{Case} $\cmd = (\xassign{e_1}{e_2}{e_3})$. In this case by definition we have:
  \begin{mathpar}
    e_1 \redx x

    e_2 \redx \be

    e_3 \redx \cid

    \prog = (\xassign{x}{\be}{\cid})

    \peq_1 \redx \true

    \peq_2 \redx x \eop \toeq{\elab{\be}{\cid}}
  \end{mathpar}
  But we have $\htrip{\toeq{\elab{\be}{\cid}} \eop \toeq{\elab{\be}{\cid}}}{\xassign{x}{\be}{\cid}}{x \eop \toeq{\elab{\be}{\cid}}}$ by $\TirName{Assign}$ with $(\toeq{\elab{\be}{\cid}} \eop \toeq{\elab{\be}{\cid}})$ iff $\true$, so this case holds.

  \textit{Case} $\cmd = \elab{\assert{e_1 = e_2}}{e_3}$. In this case by definition we have:
  \begin{mathpar}
    e_1 \redx \be_1

    e_2 \redx \be_2

    e_3 \redx \cid

    \prog = \elab{\assert{\be_1 = \be_2}}{\cid}

    \peq_1 \redx \toeq{\elab{\be_1}{\cid}} \eop \toeq{\elab{\be_2}{\cid}}
    
    \peq_2 \redx \true
  \end{mathpar}
  But we have $\htrip{\toeq{\elab{\be_1}{\cid}} \eop \toeq{\elab{\be_2}{\cid}}}{\elab{\assert{\be_1 = \be_2}}{\cid}}{\toeq{\elab{\be_1}{\cid}} \eop \toeq{\elab{\be_2}{\cid}}}$ by $\TirName{Assert}$, so
  this case holds by an application of $\TirName{Consequence}$.

   \textit{Case} $\cmd = \cmd_1;\cmd_2$. In this case by definition we have:
  \begin{mathpar}
    \cmd_1 \redx \prog_1

    \cmd_2 \redx \prog_2

    \prog = \prog_1;\prog_2

    \peq_1 = \peq_1^1 \wedge \peq_1^2

    \peq_2 = \peq_2^1 \wedge \peq_2^2

    \peq_1 \redx \eqs_1^1 \wedge \eqs_1^2

    \peq_2 \redx \eqs_2^1 \wedge \eqs_2^2
  \end{mathpar}
  where by the induction hypothesis we have:
  \begin{mathpar}
    \htrip{\eqs_1^1}{\prog_1}{\eqs_2^1}

    \htrip{\eqs_1^2}{\prog_2}{\eqs_2^2}

    \vars(\prog_1) \cap \avars(\eqs_1^1) = \varnothing

    \vars(\prog_2) \cap \avars(\eqs_1^2) = \varnothing    
  \end{mathpar}
  But then by $\TirName{Frame}$ we have
  $\htrip{\eqs_1^1 \wedge \eqs_1^2}{\prog_1}{\eqs_2^1 \wedge \eqs_1^2}$ and
  $\htrip{\eqs_2^1 \wedge \eqs_1^2}{\prog_2}{\eqs_2^1 \wedge \eqs_2^2}$,
  so this case holds by an application of $\TirName{Seq}$.
\end{proof}

\begin{mathpar}
\inferrule[Assigns]
          {\htrip{\eqs_1}{\prog}{\eqs_2}}
          {\htrip{\eqs_1 \wedge \sigma_{\prog}(\eqs)}{\prog}{\eqs_2 \wedge \eqs}}
\end{mathpar}

\begin{lemma} $\eqs_1 \models \sigma_{\prog}(\eqs_2)$ iff $\eqs_1 \wedge \toeq{\sigma_{\prog}} \models \eqs_2$.
\end{lemma}

\begin{lemma}
  Given $\htrip{\peq_1}{\cmd}{\peq_2}$ with $\peq_1 \redx \eqs_1$, $\peq_2 \redx \eqs_2$,
  and $\cmd \redx \prog$. Then $\htrip{\sigma_{\prog}(\eqs_1)}{\prog}{\eqs_2}$
  and $\eqs_1 \wedge \toeq{\sigma_{\prog}} \models \eqs_1 \wedge \eqs_2$.
\end{lemma}

\begin{theorem}
  Given $\htrip{\peq_1}{\ttt{main()}}{\peq_2}$ with $\peq_1 \redx \eqs_1$, $\peq_2 \redx \eqs_2$,
  and $\cmd \redx \prog$. Then $\htrip{\eqs_1}{\prog}{\eqs_2}$.
\end{theorem}
