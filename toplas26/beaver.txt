//
// Correctness
//


IDEALF() { (s["x"]@1 + s["y"]@2) + (s["i"]@1 * s["j"]@2) }

RECON(x) { (m[x++"s"]@1 + m[x++"s"]@2) }

// These are Beaver triple constraints. Party 3 is the oracle.
BEAVERTRIP(x) {
  m[x++"c"]@3 == r[x++"a"]@3 * r[x++"b"]@3 AND
  m[x++"as"]@1 + m[x++"as"]@2 == r[x++"a"]@3 AND
  m[x++"bs"]@1 + m[x++"bs"]@2 == r[x++"b"]@3 AND
  m[x++"cs"]@1 + m[x++"cs"]@2 == m[x++"c"]@3 
}

sshare(x:string, i1:cid, i2:cid) {
   m[x++"s"]@i2 := (s[x] + -r[x])@i1;
   m[x++"s"]@i1 := r[x]@i1
}

_open(x:string, i1:cid, i2:cid, n:string){
    p[x++"n"] := m[x]@i2;
    m[x++"p"]@i1 = p[x++"n"] + m[x]@i1
}

open(x:string) {
  _open(x,1,2,"1");
  _open(x,2,1,"2")
}

secopen(d:string;x:string,a:string) {
    sum(d, x, a);				       
    open(d)
}

_sum(z:string, x:string, y:string, i:cid) { m[z++"s"]@i := (m[x++"s"] + m[y++"s"])@i }

sum(z:string, x:string, y:string){ _sum(z,x,y,1); _sum(z,x,y,2) }
postcondition: ( RECON(z) == RECON(x) + RECON(y) )

_mult(z : string, y : string, i : cid) {
    m[z++"s"]@i := (m[z++"d"] * m[y++"s"] + -m[z++"e"] * m[z++"as"] + m[z++"cs"])@i
}

precondition: ( BEAVERTRIP(z) )
mult(z : string, x : string, y : string) {
    secopen(z++"d", x, z++"a");
    secopen(z++"e", y, z++"b");
    _mult(z,y,1); _mult(z,y,2)
}
postcondition: ( RECON(z) == RECON(x) * RECON(y) )

precondition: ( BEAVERTRIP("k") ) 
main() {
    sshare("x", 1, 2);
    sshare("y", 2, 1);
    sshare("i", 1, 2);
    sshare("j", 2, 1);
    
    sum("z","x","y");
    mult("k","i","j");
    sum("out","z","k");
    open("out")
}
postcondition: ( m["out"]@1 == IDEALF() )

// raw

_open(x:string, i1:cid, i2:cid, n:string){
    p[x++"n"] := m[x]@i2;
    m[x++"p"]@i1 = p[x++"n"] + m[x]@i1
}

open(x:string) {
  _open(x,1,2,"1");
  _open(x,2,1,"2")
}

secopen(d:string;x:string,a:string) {
    sum(d, x, a);				       
    open(d)
}

// types

_open(x:string, i1:cid, i2:cid, n:string){
    p[x++"n"] := m[x]@i2;
    m[x++"p"]@i1 = p[x++"n"] + m[x]@i1
}

([m[x]@i1, m[x]@i2] : shares)
open(x:string) {
  _open(x,1,2,"1");
  _open(x,2,1,"2");
  [p[x++"1"],p[x++"2"]] : shares;
  m[d++"p"]@2 as m[d++"p"]@1  
}

precondition: ([m[x]@i1, m[x]@i2] : shares,
	       [m[a]@i1, m[a]@i2] : shares)
secopen(d:string;x:string,a:string) {
    sum(d, x, a);				       
    open(d);
    m[d++"p"]@1 as RECON(x) + r[x++a]@o;
    <m[d++"p"]@1> : public;
    <m[d++"p"]@2> : public
}

// BDOZ

MACOK(x, i1, i2) { m[x++"m"]@i2 == m[x++"k"]@i1 + (m["delta"]@i1 * m[x++"s"]@i2) }

MACed(x) { MACOK(x, 1, 2) AND MACOK(x, 2, 1) }

_open(x:string, i1:cid, i2:cid, n:string){
    p[x++"sn"] := m[x++"s"]@i2;
    p[x++"mn"] := m[x++"m"]@i2;
    assert(p[x++"mn"] = m[x++"k"] + (m["delta"] * p[x++"sn"]))@i1;
    m[x++"p"]@i1 = p[x++"sn"] + m[x]@i1
}

precondition: ( MACed(x) )
open(x:string) {
  _open(x,1,2,"1");
  _open(x,2,1,"2")
}

secopen(d:string;x:string,a:string) {
    sum(d, x, a);				       
    open(d)
}
