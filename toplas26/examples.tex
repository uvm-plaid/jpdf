\section{Extended Examples}
\label{section-examples}

In Section \ref{section-smt} we gave the example of 3-party additive
sharing for any field $\fieldp{p}$. In Sections \ref{section-ipj} and
\ref{section-metalangty} we discussed the example of YGC input encoding.
Now we consider examples that illustrate the versatility of the
$\TirName{Encode}$ typing rule for confidentiality, the use of
postconditions for correctness, and the use of both pre-~and
postconditions for integrity.

To evaluate our system especially regarding performance, using the
Satisfiability Modulo Fields theory in cvc5 on an Apple M1 processor,
we have verified correctness of additive sharing protocols in fields
up to size $\fieldp{2^{31} - 1}$ (an approximation of 32-bit integers)
which takes $\sim$7ms to compute for 3 parties and not significantly more
than for, e.g., $\fieldp{2}$. We have also verified the semi-homomorphic
encryption properties leveraged in the BDOZ circuit library functions
(Figures \ref{fig-bdozsum} and \ref{fig-bdozmult}) in fields up to
size $\fieldp{2^{31} - 1}$ which take $\sim$8ms for the property used for
the postcondition of the $\ttt{mult}$ gate. This is categorically
better performance than can be achieved using previous brute-force
methods in $\fieldp{2}$ \cite{skalka-near-ppdp24}.

\begin{fpfig}[t]{2-party gate library with Beaver Triple multiplication, circuit definition, and compositional correctness conditions.}{fig-beaver}
\footnotesize
\begin{verbatimtab}
IDEALF() { (s["x"]@1 + s["y"]@2) + (s["i"]@1 * s["j"]@2) }
  
RECON(x) { (m[x]@1 + m[x]@2) }

BEAVERTRIP(x) {
  m[x++"c"]@3 == r[x++"a"]@3 * r[x++"b"]@3 AND
  m[x++"a"]@1 + m[x++"a"]@2 == r[x++"a"]@3 AND
  m[x++"b"]@1 + m[x++"b"]@2 == r[x++"b"]@3 AND
  m[x++"c"]@1 + m[x++"c"]@2 == m[x++"c"]@3 
}

sshare(x:string, i1:cid, i2:cid) { m[x]@i2 := (s[x] + -r[x])@i1; m[x]@i1 := r[x]@i1 }

_open(x:string, i1:cid, i2:cid, n:string){ p[x++"n"] := m[x]@i2; m[x++"p"]@i1 = p[x++"n"] + m[x]@i1 }

open(x:string) { _open(x,1,2,"1"); _open(x,2,1,"2") }

secopen(d:string;x:string,a:string) { sum(d, x, a); open(d) }

_sum(z:string, x:string, y:string, i:cid) { m[z]@i := (m[x] + m[y])@i }

sum(z:string, x:string, y:string){ _sum(z,x,y,1); _sum(z,x,y,2) }
postcondition: ( RECON(z) == RECON(x) + RECON(y) )

_mult(z : string, y : string, i : cid) {
    m[z]@i := (m[z++"d"] * m[y] + -m[z++"e"] * m[z++"a"] + m[z++"c"])@i
}

precondition: ( BEAVERTRIP(z) )
mult(z : string, x : string, y : string) {
  secopen(z++"d", x, z++"a"); secopen(z++"e", y, z++"b"); _mult(z,y,1); _mult(z,y,2)
}
postcondition: ( RECON(z) == RECON(x) * RECON(y) )

precondition: ( BEAVERTRIP("k") ) 
main() {
    sshare("x", 1, 2); sshare("y", 2, 1); sshare("i", 1, 2); sshare("j", 2, 1);
    sum("z","x","y"); mult("k","i","j"); sum("out","z","k");
    open("out")
}
postcondition: ( m["out"]@1 == IDEALF() )
\end{verbatimtab}
\end{fpfig}


\begin{fpfig}[t]{2-party gate library with Beaver Triple multiplication extended with share type annotations.}{fig-beaver-types}
\footnotesize
\begin{verbatimtab}
sshare(x:string, i1:cid, i2:cid) {
   m[x++"s"]@i1 := (s[x] + -r[x])@i2; m[x++"s"]@i2 := r[x]@i2;
   [m[x++"s"]@i1,m[x++"s"]@i2] : shares
}

([m[x]@i1, m[x]@i2] : shares)
open(x:string) {
  _open(x,1,2,"1"); _open(x,2,1,"2");
  [p[x++"1"],p[x++"2"]] : shares;
  m[d++"p"]@2 as m[d++"p"]@1  
}

precondition: ([m[x]@i1, m[x]@i2] : shares,
	       [m[a]@i1, m[a]@i2] : shares)
secopen(d:string;x:string,a:string) {
    sum(d, x, a); open(d);
    m[d++"p"]@1 as RECON(x) + r[x++a]@o;
    <m[d++"p"]@1> : public;
    <m[d++"p"]@2> : public
}

precondition: ([m[x]@1,m[x]@2] : shares;
               [m[y]@1,m[y]@2] : shares)
sum(z:string, x:string, y:string) {
    _sum(z,x,y,1); _sum(z,x,y,2);
    [m[z]@1,m[z]@2] : shares
}
postcondition: ( RECON(z) == RECON(x) + RECON(y) )

precondition: ( [m[x]@1,m[x]@2] : shares;
                [m[y]@1,m[y]@2] : shares;
	        [m[x++"c"]@1,m[x++"c"]@2] : shares ),
	       ( BEAVERTRIP(z) )
mult(z : string, x : string, y : string) {
    secopen(z++"d", x, z++"a"); secopen(z++"e", y, z++"b"); _mult(z,y,1); _mult(z,y,2);
    [m[z]@i1,m[z]@i2] : shares
}
postcondition: ( RECON(z) == RECON(x) * RECON(y)) )
\end{verbatimtab}
\end{fpfig}

\begin{fpfig}[t]{2-party gate library with Beaver Triple multiplication extended with BDOZ MACs.}{fig-beaver-bdoz}
\footnotesize
\begin{verbatimtab}
MACOK(x, i1, i2) { m[x++"m"]@i2 == m[x++"k"]@i1 + (m["delta"]@i1 * m[x++"s"]@i2) }

MACed(x) { MACOK(x, 1, 2) AND MACOK(x, 2, 1) }

_open(x:string, i1:cid, i2:cid, n:string){
    p[x++"sn"] := m[x++"s"]@i2;
    p[x++"mn"] := m[x++"m"]@i2;
    assert(p[x++"mn"] = m[x++"k"] + (m["delta"] * p[x++"sn"]))@i1;
    m[x++"p"]@i1 = p[x++"sn"] + m[x]@i1
}

precondition: ( MACed(x) )
open(x:string) { _open(x,1,2,"1"); _open(x,2,1,"2") }

_sum(z:string, x:string, y:string, i:cid){
    m[z++"s"]@i := (m[x++"s"] + m[y++"s"])@i;
    m[z++"m"]@i := (m[x++"m"] + m[y++"m"])@i;
    m[z++"k"]@i := (m[x++"k"] + m[y++"k"])@i
}

precondition: ( MACed(x) AND MACed(y) )
sum(z:string, x:string, y:string){ _sum(z,x,y,1); _sum(z,x,y,2) }
postcondition: ( MACed(z) AND RECON(z) == RECON(x) + RECON(y) )
		 
_mult(z : string, y : string, i : cid) {
   m[z++"s"]@i := (m[z++"d"] * m[y++"s"] + -m[z++"e"] * m[z++"as"] + m[z++"cs"])@i;
   m[z++"m"]@i := (m[z++"d"] * m[y++"m"] + -m[z++"e"] * m[z++"am"] + m[z++"cm"])@i;
   m[z++"k"]@i := (m[z++"d"] * m[y++"k"] + -m[z++"e"] * m[z++"ak"] + m[z++"ck"])@i
}

precondition: ( MACed(x) AND MACed(y) AND
                MACed(z++"a") AND MACed(z++"b") AND MACed(z++"c") AND BEAVERTRIP(z) )
mult(z : string, x : string, y : string) {
    secopen(z++"d", x, z++"a"); secopen(z++"e", y, z++"b"); _mult(z,y,1); _mult(z,y,2);
}
postcondition: ( RECON(z) == RECON(x) * RECON(y) )
\end{verbatimtab}
\end{fpfig}

\subsection{Confidentiality Examples}

%\input{gmw}

In the 2-party GMW protocol \cite{evans2018pragmatic}, another garbled
binary circuit protocol, values are encrypted in a manner similar to
BDOZ as described in Section \ref{section-ipj}. In our definition of
GMW we use the convention that shared values $\macgv{\mesg{w}}$ are
identified by strings $w$ and encoded as shares $\mx{w}{1}$ and
$\mx{w}{2}$.  As for YGC, ciphertypes reflect the confidentiality of
GMW input encodings as defined in the $\ttt{encodegmw}$ function in
Figure \ref{fig-gmw}. No programmer annotation is needed given the
syntax of the function body. More interestingly, the $\ttt{andgmw}$
gate definition shows how a programmer hint can express the relevant
confidentiality property of the output share $\mx{z}{2}$ on client 2,
using the $\ttt{as}$ casting. The non-trivial equivalence can be
verified by SMT once during verification, and subsequently
confidentiality is expressed in the dependent type of the function (as
for $\ttt{encode}$).

Note also that the $\ttt{andgmw}$ function is decorated with a
postcondition that expresses the correctness property of the
function. Although not strictly necessary for confidentiality, this
annotation can at least help eliminate bugs, and also can be used
compositionally for whole-program correctness properties. As for
confidentiality hints, this postcondition needs to be verified only
once at the point of definition and subsequently is guaranteed to hold
for any application.

\subsection{Integrity Examples}

% \input{bdoz}

Returning to the example of malicious-secure 2-party BDOZ arithmetic
circuits begun in Section \ref{section-ipj}, in Figure \ref{fig-bdozsum} we
define $\ttt{sum}$ and $\ttt{open}$ functions. The latter implements
``secure opening''-- each party sends it's local share of a
global value $\macgv{\mesg{w}}$ along with its MAC to the other party,
which is authenticated via the $\macbdoz{w}$ check (in \ttt{\_open}),
and then each party reconstructs $\macgv{\mesg{w}}$. The preconditions
of $\ttt{open}$ specify the authentication requirements. 

The $\ttt{sum}$ function implements an addition gate. This is
non-interactive-- each party just sums its local shares
of the two values. The pre- and postcondition annotations
on $\ttt{sum}$ express the additive homomorphism associated
with this encryption scheme-- the sum of MACs of the input
shares is a valid MAC for the output share on each client,
which can be checked using the sum of keys of the input shares.

In BDOZ a pre-processing phase is assumed where initial input secrets
are shared along with their associated MACs and keys. This can be
expressed in $\eqspre$ for input secrets $\sx{\ttt{"x"}}{1}$ and
$\sx{\ttt{"y"}}{2}$, for example, which subsume the following
constraints on shares:
{\footnotesize$$
\begin{array}{l}
\mx{\ttt{"xs"}}{2} \eop \sx{\ttt{"x"}}{1} \fminus \rx{\ttt{"x"}}{1} \wedge 
\mx{\ttt{"xs"}}{1} \eop \rx{\ttt{"x"}}{1} \wedge \\
\mx{\ttt{"ys"}}{1} \eop \sx{\ttt{"y"}}{2} \fminus \rx{\ttt{"y"}}{2} \wedge 
\mx{\ttt{"ys"}}{2} \eop \rx{\ttt{"y"}}{2} 
\end{array}
$$}
and the following constraint on keys and MACs for authentication
of $\sx{\ttt{"x"}}{1}$ (and similarly for $\sx{\ttt{"y"}}{2}$):
{\footnotesize$$
\begin{array}{l}
\mx{\ttt{"delta"}}{1} \eop \rx{\ttt{"delta"}}{1} \wedge
\mx{\ttt{"xk"}}{1} \eop \rx{\ttt{"xk"}}{1} \wedge\\
\mx{\ttt{"xm"}}{2} \eop \mx{\ttt{"xk"}}{1} \fplus (\mx{\ttt{"delta"}}{1} * \mx{\ttt{"xs"}}{2})
\end{array}
$$}
Given these global preconditions, a malicious secure opening of $\sx{\ttt{"x"}}{1} +
\sx{\ttt{"y"}}{2}$ would be obtained as
$\ttt{sum}(\ttt{"z"},\ttt{"x"},\ttt{"y"}); \ttt{open}(\ttt{"z"})$,
which type checks.

A common approach to implementing multiplication gates in a BDOZ
setting is to use \emph{Beaver Triples}. Recall that Beaver triples
are values $a,b,c$ with $a$ and $b$ chosen randomly and $c = a * b$,
unique per multiplication gate, that are secret shared with clients
during pre-processing.  In our encoding we assume the additional
convention that each gate output identifier distinguishes the Beaver
triple, so for example the share of the $a$ value for a gate
$\ttt{"g1"}$ is identified by $\ttt{"g1as"}$, etc.

%, and $\eqspre$
%subsumes the following constraints for the $a,b,c$ values of gate
%$\ttt{"g1"}$.  {\footnotesize$$
%\begin{array}{l}
%\mx{\ttt{"g1as"}}{1} \eop \rx{\ttt{"g1as"}}{1}\ \wedge 
%\mx{\ttt{"g1bs"}}{1} \eop \rx{\ttt{"g1bs"}}{1}\ \wedge\\
%\mx{\ttt{"g1as"}}{2} \eop \rx{\ttt{"g1as"}}{2}\ \wedge 
%\mx{\ttt{"g1bs"}}{2} \eop \rx{\ttt{"g1bs"}}{2}\ \wedge\\
%\mx{\ttt{"g1cs"}}{1} \eop \\
%\qquad ((\mx{\ttt{"g1as"}}{1} \fplus \mx{\ttt{"g1bs"}}{2})\ \ftimes\\
%\qquad\phantom{(}(\mx{\ttt{"g1bs"}}{1} \fplus \mx{\ttt{"g1bs"}}{2})) \fminus \rx{\ttt{"g1cs"}}{2}\ \wedge\\
%\mx{\ttt{"g1cs"}}{2} \eop \rx{\ttt{"g1cs"}}{2}
%\end{array}
%$$}

The definition of the $\ttt{mult}$ gate is presented in Figure
\ref{fig-bdozmult},
%where we present just client 1's side of the
%protocol $\ttt{\_mult1}$ (client 2's side is nearly symmetric but with
%a small variation-- refer to
%\cite{evans2018pragmatic,10.1007/978-3-030-68869-1_3} for more
%details).
%We could call this function on input secrets
%$\sx{\ttt{"x"}}{1}$ and $\sx{\ttt{"y"}}{2}$ in gate $\ttt{"g1"}$ as
%$\ttt{mult}(\ttt{"g1"},\ttt{"x"},\ttt{"y"})$, for example, or embed
%this gate internally in a circuit.
%
As for $\ttt{sum}$, the preconditions of $\ttt{mult}$ express
the expected MAC properties of input shares, as well as the
expected Beaver Triple property, and its postcondition
fexpresses the semi-homomorphic encryption property of
the resulting share, MAC, and key after gate execution-- specifically,
it preserves the BDOZ authentication property. Finally, the
postcondition of $\ttt{mult}$ expresses the
correctness property of the multiplication gate. In any case,
integrity of any circuit constructed from the $\ttt{sum}$ and
$\ttt{mult}$ library functions will require little SMT overhead
due to compositional verification, once their pre- and postconditions
are verified by type checking. 

