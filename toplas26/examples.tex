\begin{fpfig}[t]{2-party gate library with Beaver Triple multiplication, circuit definition, and compositional correctness conditions.}{fig-beaver}
\footnotesize
\begin{verbatimtab}
IDEALF() { (s["x"]@1 + s["y"]@2) + (s["i"]@1 * s["j"]@2) }
  
RECON(x) { (m[x]@1 + m[x]@2) }

BEAVERTRIP(x) {
  m[x++"c"]@3 == r[x++"a"]@3 * r[x++"b"]@3 AND
  m[x++"a"]@1 + m[x++"a"]@2 == r[x++"a"]@3 AND
  m[x++"b"]@1 + m[x++"b"]@2 == r[x++"b"]@3 AND
  m[x++"c"]@1 + m[x++"c"]@2 == m[x++"c"]@3 
}

genshares(x:string, i1:cid, i2:cid) { m[x]@i2 := (s[x] + -r[x])@i1; m[x]@i1 := r[x]@i1 }

_open(x:string, i1:cid, i2:cid, n:string){ p[x++"n"] := m[x]@i2; m[x++"p"]@i1 := p[x++"n"] + m[x]@i1 }

open(x:string) { _open(x,1,2,"1"); _open(x,2,1,"2") }

secopen(d:string;x:string,a:string) { sum(d, x, a); open(d) }

_sum(z:string, x:string, y:string, i:cid) { m[z]@i := (m[x] + m[y])@i }

sum(z:string, x:string, y:string){ _sum(z,x,y,1); _sum(z,x,y,2) }
postcondition: ( RECON(z) == RECON(x) + RECON(y) )

_mult(z : string, y : string, i : cid) {
    m[z]@i := (m[z++"d"] * m[y] + -m[z++"e"] * m[z++"a"] + m[z++"c"])@i
}

precondition: ( BEAVERTRIP(z) )
mult(z : string, x : string, y : string) {
  secopen(z++"d", x, z++"a"); secopen(z++"e", y, z++"b"); _mult(z,y,1); _mult(z,y,2)
}
postcondition: ( RECON(z) == RECON(x) * RECON(y) )

precondition: ( BEAVERTRIP("k") ) 
main() {
    genshares("x", 1, 2); genshares("y", 2, 1); genshares("i", 1, 2); genshares("j", 2, 1);
    sum("z","x","y"); mult("k","i","j"); sum("out","z","k");
    open("out");
    out@1 = m["out"]@1; out@2 =  m["out"]@2
    
}
postcondition: ( out@1 == IDEALF() AND out@2 == IDEALF() )
\end{verbatimtab}
\end{fpfig}

\section{Extended Examples}
\label{section-examples}

In Section \ref{section-smt} we gave the example of 3-party additive
sharing for any field $\fieldp{p}$, in Section \ref{section-sty} we
discussed the example of YGC input encoding, and in Sections
\ref{section-metalang} and \ref{section-metaty} we presented and
discussed the example of gates in the GMW protocol for binary
circuits. In this section we present an extended example of arithmetic
circuits with multiplication gates defined using Beaver triples
\cite{evans2018pragmatic}. We first define a compositional gate
library in $\metaprot$ with correctness conditions defined using the
Hoare logic developed in Section \ref{section-metalang}, along with a
small example circuit.  Then we will extend the library with type
annotations illustrating the use of share types developed in
Sections \ref{section-sty} and \ref{section-metaty} to enforce
confidentiality properties. Last, we will extend the base library
with additional pre and postcondition annotations to enforce
integrity properties supported by BDOZ/SPDZ style MACs
\cite{SPDZ1,SPDZ2,BDOZ,10.1007/978-3-030-68869-1_3}.

To evaluate our system especially regarding performance, using the
Satisfiability Modulo Fields theory in cvc5 on an Apple M1 processor,
we have verified correctness of these arithmetic gate libraries and
circuit in fields up to size $\fieldp{2^{31} - 1}$ (an approximation
of 32-bit integers) which takes $\sim$7ms to compute for 3 parties and
not significantly more than for, e.g., $\fieldp{2}$. We have also
verified the semi-homomorphic encryption properties leveraged in the
BDOZ circuit library functions in fields up to size $\fieldp{2^{31} -
  1}$ which take $\sim$8ms for the property used for the postcondition
of the $\ttt{mult}$ gate. This is categorically better performance
than can be achieved using previous brute-force methods in
$\fieldp{2}$ \cite{skalka-near-ppdp24}.

\subsection{Arithmetic Circuits with Beaver Triples}
\label{section-beaver}


In Figure \ref{fig-beaver} we define a 2-party arithmetic circuit with
4 input gates, 3 internal gates, and 1 output gate. The ideal functionality
is defined as $\ttt{IDEALF}$. As in GMW or BDOZ, circuit wire values
are represented as additive secret shares between two clients we call
$\ttt{1}$ and $\ttt{2}$. As in the GMW example discussed in Section
\ref{section-metaty}, we use string idenfiers $g$ to distinguish
gates, and gate output wire shares are defined as identifiers
$\mx{g}{1}$ and $\mx{g}{2}$. The function $\ttt{RECON}$
represents share reconstruction \emph{in constraints} (not the
protocols themselves). Input gates are
implemented using the $\ttt{genshares}$ function as described in
Section \ref{section-sty}. The $\ttt{open}$ function
implements a federation reveal of a shared value through
share broadcast and reconstruction.

A \ttt{sum} gate can be defined non-interactively using the
homomorphic addition. The correctness \ttt{postcondition} is simple
and perhaps unecessary to accelerate circuit verification, but is
appealing declaratively.  The multiplication gate \ttt{mult} is more
complex. We use the common approach of \emph{Beaver Triples}
\cite{evans2018pragmatic}. Recall that Beaver triples are values
$a,b,c$ with $a$ and $b$ chosen randomly and $c = a * b$, unique per
multiplication gate, that are secret-shared with clients during a
pre-processing phase by an assumed oracular client $\ttt{3}$.
The uniqueness requirement is necessary because
$a$ and $b$ are random values that serve as OTP masks for secure
openings, implemented as \ttt{secopen}. In our encoding we follow the
convention that each gate output identifier distinguishes the Beaver
triple, so for example the share of the $a$ value for a gate
$\ttt{"g"}$ is identified by $\ttt{"ga"}$, etc. The correctness
property of the multiplication gate, expressed as a
\ttt{postcondition}, relies on the $\ttt{BEAVERTRIP}$
precondition. This compositional correctness property can then be used
in circuit construction, without the need for ``re-proof'' in our
Hoare logic inference.

The circuit itself is constructed in \ttt{main} using these
gates. This is a small example but arbitrarily large circuits
can be constructed with this library. The precondition of
\ttt{main} must require distinct Beaver triples for each
multiplication gate in the circuit. The postcondition allows
verification of circuit correctness-- that the protocol
output is equal to the ideal functionality $\ttt{IDEALF}$.

\subsection{Share Type Annotations.}

\begin{fpfig}[t]{2-party gate library with Beaver Triple multiplication extended with share type annotations.}{fig-beaver-types}
\footnotesize
\begin{verbatimtab}
genshares(x:string, i1:cid, i2:cid) {
   m[x++"s"]@i1 := (s[x] + -r[x])@i2; m[x++"s"]@i2 := r[x]@i2;
   [m[x++"s"]@i1,m[x++"s"]@i2] : shares
}

([m[x]@i1, m[x]@i2] : shares)
open(x:string) {
  _open(x,1,2,"1"); _open(x,2,1,"2");
  [p[x++"1"],p[x++"2"]] : shares;
  m[d++"p"]@2 as m[d++"p"]@1  
}

precondition: ([m[x]@i1, m[x]@i2] : shares,
	       [m[a]@i1, m[a]@i2] : shares)
secopen(d:string;x:string,a:string) {
    sum(d, x, a); open(d);
    m[d++"p"]@1 as RECON(x) + r[x++a]@3;
    <m[d++"p"]@1> : public;
    <m[d++"p"]@2> : public
}

precondition: ([m[x]@1,m[x]@2] : shares;
               [m[y]@1,m[y]@2] : shares)
sum(z:string, x:string, y:string) {
    _sum(z,x,y,1); _sum(z,x,y,2);
    [m[z]@1,m[z]@2] : shares
}
postcondition: ( RECON(z) == RECON(x) + RECON(y) )

precondition: ( [m[x]@1,m[x]@2] : shares;
                [m[y]@1,m[y]@2] : shares;
	        [m[x++"c"]@1,m[x++"c"]@2] : shares ),
	       ( BEAVERTRIP(z) )
mult(z : string, x : string, y : string) {
    secopen(z++"d", x, z++"a"); secopen(z++"e", y, z++"b"); _mult(z,y,1); _mult(z,y,2);
    [m[z]@i1,m[z]@i2] : shares
}
postcondition: ( RECON(z) == RECON(x) * RECON(y)) )
\end{verbatimtab}
\end{fpfig}

In Figure \ref{fig-beaver-types} we extend our previous gate definitions with
share type annotations to enforce confidentiality. The core idea is that
wire values must be \ttt{share}s. The \ttt{genshares}
function includes an annotation specifying that all input gates establish
the $\ttt{shares}$ invariant for wire values. In the \ttt{sum} function,
the \ttt{share} type preconditions for input wires are specified. The
output wire shares can be declared as \ttt{share}s without any coercion
needed, since given preconditions our typing algorithm ($\Vdash$) is
able to check the use of homomorphic addition. 

We add coercions and typing assertions to the $\ttt{secopen}$ function
to specify properties of secure openings. After noninteractively
summing a wire value $\ttt{x}$ and a random Beaver triple value
$\ttt{x++a}$, the federation can publicly open the value since it is
masked by the random value. This is expressed using the coercion
$\ttt{as RECON(x) +  r[x++a]@3}$.

\subsubsection{Malicious-Secure Arithmetic Circuits}


\begin{fpfig}[t]{2-party gate library with Beaver Triple multiplication extended with BDOZ MACs.}{fig-beaver-bdoz}
\footnotesize
\begin{verbatimtab}
MACOK(x, i1, i2) { m[x++"m"]@i2 == m[x++"k"]@i1 + (m["delta"]@i1 * m[x++"s"]@i2) }

MACed(x) { MACOK(x, 1, 2) AND MACOK(x, 2, 1) }

_open(x:string, i1:cid, i2:cid, n:string){
    p[x++"sn"] := m[x++"s"]@i2;
    p[x++"mn"] := m[x++"m"]@i2;
    assert(p[x++"mn"] = m[x++"k"] + (m["delta"] * p[x++"sn"]))@i1;
    m[x++"p"]@i1 := p[x++"sn"] + m[x]@i1
}

precondition: ( MACed(x) )
open(x:string) { _open(x,1,2,"1"); _open(x,2,1,"2") }

_sum(z:string, x:string, y:string, i:cid){
    m[z++"s"]@i := (m[x++"s"] + m[y++"s"])@i;
    m[z++"m"]@i := (m[x++"m"] + m[y++"m"])@i;
    m[z++"k"]@i := (m[x++"k"] + m[y++"k"])@i
}

precondition: ( MACed(x) AND MACed(y) )
sum(z:string, x:string, y:string){ _sum(z,x,y,1); _sum(z,x,y,2) }
postcondition: ( MACed(z) AND RECON(z) == RECON(x) + RECON(y) )
		 
_mult(z : string, y : string, i : cid) {
   m[z++"s"]@i := (m[z++"d"] * m[y++"s"] + -m[z++"e"] * m[z++"as"] + m[z++"cs"])@i;
   m[z++"m"]@i := (m[z++"d"] * m[y++"m"] + -m[z++"e"] * m[z++"am"] + m[z++"cm"])@i;
   m[z++"k"]@i := (m[z++"d"] * m[y++"k"] + -m[z++"e"] * m[z++"ak"] + m[z++"ck"])@i
}

precondition: ( MACed(x) AND MACed(y) AND
                MACed(z++"a") AND MACed(z++"b") AND MACed(z++"c") AND BEAVERTRIP(z) )
mult(z : string, x : string, y : string) {
    secopen(z++"d", x, z++"a"); secopen(z++"e", y, z++"b"); _mult(z,y,1); _mult(z,y,2);
}
postcondition: ( RECON(z) == RECON(x) * RECON(y) )
\end{verbatimtab}
\end{fpfig}


In BDOZ a pre-processing phase is assumed where initial input secrets
are shared along with their associated MACs and keys. This can be
expressed in $\eqspre$ for input secrets $\sx{\ttt{"x"}}{1}$ and
$\sx{\ttt{"y"}}{2}$, for example, which subsume the following
constraints on shares:
{\footnotesize$$
\begin{array}{l}
\mx{\ttt{"xs"}}{2} \eop \sx{\ttt{"x"}}{1} \fminus \rx{\ttt{"x"}}{1} \wedge 
\mx{\ttt{"xs"}}{1} \eop \rx{\ttt{"x"}}{1} \wedge \\
\mx{\ttt{"ys"}}{1} \eop \sx{\ttt{"y"}}{2} \fminus \rx{\ttt{"y"}}{2} \wedge 
\mx{\ttt{"ys"}}{2} \eop \rx{\ttt{"y"}}{2} 
\end{array}
$$}
and the following constraint on keys and MACs for authentication
of $\sx{\ttt{"x"}}{1}$ (and similarly for $\sx{\ttt{"y"}}{2}$):
{\footnotesize$$
\begin{array}{l}
\mx{\ttt{"delta"}}{1} \eop \rx{\ttt{"delta"}}{1} \wedge
\mx{\ttt{"xk"}}{1} \eop \rx{\ttt{"xk"}}{1} \wedge\\
\mx{\ttt{"xm"}}{2} \eop \mx{\ttt{"xk"}}{1} \fplus (\mx{\ttt{"delta"}}{1} * \mx{\ttt{"xs"}}{2})
\end{array}
$$}
Given these global preconditions, a malicious secure opening of $\sx{\ttt{"x"}}{1} +
\sx{\ttt{"y"}}{2}$ would be obtained as
$\ttt{sum}(\ttt{"z"},\ttt{"x"},\ttt{"y"}); \ttt{open}(\ttt{"z"})$,
which type checks.


The definition of the $\ttt{mult}$ gate is presented in Figure
\ref{fig-bdozmult},
%where we present just client 1's side of the
%protocol $\ttt{\_mult1}$ (client 2's side is nearly symmetric but with
%a small variation-- refer to
%\cite{evans2018pragmatic,10.1007/978-3-030-68869-1_3} for more
%details).
%We could call this function on input secrets
%$\sx{\ttt{"x"}}{1}$ and $\sx{\ttt{"y"}}{2}$ in gate $\ttt{"g1"}$ as
%$\ttt{mult}(\ttt{"g1"},\ttt{"x"},\ttt{"y"})$, for example, or embed
%this gate internally in a circuit.
%
As for $\ttt{sum}$, the preconditions of $\ttt{mult}$ express
the expected MAC properties of input shares, as well as the
expected Beaver Triple property, and its postcondition
fexpresses the semi-homomorphic encryption property of
the resulting share, MAC, and key after gate execution-- specifically,
it preserves the BDOZ authentication property. Finally, the
postcondition of $\ttt{mult}$ expresses the
correctness property of the multiplication gate. In any case,
integrity of any circuit constructed from the $\ttt{sum}$ and
$\ttt{mult}$ library functions will require little SMT overhead
due to compositional verification, once their pre- and postconditions
are verified by type checking. 

