\input{beaver}

\section{Extended Examples}
\label{section-examples}

In Section \ref{section-smt} we gave the example of 3-party additive
sharing for any field $\fieldp{p}$, in Section \ref{section-sty} we
discussed the example of YGC input encoding, and in Sections
\ref{section-metalang} and \ref{section-metaty} we presented and
discussed the example of gates in the GMW protocol for binary
circuits. In this section we present an extended example of arithmetic
circuits with multiplication gates defined using Beaver triples
\cite{evans2018pragmatic}. We first define a compositional gate
library in $\metaprot$ with correctness conditions defined using the
Hoare logic developed in Section \ref{section-metalang}, along with a
small example circuit.  Then we will extend the library with type
annotations illustrating the use of share types developed in
Sections \ref{section-sty} and \ref{section-metaty} to enforce
confidentiality properties. Last, we will extend the base library
with additional pre and postcondition annotations to enforce
integrity properties supported by BDOZ/SPDZ style MACs
\cite{SPDZ1,SPDZ2,BDOZ,10.1007/978-3-030-68869-1_3}.

To evaluate our system especially regarding performance, using the
Satisfiability Modulo Fields theory in cvc5 on an Apple M1 processor,
we have verified correctness of these arithmetic gate libraries and
circuit in fields up to size $\fieldp{2^{31} - 1}$ (an approximation
of 32-bit integers) which takes $\sim$7ms to compute for 3 parties and
not significantly more than for, e.g., $\fieldp{2}$. We have also
verified the semi-homomorphic encryption properties leveraged in the
BDOZ circuit library functions in fields up to size $\fieldp{2^{31} -
  1}$ which take $\sim$8ms for the property used for the postcondition
of the $\ttt{mult}$ gate. This is categorically better performance
than can be achieved using previous brute-force methods in
$\fieldp{2}$ \cite{skalka-near-ppdp24}.

\subsection{Arithmetic Circuits with Beaver Triples}
\label{section-beaver}


In Figure \ref{fig-beaver} we define a 2-party arithmetic circuit with
4 input gates, 3 internal gates, and 1 output gate. The ideal functionality
is defined as $\ttt{IDEALF}$. As in GMW or BDOZ, circuit wire values
are represented as additive secret shares between two clients we call
$\ttt{1}$ and $\ttt{2}$. As in the GMW example discussed in Section
\ref{section-metaty}, we use string idenfiers $g$ to distinguish
gates, and gate output wire shares are defined as identifiers
$\mx{g}{1}$ and $\mx{g}{2}$. The function $\ttt{RECON}$
represents share reconstruction \emph{in constraints} (not the
protocols themselves). Input gates are
implemented using the $\ttt{genshares}$ function as described in
Section \ref{section-sty}. The $\ttt{open}$ function
implements a federation reveal of a shared value through
share broadcast and reconstruction.

A \ttt{sum} gate can be defined non-interactively using the
homomorphic addition. The correctness \ttt{postcondition} is simple
and perhaps unecessary to accelerate circuit verification, but is
appealing declaratively.  The multiplication gate \ttt{mult} is more
complex. We use the common approach of \emph{Beaver Triples}
\cite{evans2018pragmatic}. Recall that Beaver triples are values
$a,b,c$ with $a$ and $b$ chosen randomly and $c = a * b$, unique per
multiplication gate, that are secret-shared with clients during a
pre-processing phase by an assumed oracular client $\ttt{3}$.
The uniqueness requirement is necessary because
$a$ and $b$ are random values that serve as OTP masks for secure
openings, implemented as \ttt{secopen}. In our encoding we follow the
convention that each gate output identifier distinguishes the Beaver
triple, so for example the share of the $a$ value for a gate
$\ttt{"g"}$ is identified by $\ttt{"ga"}$, etc. The correctness
property of the multiplication gate, expressed as a
\ttt{postcondition}, relies on the $\ttt{BEAVERTRIP}$
precondition. This compositional correctness property can then be used
in circuit construction, without the need for ``re-proof'' in our
Hoare logic inference.


The circuit itself is constructed in \ttt{main} using these
gates. This is a small example but arbitrarily large circuits
can be constructed with this library. The precondition of
\ttt{main} must require distinct Beaver triples for each
multiplication gate in the circuit. The postcondition allows
verification of circuit correctness-- that the protocol
output is equal to the ideal functionality $\ttt{IDEALF}$.

\subsection{Share Type Annotations.}

In Figure \ref{fig-beaver-types} we extend our previous gate definitions with
share type annotations to enforce confidentiality. The core idea is that
wire values must be \ttt{share}s. The \ttt{genshares}
function includes an annotation specifying that all input gates establish
the $\ttt{shares}$ invariant for wire values. In the \ttt{sum} function,
the \ttt{share} type preconditions for input wires are specified. The
output wire shares can be declared as \ttt{share}s without any coercion
needed, since given preconditions our typing algorithm ($\Vdash$) is
able to check the use of homomorphic addition. 

We add coercions and typing assertions to the $\ttt{secopen}$ function
to specify properties of secure openings. After noninteractively
summing a wire value $\ttt{x}$ and a random Beaver triple value
$\ttt{x++a}$, the federation can publicly open the value since it is
masked by the random value. This is expressed using the coercion
$\ttt{as RECON(x) +  r[x++a]@3}$. The coercion then allows the
opened value to be declared $\ttt{public}$.

In the \ttt{mult} function, each client $\ttt{i}$ symmetrically
computes:
$$
\ttt{((m[z++"d"] * m[y]) + (-m[z++"e"] * m[z++"a"]) + m[z++"c"])@i}
$$
Since $\ttt{m[z++"d"]@i : public}$ and $\ttt{m[z++"e"]@i : public}$
are both established by $\ttt{secopen}$, and
$\ttt{m[y]@i}$, $\ttt{m[z++"a"]@i}$, and $\ttt{m[z++"c"]@i}$ are
all declared to be shares in preconditions, we have that each
of the shared computations $\ttt{(m[z++"d"] * m[y])@i}$ and $\ttt{(-m[z++"e"] * m[z++"a"])@i}$
are shares, so the gate outputs are shares, and this will
be successfully checked by syntax-directed $\Vdash$ type checking that
results from the declaration $\ttt{[m[z]@i1,m[z]@i2] : shares}$. 

\subsubsection{Malicious-Secure Arithmetic Circuits}

Our Definition \ref{def-integrity} establishes a general semantics of
integrity, while the $\minicat$ integrity type system presented in
Section \ref{section-ipj} focuses on the use of BDOZ/SPDZ-style
MACs. A main concern here is the encorcement of MAC checking which is
an algebraic property. Here we show how pre and postconditions can be
used to enforce these properties in our arithmetic circuit library, in
Figure \ref{fig-beaver-bdoz}. Note that this code is an extension of the
library presented in Figure \ref{fig-beaver} and does not incorporate
the type annotations in Figure \ref{fig-beaver-types}, but this is
just for clarity of the presentation and these features could be combined. 

