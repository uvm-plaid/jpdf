\section{The $\metaprot$ Language and Automated Hoare Logic}
\label{section-metalang}

The $\metaprot$ language \cite{skalka-near-ppdp24} includes structured
data and function definitions for defining composable protocol
elements at a higher level of abstraction than $\minicat$.  The
$\metaprot$ language is a \emph{metalanguage} aka metaprogramming
language, where an $\fedprot$ protocol is the result of
computation. In addition to these declarative benefits of $\metaprot$,
component definitions support compositional verification of larger
protocols. Separate verification of well-designed components results
in confidentiality and integrity properties to be recorded in their
types, allowing for significant reduction of SMT verification in whole
program analysis, as we will discuss with extended examples in Section
\ref{section-examples}.

\metaprotsyntaxfig

\subsection{Syntax and Semantics}

The syntax of $\metaprot$ is defined in Figure
\ref{fig-metaprotsyntax}.  It includes a syntax of values $\mv$ that
include client ids $\cid$, identifier strings $w$, expressions $\be$
in field $\mathbb{F}_p$, record values, and $\minicat$ variables
$x$. $\metaprot$ expression forms allow dynamic construction of these
values. $\metaprot$ \emph{instruction} forms allow dynamic
construction of $\minicat$ protocols $\prog$ that incorporate expression
evaluation. The syntax also supports definitions of functions that
compute values $\mv$ and, as a distinct form, functions that compute
protocols $\prog$.  Formally, we consider a complete metaprogram to include
both a codebase and a ``main'' program that uses the codebase.
We disallow recursion, mainly to guarantee decidability
of type dependence (Section \ref{section-metalangty}).
\begin{definition}
A \emph{codebase} $\codebase$ is a list of function 
declarations. We write $ \codebase(f) = y_1,\ldots,y_n,\ e$
if $f(y_1,\ldots,y_n) \{ e \} \in \codebase$, and we
write  $ \codebase(f) = y_1 : \tau_1, \ldots, y_n : \tau_n, \instr$
if $f(y_1 : \tau_1, \ldots, y_n : \tau_n) \{ \instr \} \in \codebase$.
%A \emph{metaprogram}, aka \emph{metaprotocol}  is a pair of a 
%codebase and expression $\codebase, e$. We may omit
%$\codebase$ if it is clear from context.  
\end{definition}

\metaprotexprsemanticsfig

We define a big-step evaluation relation $\redx$ in Figures
\ref{fig-metaprotexprsemantics} and \ref{fig-metaprotinstrsemantics}
for expressions and instructions, respectively.  In this definition we
write $e[\mv/y]$ and $\instr[\mv/y]$ to denote the substitution of
$\mv$ for free occurrences of $y$ in $e$ or $\instr$ respectively. The
rules are mostly standard. Note that we do not include an evaluation
rule for the form $\eqcast{\mx{e}{e}}{\notg{\phi}}$ which is a type
annotation that we assume is erased from programs prior to
evaluation. We defer discussion of this form, as well as the syntactic
category $\notg{\phi}$, to the next Section.

\metaprotinstrsemanticsfig

\subsection{$\metaprot$ Automated Abstract Hoare Logic}

\begin{verbatimtab}
precondition: ( m[x++"foo"]@1 == 3 )
bar(x:string){ m[x++"bar"]@2 := (m[x++"foo"] + m[x++"baz"])@1 }
postcondition: ( [m[z++"bar"]@2 == m[x++"baz"]@1 + 3 )
\end{verbatimtab}

\peqfig

\begin{lemma}
  \label{lemma-genentails}
  If $\forall y_1:\tau_1,\ldots,y_n:\tau_n . \peq_1 \models \peq_2$ and
  $\peq_1[\mv_1/y_1]\cdots[\mv_n/y_n] \redx \eqs_1$ and
  $\peq_2[\mv_1/y_1]\cdots[\mv_n/y_n] \redx \eqs_2$, then
  $\eqs_1 \models \eqs_2$.  
\end{lemma}


\begin{fpfig}[t]{Algorithmic $\metaprot$ Abstract Hoare Triple Deduction Rules}{fig-metahtrip}
\begin{mathpar}
\inferrule[GenEntails]
          {\mv_1,\ldots,\mv_n = \fresh(\tau_1,\ldots,\tau_n) \\ \peq_1[\mv_1/y_n \cdots \mv_n/y_n] \redx \eqs_1 \\
           \peq_2[\mv_1/y_n \cdots \mv_n/y_n] \redx \eqs_2 \\ \eqs_1 \models \eqs_2}
          {\forall y_1:\tau_1,\ldots,y_n:\tau_n . \peq_1 \models \peq_2 }
          
  \inferrule[Mesg]
            {}
            {\htrip{\eqtrue}{\xassign{e_1}{e_2}{e_3}}{e_1 \eop \toeq{\elab{e_2}{e_3}}}}

  %\inferrule[Encode]
  %          {\mx{e_1}{e_2} \redx x \\ \notg{\phi} \redx \phi \\
  %            \eqs \models x \eop \phi\\
  %            \atj{\phi}{R}{\ty}}
  %          {\mtj{\eqcast{\mx{e_1}{e_2}}{\notg{\phi}}}{\eqs}{(x : \ty)}{R}{\varnothing}{\eqs}}
  %
  \inferrule[Assert]
            {}
            {\htrip{\toeq{\elab{e_1}{e_3}} \eop \toeq{\elab{e_2}{e_3}}}{\elab{\assert{e_1 = e_2}}{e_3}}{\eqtrue}}

  \inferrule[Seq]          
            {\htrip{\peq_1^1}{\cmd_1}{\peq_2^1} \\ \htrip{\peq_1^2}{\cmd_2}{\peq_2^2}}
            {\htrip{\peq_1^1 \wedge (\peq_2^1 \impl \peq_1^2)}{\cmd_1;\cmd_2}{\peq_2^1 \wedge \peq_2^2}}

  \inferrule[Let]
            {\htrip{\peq_1}{\cmd[e/y]}{\peq_2}}
            {\htrip{\peq_1}{\elet{y}{e}{\cmd}}{\peq_2}}

  \inferrule[App]
            {\htrip{\peq_1}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq_2}}
            {\htrip{\peq_1[e_1/y_1 \cdots e_n/y_n]}{f(e_1,\ldots,e_n)}{\peq_2[e_1/y_1 \cdots e_n/y_n]}}

  \inferrule[Fn]
            {\codebase(f) = y_1 : \tau_1, \ldots, y_n : \tau_n, \cmd \\ \htrip{\peq_1}{\cmd}{\peq_2}}
            {\htrip{\peq_1}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq_2}}

  \inferrule[Hardpack]
            {\precond(f) = \peq_1 \\ \postcond(f) = \peq_2 \\
              \htrip{\peq_1'}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq_2'} \\
              \forall y_1:\tau_1,\ldots,y_n:\tau_n . 
            \peq_1 \models \peq_1'\ \text{and}\ \peq_1 \wedge \peq_2' \models \peq_2}
            {\htrip{\peq_1}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq_2}}
\end{mathpar}
\end{fpfig}


\begin{lemma}
  \label{lemma-closure}
  If $\htrip{\peq_1}{\prog}{\peq_2}$ and $\instr[\mv_1/y_1]\cdots[\mv_n/y_n] \redx \prog$
  then $\peq_1[\mv_1/y_1]\cdots[\mv_n/y_n] \redx \eqs_1$ and
  $\peq_2[\mv_1/y_1]\cdots[\mv_n/y_n] \redx \eqs_2$ for some $\eqs_1, \eqs_2$. 
\end{lemma}

\begin{lemma}[$\metaprot$ Hoare Triple Correctness]
  \label{lemma-htrip}
  If $\htrip{\peq_1}{\cmd}{\peq_2}$ with $\peq_1 \redx
  \eqs_1$, $\peq_2 \redx \eqs_2$, and $\cmd \redx
  \prog$, then $\htrip{\eqs_1}{\prog}{\eqs_2}$.
\end{lemma}

\begin{proof}
  By structural induction on the derivation of $\cmd \redx \prog$ and
  case analysis on $\cmd$.

  \textit{Case} $\cmd = (\xassign{e_1}{e_2}{e_3})$. In this case by definition
  and inversion of $\redx$ and $\TirName{Assign}$ we have:
  \begin{mathpar}
    e_1 \redx x

    e_2 \redx \be

    e_3 \redx \cid

    \prog = (\xassign{x}{\be}{\cid})

    \peq_1 \redx \true

    \peq_2  \redx x \eop \toeq{\elab{\be}{\cid}}
  \end{mathpar}
  Now by \TirName{Assign} we have
  $\htrip{\toeq{\elab{\be}{\cid}} \eop \toeq{\elab{\be}{\cid}}}{\xassign{x}{\be}{\cid}}{x \eop \toeq{\elab{\be}{\cid}}}$, so
  we have
  $\htrip{\true}{\xassign{x}{\be}{\cid}}{x \eop
    \toeq{\elab{\be}{\cid}}}$ by \TirName{Consequence}.

  \textit{Case} $\cmd = \elab{\assert{e_1 = e_2}}{e_3}$. In this case by definition we have:
  \begin{mathpar}
    e_1 \redx \be_1

    e_2 \redx \be_2

    e_3 \redx \cid

    \prog = \elab{\assert{\be_1 = \be_2}}{\cid}

    \peq_1 \redx \toeq{\elab{\be_1}{\cid}} \eop \toeq{\elab{\be_2}{\cid}}
    
    \peq_2 \redx \true
  \end{mathpar}
  But we have $\htrip{\toeq{\elab{\be_1}{\cid}} \eop \toeq{\elab{\be_2}{\cid}}}{\elab{\assert{\be_1 = \be_2}}{\cid}}{\toeq{\elab{\be_1}{\cid}} \eop \toeq{\elab{\be_2}{\cid}}}$ by $\TirName{Assert}$, so
  $\htrip{\toeq{\elab{\be_1}{\cid}} \eop \toeq{\elab{\be_2}{\cid}}}{\elab{\assert{\be_1 = \be_2}}{\cid}}{\true}$ by $\TirName{Consequence}$.

  \textit{Case} $\cmd = \cmd_1;\cmd_2$. In this case by assumption and
  definition and inversion of $\redx$ and $\TirName{Seq}$ we have:
  \begin{mathpar}
    \cmd_1 \redx \prog_1

    \cmd_2 \redx \prog_2

    \prog = \prog_1;\prog_2

    \peq_1 \redx \eqs_1^1 \wedge (\eqs_2^1 \impl \eqs_1^2)
      
    \peq_2 \redx \eqs_2^1 \wedge \eqs_2^2
  \end{mathpar}
  and by inversion of the $\TirName{Seq}$ rule we have:
  \begin{mathpar}
    \htrip{\peq_1^1}{\cmd_1}{\peq_2^1}

    \htrip{\peq_1^2}{\cmd_2}{\peq_2^2}
  \end{mathpar}
  and by the induction hypothesis we have:
  \begin{mathpar}
    \htrip{\eqs_1^1}{\cmd_1}{\eqs_2^1}

    \htrip{\eqs_1^2}{\cmd_2}{\eqs_2^2}
  \end{mathpar}
  But by \TirName{Hyp} we have:
  $\htrip{\eqs_1^1 \wedge (\eqs_2^1 \impl \eqs_1^2)}{\cmd_1}{\eqs_2^1 \wedge \eqs_1^2}$
  and by sanity conditions \cnote{need to clarify these} we have
  $\vars(\eqs_2^1) \cap \avars(\prog_2) = \varnothing$ so by \TirName{Frame} we
  have
  $\htrip{\eqs_2^1 \wedge \eqs_1^2}{\cmd_2}{\eqs_2^1 \wedge \eqs_2^2}$.
  Thus by $\TirName{Seq}$ we have:
  $$\htrip{\eqs_1^1 \wedge (\eqs_2^1 \impl \eqs_1^2)}{\prog_1;\prog_2}{\eqs_2^1 \wedge \eqs_2^2}$$

  \textit{Case} $\cmd = f(e_1,\ldots,e_n)$. In this case by assumption and
  definition and inversion of $\TirName{App}$ and $\redx$ we have:
  \begin{mathpar}
    \codebase(f) = y_1,\ldots,y_n, \instr
    
    e_1 \redx \mv_1 \cdots e_n \redx \mv_n

    \instr[\mv_1/y_1]\cdots[\mv_n/y_n] \redx \prog

    \peq_1 = \peq^0_1[\mv_1/y_1]\cdots[\mv_n/y_n]

    \peq_2 = \peq^0_2[\mv_1/y_1]\cdots[\mv_n/y_n]
    
    \htrip{\peq^0_1}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq^0_2}
  \end{mathpar}
  Note that sanity conditions on pre- and post-condition annotations
  means there exists $\eqs_1$ and $\eqs_2$ where $\peq_1 \redx
  \eqs_1$ and $\peq_2 \redx \eqs_2$. Now, the judgement
  $\htrip{\peq^0_1}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq^0_2}$
  follows by one or two subcases. Where it follows by \TirName{Fn} the
  result is immediate by definition and the induction
  hypothesis. Otherwise it follows by \TirName{Hardpack} and we
  proceed as follows.

  By inversion of \TirName{Hardpack} we have
  $\htrip{\peq_1'}{f(y_1:\tau_1,\ldots,y_n:\tau_n)}{\peq_2'}$ by
  \TirName{Fn} where $\forall y_1:\tau_1,\ldots,y_n:\tau_n . \peq^0_1
  \models \peq_1'$. Then $\peq_1'[\mv_1/y_1]\cdots[\mv_n/y_n] \redx
  \eqs_1'$ and $\peq_2'[\mv_1/y_1]\cdots[\mv_n/y_n] \redx
  \eqs_2'$ by Lemma \ref{lemma-closure}. 
  By Lemma \ref{lemma-genentails} we have $\eqs_1
  \models \eqs_1'$, so by \TirName{Consequence} we have
  $\htrip{\eqs_1}{\prog}{\eqs_2'}$, and by \TirName{Hyp}
  we have:
  $$\htrip{\eqs_1 \wedge (\eqs_2' \impl \eqs_2)}{\prog}{\eqs_2' \wedge \eqs_2}$$

  Furthermore, also by inversion of \TirName{Hardpack} we have
  $\forall y_1:\tau_1,\ldots,y_n:\tau_n . \peq^0_1 \wedge 
  \peq_2' \models \peq^0_2$. 
  By Lemma \ref{lemma-genentails} we thus have $\eqs_1
  \wedge \eqs_2' \models \eqs_2$, which implies
  $\eqs_1 \models \eqs_2' \impl \eqs_2$.
  Thus by \TirName{Consequence} we have $\htrip{\eqs_1}{\prog}{\eqs_2}$.

  Finally, \textit{case} $\prog = \elet{y}{e}{\cmd}$ follows trivially
  by the induction hypothesis, which covers all cases to prove
  the result.
\end{proof}

\begin{theorem}
  If $\htrip{\eqs_1}{\ttt{main()}}{\eqs_2}$ as a consequence of
  \TirName{HardPack} and $\ttt{main}() \redx \prog$ then
  $\htrip{\eqs_1}{\prog}{\eqs_2}$.
\end{theorem}
