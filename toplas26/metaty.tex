\subsection{Share Type Checking with Annotations}

Share types rely on SMT entailments via the \TirName{ShareEntails} and
\TirName{PubEntails} rules, which are not syntax directed. Our goal
with the $\metaprot$ language is to automate share type checking. To
enable this we introduce \emph{share type annotations}. These
annotations allow programmer specification of properties that can be
verified as part of the Hoare triple analysis defined in Section
\ref{section-metahtrip} and that enable automated checking of types.

A fundamental component of the system is automated share type checking
of noninteractive computations.  We define an algorithmic, syntax
directed subset of noninteractive share typing as follows:
\begin{definition}
  Define $\Gamma \Vdash \stt : \sty$ iff $\Gamma,\true \Vdash \stt : \sty$ without the
  use of \TirName{ShareEntails} and \TirName{PubEntails}.
\end{definition}

\stafig

The syntax of type annotations $\sta$ is defined in Figure
\ref{fig-sta}, which we extend the language of commands $\cmd$ to
include. Type annotations are of the form $e_1 \kwas e_2$, which
defines an SMT equivalence, and $e : \sty$ which are verified using
the automated $\Vdash$ typing judgement-- the key idea here being that
explicit equivalences can stand in for implicit \TirName{ShareEntails}
and \TirName{PubEntails} judgements. In the semantics type annotations
are interpreted as no-ops, and their integration in Hoare triple
derivations requires annotated equivalences to be included in
preconditions.  In an implementation, Hoare triple verification can be
conducted independently prior to type checking.

\subsubsection{Annotation Type Checking}

Type checking judgements for typing annotations are defined as follows.
The \emph{definitions} element $\xdefs$ of judgements is an environment
of SMT equivalences induced either by the program or by annotation. 
\begin{definition}[$\metaprot$ Type Checking Judgements]
  \emph{Type checking judgements} are of the syntactic form
  $\shtrip{\Gamma, R, \xdefs}{\cmd}{\Gamma, R, \xdefs}$
  where $\xdefs : \phi \rightarrow \phi$ are called
  \emph{definitions}.
\end{definition}

\shtripstafig

All typing judgements are dependent on closed expressions $e$ which we
equate up to evaluation. Since the semantics of expressions is total,
we simply evaluate expressions in preconditions of derivation
rules. The derivation rules for annotations $\sta$ are given in Figure
\ref{fig-shtripsta}. First, we note that the \TirName{Coerce} rule
extends definitions to include the equivalence specified by the $e_1
\kwas e_2$ annotation form-- we assume the validity of the equivalence
is enforced by Hoare triple verification and so is not checked (again)
here.  These definitions extend or even overwrite variable definitions
established by the protocol itself (see the \TirName{Defn} rule in
Figure \ref{fig-shtripcmd} discussed below).

In the rules for share type annotations of the form $\notg{\stt} :
\sty$, 

\subsubsection{Functions and Application}

\begin{definition}[Abstract Share Type Environments]
  We write $\notg{\Gamma}$ to denote sets of bindings $\notg{\stt} : \sty$, and
  $\notg{R}$ to denote sets of expressions (that evaluate to random variables).
  We define evaluation of these, respectively, as follows:
  \begin{mathpar}
  \inferrule
      {\notg{\stt}_1 \redx \stt_1\ \cdots\ \notg{\stt}_n \redx \stt_n}
      {\setit{\notg{\stt}_1 : \sty_1, \ldots, \notg{\stt}_n : \sty_n} \redx
        \setit{\stt_1 : \sty_1, \ldots, \stt_n : \sty_n}}
      
  \inferrule
      {e_1 \redx \rx{w_1}{\cid_1}\ \cdots\ e_1 \redx \rx{w_n}{\cid_n}}
      {\setit{e_1,\ldots,e_n} \redx
        \setit{\rx{w_1}{\cid_1}, \ldots, \rx{w_n}{\cid_n}}}
  \end{mathpar}
\end{definition}

\begin{definition}[$\metaprot$ Function Types]
  Dependent function types are of the syntactic form
  $\Pi y_1,\ldots,y_n. \notg{\Gamma} \rightarrow (\notg{\Gamma}, \notg{R})$.
  where $y_1,\ldots,y_n$ range over $\stringty$ or $\cidty$ types.
\end{definition}

\shtripcmdfig

\begin{fpfig}[t]{GMW $\ttt{and}$ gate with share type annotations.}{fig-gmwsharetypes}
\begin{verbatimtab}
andgmw(z:string, x:string, y:string) {
  let table = andtablegmw(x,y,z) in
  m[z]@2 := OT4((m[x], m[y])@2, table.row4, table.row3, table.row2, table.row1)@1;
  m[z]@1 := r[z]@1;
  m[z]@2 as (RECON(x) * RECON(y)) + r[z]@1;
  [m[z]@1,m[z]@2] : shares
}
postcondition:  ( RECON(z) == RECON(x) * RECON(y))
\end{verbatimtab}
\end{fpfig}

\begin{definition} Define $\clean(\Gamma)$ as follows:
\begin{eqnarray*}
\clean(\varnothing) &=& \varnothing \\[-1.5mm]
\clean(\setit{[\mx{z}{\cid}, \mx{y}{\cid'}] : \sharety} \cup \Gamma) &=& \clean(\Gamma)\\[-1.5mm]
\clean(\setit{\pubx{\mx{z}{\cid}} : \pubty} \cup \Gamma) &=& \clean(\Gamma)\\[-1.5mm]
\clean(\setit{\stt : \sty} \cup \Gamma) &=& \setit{\stt : \sty} \cup \clean(\Gamma)
\end{eqnarray*}
\end{definition}

\begin{lemma}
  Assume $\cmd \redx \prog$ and $\htrip{\eqs_1 \wedge \toeq{\xdefs_1}}{\prog}{\eqs_2}$ and
  $\shtrip{\Gamma_1,R_1,\xdefs_1}{\cmd}{\Gamma_2,R_2,\xdefs_2}$ and   
  $\eqs_1 \wedge \toeq{\xdefs_1},\clean(\Gamma_1),R_1 : {OK}$.
  Then $\eqs_1 \wedge \toeq{\xdefs_1} \wedge \toeq{\prog} \vdash \clean(\Gamma_1),R_1 \stredx^* \clean(\Gamma_2),R_2$.
\end{lemma}

\begin{lemma}
  Assume $\htrip{\eqspre}{\ttt{main()}}{\eqs}$ and $\ttt{main} : \Gamma_1 \rightarrow (\Gamma_2,R)$
  and $\eqspre,\Gamma_1,R' : {OK}$ with $R' \cap R = \varnothing$. Given $\ttt{main()} \redx \prog$,
  then $\eqspre \wedge \toeq{\prog} \vdash \varnothing, \varnothing \stredx^* \clean(\Gamma_2),R$.
\end{lemma}

\begin{theorem}
  Assume $\htrip{\eqspre}{\ttt{main()}}{\eqs}$ and $\ttt{main} : \Gamma_1 \rightarrow (\Gamma_2,R)$
  and $\eqspre,\Gamma_1,R' : {OK}$ with $R' \cap R = \varnothing$. Given $\ttt{main()} \redx \prog$,
  with $\iov(\prog) = S \cup V \cup O$, then $\prog$ satisfies noninterference modulo output if
  $\realviews{\setit{\cid_1}}{\setit{\cid_2}} \cup O
  \subseteq \ov(\clean(\Gamma_2))$ for all $\cid_1$, $\cid_2$ with $\cid_1 \ne \cid_2$.
\end{theorem}

