\subsection{Share Type Checking with Annotations}

Share types rely on SMT entailments via the \TirName{ShareEntails} and \TirName{PubEntails} rules,
which are not syntax directed. Our goal with the $\metaprot$ language is to automate share type
checking. To enable this we introduce \emph{share type annotations} 

\stafig

\begin{definition}[Abstract Share Type Environments]
  We write $\notg{\Gamma}$ to denote sets of bindings $\notg{\stt} : \sty$, and
  $\notg{R}$ to denote sets of expressions (that evaluate to random variables).
  We define evaluation of these, respectively, as follows:
  \begin{mathpar}
  \inferrule
      {\notg{\stt}_1 \redx \stt_1 \cdots \notg{\stt}_n \redx \stt_n}
      {\setit{\notg{\stt}_1 : \sty_1, \ldots, \notg{\stt}_n : \sty_n} \redx
        \setit{\stt_1 : \sty_1, \ldots, \stt_n : \sty_n}}
      
  \inferrule
      {e_1 \redx \rx{w_1}{\cid_1} \cdots e_1 \redx \rx{w_n}{\cid_n}}
      {\setit{e_1,\ldots,e_n} \redx
        \setit{\rx{w_1}{\cid_1}, \ldots, \rx{w_n}{\cid_n}}}
  \end{mathpar}
\end{definition}

\shtripstafig

\begin{mathpar}
  \inferrule[Coerce]
      {e_1 \redx \phi_1 \\ e_2 \redx \phi_2}
      {\shtrip{\Gamma, R, \xdefs}{e_1 \kwas e_2}{\Gamma, R, \xdefs[\phi_1 \mapsto \phi_2]}}

  \inferrule[LocalShares]
      {e_1 \redx x_1 \\ e_2 \redx x_2  \\
        \Gamma \Vdash [\xdefs(x_1), \xdefs(x_2)] : \sharety}
      {\shtrip{\Gamma, R, \xdefs}{[e_1,e_2] : \sharety}
        {\Gamma \cup \setit{[x_1,x_2] : \sharety}, R, \xdefs}}

  \inferrule[GenShares]
      {e_1 \redx x_1 \\ e_2 \redx x_2  \\ \xdefs(x_1) = \phi - \rx{w}{\cid} \\ \xdefs(x_2) =  \rx{w}{\cid}}
      {\shtrip{\Gamma, R, \xdefs}{[e_1,e_2] : \sharety}
        {\Gamma \cup \setit{[x_1,x_2] : \sharety}, R \uplus \setit{\rx{w}{\cid}}, \xdefs}}

  \inferrule[LocalPublic]
      {e \redx \phi \\ \Gamma \Vdash \pubx{\xdefs(\phi)} : \pubty}
      {\shtrip{\Gamma, R, \xdefs}{\pubx{e} : \pubty}
        {\Gamma \cup \setit{\pubx{\phi} : \pubty}, R, \xdefs}}

  \inferrule[MaskedPublic]
      {e_1 \redx x_1 \\ e_2 \redx x_2  \\
        \Gamma \Vdash [x_1, x_2] : \sharety \\
        \xdefs(x_1 + x_2)  = \phi + \rx{w}{\oid}}
      {\shtrip{\Gamma, R, \xdefs}{\pubx{e_1+e_2} : \pubty}
        {\Gamma \cup \setit{\pubx{x_1 + x_2} : \pubty}, R \uplus \setit{\rx{w}{\oid}}, \xdefs}}

  \inferrule[Reveal]
      {e_1 \redx x_1 \\ e_2 \redx x_2  \\
        \Gamma \Vdash [x_1, x_2] : \sharety}
      {\shtrip{\Gamma, R, \xdefs}{\pubx{e_1 + e_2} : \outty}
        {\Gamma \cup \setit{\pubx{x_1 \fplus x_2} : \outty}, R, \xdefs}}

  \inferrule[Output]
      {e \redx \out{\cid} \\
       \xdefs(\out{\cid}) = x_1 + x_2 \\
       \Gamma \Vdash \pubx{x_1 + x_2} : \outty }
      {\shtrip{\Gamma, R, \xdefs}{\out{\cid} : \outty}
        {\Gamma \cup \setit{\pubx{\out{\cid}} : \outty}, R, \xdefs}}
\end{mathpar}



\begin{mathpar}
  \inferrule[Defn]
      {e_1 \redx x \\ e_2 \redx \elab{\be}{\cid}}
      {\shtrip{\Gamma, R, \xdefs}{e_1 := e_2}{\Gamma, R, \xdefs[x \mapsto \toeq{\elab{\be}{\cid}}]}}

  \inferrule[App]
      {f : \Pi y_1,\ldots,y_n. \notg{\Gamma_1} \rightarrow (\notg{\Gamma_2}, \notg{R'}) \\
        \notg{\Gamma_1}[e_1/y_1 \cdots e_n/y_n] \redx \Gamma_1 \\
        \notg{\Gamma_2}[e_1/y_1 \cdots e_n/y_n] \redx \Gamma_2 \\
        \notg{R'}[e_1/y_1 \cdots e_n/y_n] \redx R'        
      }
      {\shtrip{\Gamma \cup \Gamma_1, R, \xdefs}{f(e_1,\ldots,e_n)}{\Gamma \cup \Gamma_1 \cup \Gamma_2, R \uplus R', \xdefs}}

  \inferrule[Seq]    
      {\shtrip{\Gamma_1,R_1,\xdefs_1}{\cmd_1}{\Gamma_2,R_2,\xdefs_2} \\
       \shtrip{\Gamma_2,R_2,\xdefs_2}{\cmd_2}{\Gamma_3,R_3,\xdefs_3}}
      {\shtrip{\Gamma_1,R_1,\xdefs_1}{\cmd_1;\cmd_2}{\Gamma_3,R_3,\xdefs_3}}

  \inferrule[Let]
      {\shtrip{\Gamma_1,R_1,\xdefs_1}{\cmd[e/y]}{\Gamma_2,R_2,\xdefs_2}}
      {\shtrip{\Gamma_1,R_1,\xdefs_1}{\elet{y}{e}{\cmd}}{\Gamma_2,R_2,\xdefs_2}}
      
  \inferrule[Fn]
            {\codebase(f) = y_1 : \tau_1, \ldots, y_n : \tau_n, \cmd \\
              \mv_1,\ldots,\mv_n = \fresh(\tau_1,\ldots,\tau_n) \\
              \notg{\Gamma_1}[\mv_1/y_1 \cdots \mv_n/y_n] \redx \Gamma_1 \\
              \notg{\Gamma_2}[\mv_1/y_1 \cdots \mv_n/y_n] \redx \Gamma_2 \\
              \notg{R}[\mv_1/y_1 \cdots \mv_n/y_n] \redx R \\  
     \shtrip{\Gamma_1, \varnothing, \varnothing}{\cmd[\mv_1/y_1 \cdots \mv_n/y_n]}{\Gamma_2, R,\xdefs}}
    {f : \Pi y_1,\ldots,y_n. \notg{\Gamma_1} \rightarrow (\notg{\Gamma_2}, \notg{R})}
\end{mathpar}


\begin{fpfig}[t]{GMW $\ttt{and}$ gate with share type annotations.}{fig-gmwsharetypes}
\begin{verbatimtab}
andgmw(z:string, x:string, y:string) {
  let table = andtablegmw(x,y,z) in
  m[z]@2 := OT4((m[x], m[y])@2, table.row4, table.row3, table.row2, table.row1)@1;
  m[z]@1 := r[z]@1;
  m[z]@2 as (RECON(x) * RECON(y)) + r[z]@1;
  [m[z]@1,m[z]@2] : shares
}
postcondition:  ( RECON(z) == RECON(x) * RECON(y))
\end{verbatimtab}
\end{fpfig}

\begin{definition} Define $\clean(\Gamma)$ as follows:
\begin{eqnarray*}
\clean(\varnothing) &=& \varnothing \\[-1.5mm]
\clean(\setit{[\mx{z}{\cid}, \mx{y}{\cid'}] : \sharety} \cup \Gamma) &=& \clean(\Gamma)\\[-1.5mm]
\clean(\setit{\pubx{\mx{z}{\cid}} : \pubty} \cup \Gamma) &=& \clean(\Gamma)\\[-1.5mm]
\clean(\setit{\stt : \sty} \cup \Gamma) &=& \setit{\stt : \sty} \cup \clean(\Gamma)
\end{eqnarray*}
\end{definition}

\begin{lemma}
  Assume $\cmd \redx \prog$ and $\htrip{\eqs_1 \wedge \toeq{\xdefs_1}}{\prog}{\eqs_2}$ and
  $\shtrip{\Gamma_1,R_1,\xdefs_1}{\cmd}{\Gamma_2,R_2,\xdefs_2}$ and   
  $\eqs_1 \wedge \toeq{\xdefs_1},\clean(\Gamma_1),R_1 : {OK}$.
  Then $\eqs_1 \wedge \toeq{\xdefs_1} \wedge \toeq{\prog} \vdash \clean(\Gamma_1),R_1 \stredx^* \clean(\Gamma_2),R_2$.
\end{lemma}

\begin{lemma}
  Assume $\htrip{\eqspre}{\ttt{main()}}{\eqs}$ and $\ttt{main} : \Gamma_1 \rightarrow (\Gamma_2,R)$
  and $\eqspre,\Gamma_1,R' : {OK}$ with $R' \cap R = \varnothing$. Given $\ttt{main()} \redx \prog$,
  then $\eqspre \wedge \toeq{\prog} \vdash \varnothing, \varnothing \stredx^* \clean(\Gamma_2),R$.
\end{lemma}

\begin{theorem}
  Assume $\htrip{\eqspre}{\ttt{main()}}{\eqs}$ and $\ttt{main} : \Gamma_1 \rightarrow (\Gamma_2,R)$
  and $\eqspre,\Gamma_1,R' : {OK}$ with $R' \cap R = \varnothing$. Given $\ttt{main()} \redx \prog$,
  with $\iov(\prog) = S \cup V \cup O$, then $\prog$ satisfies noninterference modulo output if
  $\realviews{\setit{\cid_1}}{\setit{\cid_2}} \cup O
  \subseteq \ov(\clean(\Gamma_2))$ for all $\cid_1$, $\cid_2$ with $\cid_1 \ne \cid_2$.
\end{theorem}

