\section{Compositional Type Verification in $\metaprot$}

Practical MPC computations protocols are
typically composed of compositional units. Examples include GMW circuits
and Yao's Garbled Circuits (YGC), that are composed of so-called
garbled gates. Languages such as Fairplay \cite{269581} provide gates as
units of abstraction that are ``wired'' together by the programmer to
generate a complete circuit.

The $\fedprot$ language is low-level and does not include abstractions
for defining composable elements. So in this Section we introduce the
$\metaprot$ language that includes structured data and function
definitions for defining composable protocol elements at a higher
level of abstraction.  The $\metaprot$ language is a
\emph{metalanguage}, where $\fedprot$ protocols are the residuum of
computation. In addition to these declarative benefits of $\metaprot$,
component definitions support compositional verification of larger
protocols as we will discuss with examples in Section
\ref{section-examples}.

\metaprotsyntaxfig

\subsection{Syntax and Semantics}

The syntax of $\metaprot$ is defined in Figure
\ref{fig-metaprot}.  It includes a syntax of function
definitions and records, and values $\mv$ include client ids $\cid$, identifier
strings $w$, expressions $\be$ in field $\mathbb{F}_p$, and the unit value $()$.
Expression forms allow dynamic construction of field expressions and $\minifed$ commands.
The construction of a command has the side-effect of adding to the residual
$\minifed$ protocol. Formally, we consider a complete metaprogram to include both a
codebase and a ``main'' program that uses the codebase. 
\begin{definition}
A \emph{codebase} $\codebase$ is a list of function 
declarations. We write $ \codebase(f) = y_1,\ldots,y_n,\ e$
iff $f(y_1,\ldots,y_n) \{ e \} \in \codebase$.
A \emph{metaprogram}, aka \emph{metaprotocol}  is a pair of a 
codebase and expression $\codebase, e$. We may omit
$\codebase$ if it is clear from context.  
\end{definition}

We define a small-step evaluation aka reduction relation $\redx$ in
Figure \ref{fig-metaprot}.  We write $\redxs$ to denote the
reflexive, transitive closure of $\redx$. Reduction is defined on
\emph{configurations} which are pairs of the form $\config{\prog}{e}$,
where $\prog$ is the $\minifed$ program accumulated during evaluation.
In this definition we write $e[\mv/y]$ to denote the substitution of $\mv$
for free occurrences of $y$ in $e$. The rules are mostly standard,
except when a concrete $\minifed$ assignment is encountered it is added
to the end of $\prog$.

\metaprotexprsemanticsfig

The rules rely on a definition of \emph{evaluation contexts} $E$
allowing computation within a larger program context, where $E[e]$
denotes an expression with $e$ in the hole $[]$ of $E$. The syntax
of $E$ imposes a left-to-right order of evaluation of subexpressions
for all forms.

\metaprotinstrsemanticsfig

\subsection{Dependent Hoare Type Theory}

\subsubsection{$\minicat$ expression type algorithm}

\atjfig

\begin{lemma}
  If $\atj{\toeq{\phi}}{R}{\ty}$ then $\eqj{R}{\eqs}{\phi}{\ty}$ for any $\eqs$.
\end{lemma}


$$
\cmd ::= \cdots \mid \eqcast{\mx{e}{e}}{\notg{\phi}}
$$

$$
\begin{array}{rcl}
  \notg{\phi} &::=& e \mid \notg{\phi} \fplus \notg{\phi} \mid \notg{\phi} \fminus \notg{\phi} \mid \notg{\phi} \ftimes \notg{\phi} \\
  \notg{\eqs} &::=& \notg{\phi} \eop \notg{\phi} \mid \notg{\eqs} \wedge \notg{\eqs} \\
  \notg{t} &::=& e \mid \cty{e}{\notg{\ty}} \\
  \notg{\ty} & \in & 2^{\notg{t}}\\
  \notg{\Gamma} &::=& \varnothing \mid \notg\Gamma; e : \notg{\ty}\\
  \notg\Delta &::=& \varnothing \mid \notg\Delta; e : \ity{e}{\notg{V}}\\
  \notg{X} &\in& 2^{e}
\end{array}
$$

\begin{mathpar}
  \inferrule
      {\notg{\phi_1} \redx \phi_1 \\ \notg{\phi_2} \redx \phi_2}     
      {\notg{\phi_1} \ftimes \notg{\phi_2} \redx \phi_1 \ftimes \phi_2}

  \inferrule
      {\notg{\phi_1} \redx \phi_1 \\ \notg{\phi_2} \redx \phi_2}
      {\notg{\phi_1} \eop \notg{\phi_2} \redx \phi_1 \eop \phi_2}

  \inferrule
      {\notg{\eqs_1} \redx \eqs_1 \\ \notg{\eqs_2} \redx \eqs_2 }
      {\notg{\eqs_1} \wedge \notg{\eqs_2} \redx \eqs_1 \wedge \eqs_2}
\end{mathpar}

\begin{mathpar}
  \inferrule
      {e \redx x \\ \notg{\ty} \redx \ty}
      {\cty{e}{\notg{\ty}} \redx \cty{x}{\ty}}
      
  \inferrule
      {\notg{t_1} \redx t_1 \\ \cdots \\ \notg{t_n} \redx t_n}
      {\setit{\notg{t_1},\ldots,\notg{t_n}} \redx \setit{ t_1,\ldots,t_n }}

  \inferrule
      {\notg{\Gamma} \redx \Gamma \\ e \redx x \\ \notg{\ty} \redx \ty }
      {\notg{\Gamma}; e : \notg{\ty} \redx \Gamma; x : \ty }

  \inferrule
      {\notg{\Delta} \redx \Delta \\ e_1 \redx x  \\ e_2 \redx \cid \\ \notg{V} \redx V}
      {\notg{\Delta}; e_1 : \ity{e_2}{\notg{V}} \redx \Delta; x : \ity{\cid}{V} }

  \inferrule
      {\notg{\eqs_1} \redx \eqs_1 \\ \notg{\Gamma} \redx \\ \notg{R} \redx R
        \\ \notg{\Delta} \redx \Delta \\ \notg{\eqs_2} \redx \eqs_2}
      {\hty{\notg{\eqs_1}}{\notg{\Gamma}}{\notg{R}}{\notg{\Delta}}{\notg{\eqs_2}} \redx
        \hty{\eqs_1}{\Gamma}{R}{\Delta}{\eqs_2}}
\end{mathpar}



\begin{mathpar}
  \inferrule[Mesg]
            {e_1 \redx x \\ e_2 \redx \be \\ e_3 \redx \cid \\ \atj{\toeq{\elab{\be}{\cid}}}{R_2}{\ty} \\
              \itj{\cid}{\be}{V}}
            {\mtj{\xassign{e_1}{e_2}{e_3}}{\eqs}{(x:\ty)}{R_1;R_2}{(x : \ity{\cid}{V})}{\eqs \wedge x \eop \toeq{\elab{\be}{\cid}}}}

  \inferrule[Encode]
            {e_1 \redx w \\ e_2 \redx \cid \\ \notg{\phi} \redx \phi \\
              \eqs \models \toeq{\elab{\be}{\cid}} \eop \phi\\
              \atj{\phi}{R}{\ty}}
            {\mtj{\eqcast{\mx{e_1}{e_2}}{\notg{\phi}}}{\eqs}{(\mx{w}{\cid}:\ty)}{R}{\varnothing}{\eqs}}

  \inferrule[App]
            {\tsig(f) = \dht{y_1,\ldots,y_n}{\notg{\eqs_1}}{\notg{\Gamma}}{\notg{R}}{\notg{\Delta}}{\notg{\eqs_2}} \\
              e_1 \redx \mv_1\ \cdots\ e_n \redx \mv_n \\
              \subn = [\mv_1/y_1]\cdots[\mv_n/y_n] \\
              \subn(\hty{\notg{\eqs_1}}{\notg{\Gamma}}{\notg{R}}{\notg{\Delta}}{\notg{\eqs_2}}) \redx
                    \hty{\eqs_1}{\Gamma}{R}{\Delta}{\eqs_2} \\
              \eqs \models \eqs_1}
            {\mtj{f(e_1,\ldots,e_n)}{\eqs}{\Gamma}{R}{\Delta}{\eqs \wedge \eqs_2}}

  \inferrule[Seq]          
            {\mtj{\prog_1}{\eqs_1}{\Gamma_1}{R_1}{\Delta_1}{\eqs_2} \\
             \mtj{\prog_2}{\eqs_2}{\Gamma_2}{R_2}{\Delta_2}{\eqs_3}}
            {\mtj{\prog_1;\prog_2}{\eqs_1}{\Gamma_1;\Gamma_2}{R_1;R_2}{\Delta_1;\Delta_2}{\eqs_3}}
\end{mathpar}

\begin{mathpar}
  \inferrule[Sig]
            {\codebase(f) = y_1,\ldots,y_n, \instr \\
              \subn = [\mv_1/y_1]\cdots[\mv_n/y_n] \\
              \subn(\hty{\notg{\eqs_1}}{\notg{\Gamma}}{\notg{R}}{\notg{\Delta}}{\notg{\eqs_2}}) \redx
                    \hty{\eqs_1}{\Gamma}{R}{\Delta}{\eqs_2} \\
              \mtj{\subn(\instr)}{\eqs_1}{\Gamma}{R}{\Delta}{\eqs} \\
              \eqs \models \eqs_2}
            {f : \dht{y_1,\ldots,y_n}{\notg{\eqs_1}}{\notg{\Gamma}}{\notg{R}}{\notg{\Delta}}{\notg{\eqs_2}}}
\end{mathpar}

\begin{definition}
  $\tsig$ is \emph{verified} iff $f : \tsig(f)$ is valid for all $f \in \dom(\tsig)$.
\end{definition}

\begin{theorem}
  Given preprocessing predicate $\eqspre$, program $\instr$, and verified $\tsig$, if
  the judgement $\mtj{\instr}{\eqspre}{\Gamma}{R}{\Delta}{\eqs}$ is derivable then
  $\instr \redx \prog$ and:
  \begin{enumerate}
  \item $\cpj{R}{\eqs}{\eqspre \wedge \toeq{\prog}}{\Gamma}$ is valid.
  \item $\ipj{\eqs}{\prog}{\Delta}$ is valid.
  \end{enumerate}
\end{theorem}
