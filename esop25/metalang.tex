\section{Compositional Type Verification in $\metaprot$}

Practical MPC computations protocols are
typically composed of compositional units. Examples include GMW circuits
and Yao's Garbled Circuits (YGC), that are composed of so-called
garbled gates. Languages such as Fairplay \cite{269581} provide gates as
units of abstraction that are ``wired'' together by the programmer to
generate a complete circuit.

The $\fedprot$ language is low-level and does not include abstractions
for defining composable elements. So in this Section we introduce the
$\metaprot$ language that includes structured data and function
definitions for defining composable protocol elements at a higher
level of abstraction.  The $\metaprot$ language is a
\emph{metalanguage}, where $\fedprot$ protocols are the residuum of
computation. In addition to these declarative benefits of $\metaprot$,
component definitions support compositional verification of larger
protocols as we will discuss with examples in Section
\ref{section-examples}.

\metaprotsyntaxfig

\subsection{Syntax and Semantics}

The syntax of $\metaprot$ is defined in Figure
\ref{fig-metaprotsyntax}.  It includes a syntax of values $\mv$ that
include client ids $\cid$, identifier strings $w$, expressions $\be$
in field $\mathbb{F}_p$, record values, and $\minicat$ variables
$x$. $\metaprot$ expression forms allow dynamic construction of these
values. $\metaprot$ \emph{instruction} forms allow dynamic
construction of $\minicat$ protocols $\prog$, incorporating expression
evaluation. The syntax also supports definitions of functions that
compute values $\mv$ and, as a distinct form, functions that compute
protocols.  Formally, we consider a complete metaprogram to include
both a codebase and a ``main'' program that uses the codebase.
\begin{definition}
A \emph{codebase} $\codebase$ is a list of function 
declarations. We write $ \codebase(f) = y_1,\ldots,y_n,\ e$
if $f(y_1,\ldots,y_n) \{ e \} \in \codebase$, and we
write  $ \codebase(f) = y_1,\ldots,y_n,\ \instr$
if $f(y_1,\ldots,y_n) \{ \instr \} \in \codebase$.
%A \emph{metaprogram}, aka \emph{metaprotocol}  is a pair of a 
%codebase and expression $\codebase, e$. We may omit
%$\codebase$ if it is clear from context.  
\end{definition}

We define a big-step evaluation relation $\redx$ in Figures
\ref{fig-metaprotexprsemantics} and \ref{fig-metaprotinstrsemantics}
for expressions and instructions, respectively.  In this definition we
write $e[\mv/y]$ and $\instr[\mv/y]$ to denote the substitution of
$\mv$ for free occurrences of $y$ in $e$ or $\instr$ respectively. The
rules are mostly standard.

\metaprotexprsemanticsfig

\metaprotinstrsemanticsfig

\subsection{Dependent Hoare Type Theory}

\subsubsection{$\minicat$ expression type algorithm}

\atjfig

\begin{lemma}
  If $\atj{\toeq{\phi}}{R}{\ty}$ then $\eqj{R}{\eqs}{\phi}{\ty}$ for any $\eqs$.
\end{lemma}


$$
\cmd ::= \cdots \mid \eqcast{\mx{e}{e}}{\notg{\phi}}
$$

$$
\begin{array}{rcl}
  \notg{\phi} &::=& e \mid \notg{\phi} \fplus \notg{\phi} \mid \notg{\phi} \fminus \notg{\phi} \mid \notg{\phi} \ftimes \notg{\phi} \\
  \notg{\eqs} &::=& \notg{\phi} \eop \notg{\phi} \mid \notg{\eqs} \wedge \notg{\eqs} \\
  \notg{t} &::=& e \mid \cty{e}{\notg{\ty}} \\
  \notg{\ty} & \in & 2^{\notg{t}}\\
  \notg{\Gamma} &::=& \varnothing \mid \notg\Gamma; e : \notg{\ty}\\
  \notg\Delta &::=& \varnothing \mid \notg\Delta; e : \ity{e}{\notg{V}}\\
  \notg{X} &\in& 2^{e}
\end{array}
$$

\begin{mathpar}
  \inferrule
      {\notg{\phi_1} \redx \phi_1 \\ \notg{\phi_2} \redx \phi_2}     
      {\notg{\phi_1} \ftimes \notg{\phi_2} \redx \phi_1 \ftimes \phi_2}

  \inferrule
      {\notg{\phi_1} \redx \phi_1 \\ \notg{\phi_2} \redx \phi_2}
      {\notg{\phi_1} \eop \notg{\phi_2} \redx \phi_1 \eop \phi_2}

  \inferrule
      {\notg{\eqs_1} \redx \eqs_1 \\ \notg{\eqs_2} \redx \eqs_2 }
      {\notg{\eqs_1} \wedge \notg{\eqs_2} \redx \eqs_1 \wedge \eqs_2}
\end{mathpar}

\begin{mathpar}
  \inferrule
      {e \redx x \\ \notg{\ty} \redx \ty}
      {\cty{e}{\notg{\ty}} \redx \cty{x}{\ty}}
      
  \inferrule
      {\notg{t_1} \redx t_1 \\ \cdots \\ \notg{t_n} \redx t_n}
      {\setit{\notg{t_1},\ldots,\notg{t_n}} \redx \setit{ t_1,\ldots,t_n }}

  \inferrule
      {\notg{\Gamma} \redx \Gamma \\ e \redx x \\ \notg{\ty} \redx \ty }
      {\notg{\Gamma}; e : \notg{\ty} \redx \Gamma; x : \ty }

  \inferrule
      {\notg{\Delta} \redx \Delta \\ e_1 \redx x  \\ e_2 \redx \cid \\ \notg{V} \redx V}
      {\notg{\Delta}; e_1 : \ity{e_2}{\notg{V}} \redx \Delta; x : \ity{\cid}{V} }

  \inferrule
      {\notg{\eqs_1} \redx \eqs_1 \\ \notg{\Gamma} \redx \\ \notg{R} \redx R
        \\ \notg{\Delta} \redx \Delta \\ \notg{\eqs_2} \redx \eqs_2}
      {\hty{\notg{\eqs_1}}{\notg{\Gamma}}{\notg{R}}{\notg{\Delta}}{\notg{\eqs_2}} \redx
        \hty{\eqs_1}{\Gamma}{R}{\Delta}{\eqs_2}}
\end{mathpar}



\begin{mathpar}
  \inferrule[Mesg]
            {e_1 \redx x \\ e_2 \redx \be \\ e_3 \redx \cid \\ \atj{\toeq{\elab{\be}{\cid}}}{R_2}{\ty} \\
              \itj{\cid}{\be}{V}}
            {\mtj{\xassign{e_1}{e_2}{e_3}}{\eqs}{(x:\ty)}{R_1;R_2}{(x : \ity{\cid}{V})}{\eqs \wedge x \eop \toeq{\elab{\be}{\cid}}}}

  \inferrule[Encode]
            {e_1 \redx w \\ e_2 \redx \cid \\ \notg{\phi} \redx \phi \\
              \eqs \models \toeq{\elab{\be}{\cid}} \eop \phi\\
              \atj{\phi}{R}{\ty}}
            {\mtj{\eqcast{\mx{e_1}{e_2}}{\notg{\phi}}}{\eqs}{(\mx{w}{\cid}:\ty)}{R}{\varnothing}{\eqs}}

  \inferrule[App]
            {\tsig(f) = \dht{y_1,\ldots,y_n}{\notg{\eqs_1}}{\notg{\Gamma}}{\notg{R}}{\notg{\Delta}}{\notg{\eqs_2}} \\
              e_1 \redx \mv_1\ \cdots\ e_n \redx \mv_n \\
              \subn = [\mv_1/y_1]\cdots[\mv_n/y_n] \\
              \subn(\hty{\notg{\eqs_1}}{\notg{\Gamma}}{\notg{R}}{\notg{\Delta}}{\notg{\eqs_2}}) \redx
                    \hty{\eqs_1}{\Gamma}{R}{\Delta}{\eqs_2} \\
              \eqs \models \eqs_1}
            {\mtj{f(e_1,\ldots,e_n)}{\eqs}{\Gamma}{R}{\Delta}{\eqs \wedge \eqs_2}}

  \inferrule[Seq]          
            {\mtj{\prog_1}{\eqs_1}{\Gamma_1}{R_1}{\Delta_1}{\eqs_2} \\
             \mtj{\prog_2}{\eqs_2}{\Gamma_2}{R_2}{\Delta_2}{\eqs_3}}
            {\mtj{\prog_1;\prog_2}{\eqs_1}{\Gamma_1;\Gamma_2}{R_1;R_2}{\Delta_1;\Delta_2}{\eqs_3}}
\end{mathpar}

\begin{mathpar}
  \inferrule[Sig]
            {\codebase(f) = y_1,\ldots,y_n, \instr \\
              \subn = [\mv_1/y_1]\cdots[\mv_n/y_n] \\
              \subn(\hty{\notg{\eqs_1}}{\notg{\Gamma}}{\notg{R}}{\notg{\Delta}}{\notg{\eqs_2}}) \redx
                    \hty{\eqs_1}{\Gamma}{R}{\Delta}{\eqs_2} \\
              \mtj{\subn(\instr)}{\eqs_1}{\Gamma}{R}{\Delta}{\eqs} \\
              \eqs \models \eqs_2}
            {f : \dht{y_1,\ldots,y_n}{\notg{\eqs_1}}{\notg{\Gamma}}{\notg{R}}{\notg{\Delta}}{\notg{\eqs_2}}}
\end{mathpar}

\begin{definition}
  $\tsig$ is \emph{verified} iff $f : \tsig(f)$ is valid for all $f \in \dom(\tsig)$.
\end{definition}

\begin{theorem}
  Given preprocessing predicate $\eqspre$, program $\instr$, and verified $\tsig$, if
  the judgement $\mtj{\instr}{\eqspre}{\Gamma}{R}{\Delta}{\eqs}$ is derivable then
  $\instr \redx \prog$ and:
  \begin{enumerate}
  \item $\cpj{R}{\eqs}{\eqspre \wedge \toeq{\prog}}{\Gamma}$ is valid.
  \item $\ipj{\eqs}{\prog}{\Delta}$ is valid.
  \end{enumerate}
\end{theorem}
