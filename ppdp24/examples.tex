\section{Examples}
\label{section-examples}

\subsection{2-Party GMW}
\label{section-metalang-gmw}

\input{gmw}

The GMW protocol uses secret sharing to represent data flowing through
circuits. In the 2-party case, clients 1 and 2 each share their input
secrets, and use those shares to represent inputs to gates. Outputs
are also represented as shares. We refer to the pair of shares
representing any particular value as a \emph{wire value}, and
we represent them via records of the form
$
\ttt{\{c1 = } v_1\ttt{;c2 = } v_2\ttt{\}} 
$
where $v_1$ and $v_2$ are client 1 and 2's shares respectively.

For full details of the GMW protocol the reader is referred to
\cite{evans2018pragmatic}. Our implementation libary is shown in
Figure \ref{fig-gmw}, with type signatures for the library functions
also shown. We present the And gate since it is
an interesting component. The Figure includes the
following top-level functions:
\begin{itemize}
\item \ttt{encodegmw}: This function encodes client 1's and client 2's
  secret bits called $\ttt{s[1,"s1"]}$ and $\ttt{s[1,"s2"]}$ into two
  distinct wire values (pairs of shares).
\item \ttt{andgmw}: This function defines the gate $\ttt{"g"}$, the
  identifier $\ttt{"g"}$ being used to distinguish randomness used
  within.  In our version client 1 builds the output table (using
  \ttt{andtablegmw})and transfers the correct output share to client 2
  using 1-out-of-4 OT ($\ttt{OT4}$), definable using $\ttt{OT}$, as
  per standard GMW protocol.
\item \ttt{decode}: This function decodes and publishes a wire value
  by $\ttt{xor}$ing the shares. Note that this requires both client 1
  and 2 to publicize their shares.
\end{itemize}
\begin{example}
  \label{example-gmw-andcircuit}
The following program uses our GMW library to define
a circuit with a single And gate and input secrets $\ttt{s1}$ and
$\ttt{s2}$ from client's 1 and 2 respectively:
\begin{verbatimtab}
decode(andgmw("gate0",encodegmw("s1"),encodegmw("s2")))
\end{verbatimtab}
\end{example}

\begin{definition}
  For all $\alpha \in \{ \mesg{w}, \flip{w} \}$ define:
  $$\pmf(\macgv{\alpha} = v) \defeq \sum_{\sigma) \in A} \pmf(\sigma')$$
  and define:
  $$\condd{\pmf}{X}{\macgv{\alpha} = v}(\sigma) \defeq  \sum_{\sigma' \in A} \condd{\pmf}{X}{\sigma'}(\sigma)$$
  where $A = \{ \store \in \mems(\{ \elab{\alpha}{1},\elab{\alpha}{2} \} ) \mid
      \cod{\store(\elab{\alpha}{1}) + \store(\elab{\alpha}{2})} = v \}$.
\end{definition}

\begin{lemma}
  If $\condp{\pmf}{X_1}{\detx{X_2}}$ and
  $\condp{\pmf}{X_2}{\detx{X_3}}$ then $\condp{\pmf}{X_1}{\detx{X_3}}$.
\end{lemma}

\begin{lemma}
  If $\condsep{\pmf}{X_1}{X_2}{X_3}$ and
  $\condp{\pmf}{X_2}{\detx{X_4}}$ then $\condsep{\pmf}{X_1}{X_4}{X_3}$.
\end{lemma}

\begin{lemma}
  Given:
  $$
  \begin{array}{c}
  (\varnothing,\andgmw(z,\mesg{x},\mesg{y}) \redxs %\\
  (\prog,\mesg{z})
  \end{array}
  $$
  Then:
  $$
  \condsep
      {\progtt(\prog)}
      {\{ \macgv{\mesg{x}},\macgv{\mesg{y}} \}}
      {\{ \macgv{\mesg{z}} \}}
      {\{ \elab{\mesg{x}}{2},\elab{\mesg{y}}{2},\elab{\mesg{z}}{1},\elab{\mesg{z}}{2} \}}
  $$
  $$
  \conddetx{\progtt(\prog)}{\{ \macgv{\mesg{x}},\macgv{\mesg{y}} \}}{\{ \macgv{\mesg{z}} \}}    
  $$
\end{lemma}

\begin{lemma}
  $$ (\varnothing,e) \redxs (\prog,\decodegmw(E[\mesg{z}])) $$
  $$\iov(\prog) = S \cup M$$
  $$\condsep{\progtt(\prog)}{S}{\{\macgv{\mesg{z}}\}}{(M_C \cup \{ \elab{\mesg{z}}{1}, \elab{\mesg{z}}{2} \})}$$
  $$\conddetx{\progtt(\prog)}{S}{\{\macgv{\mesg{z}}\}}$$
\end{lemma}

\begin{mathpar}
  \condsep{\progtt(\prog_1)}{S^1}{\{ \macgv{\mesg{x}} \}}{(M^1_C \cup \{ \elab{\mesg{x}}{1}, \elab{\mesg{x}}{2} \})}
  
  \condsep{\progtt(\prog_2)}{S^2}{\{ \macgv{\mesg{y}} \}}{(M^2_C \cup \{ \elab{\mesg{y}}{1}, \elab{\mesg{y}}{2} \})}
  
  \condsep{\progtt(\prog_3)}{S^1 \cup S^2}{\{ \macgv{\mesg{z}} \}}{(M^1_C \cup M^2_C \cup \{ \elab{\mesg{x}}{2}, \elab{\mesg{y}}{2}, \elab{\mesg{z}}{1}, \elab{\mesg{z}}{2} \})}
\end{mathpar}

\subsection{2-Party BDOZ}

\input{bdoz}


\begin{definition}
  Given $\prog$ with $\iov(\prog) = S \cup V \cup O$,
  let $X_H \subseteq \{ x \mid x \in (\houtputs \cup O_H) \wedge x \in \dom(\store) \}$.
  Then the \emph{adversarial inputs to $X_H$} is the least set
  $X_C \subseteq \cinputs$ such that $\progtt(\prog) \not\vdash X_C * X_H$.
\end{definition}
\begin{definition}[Cheating Detection]
  \emph{Cheating is detected} in $\prog$ with $\iov(\prog) = S \cup V \cup O$ iff
  for all  $\store \in \aruns(\prog)$,
  letting $X_H = \{ x \mid x \in (\houtputs \cup O_H) \wedge x \in \dom(\store) \}$,
  and letting $X_C$ be the adversarial inputs to $X_H$,
  there exists $\sigma'\in \runs(\prog)$
  with $\store_{X_C} = \store'_{X_C}$.  
\end{definition}

\begin{lemma}
  If cheating is detected in $\prog$, then $\prog$ has integrity.
\end{lemma}
