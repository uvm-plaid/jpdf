\section{Examples and Proof Methods}
\label{section-examples}

\subsection{2-Party GMW}
\label{section-metalang-gmw}

\input{gmw}

The GMW protocol is a garbled binary circuit protocol. In this section
we will assume the 2-party version, though it generalizes to $n$
parties\cite{XXX}. GMW uses a common technique in MPC, which is to
represent values $v$ as distributed shares $v_1$ and $v_2$ with
$v = v_1 \fplus v_2$. This trick maintains secrecy of $v$
from both parties, and in GMW it is used to maintain the intermediate
values of internal gate outputs in circuits. In related literature
the notation $\macgv{x}$ is used to represent the ``true''
value of $x$ and $[x]$ is often used to represent the share of
given party.

To capture this convention, which is used in many other protocols, we
introduce a new naming convention for ``global view'' elements
$\macgv{\mesg{w}}$, which denote the summed value of
$\elab{\mesg{w}}{1}$ and $\elab{\mesg{w}}{2}$ in a protocol
run. This concept integrates program distributions in the
usual manner, as the probability of the outcome of summation
of two variables in the distribution.
\begin{definition}
  For all $\mesg{w}$ define:
  $$\pmf(\macgv{\mesg{w}} = v) \defeq \sum_{\sigma \in A} \pmf(\sigma)$$
  and define:
  $$\condd{\pmf}{X}{\macgv{\mesg{w}} = v}(\sigma) \defeq  \sum_{\sigma' \in A} \condd{\pmf}{X}{\sigma'}(\sigma)$$
  where $A = \{ \store \in \mems(\{ \elab{\alpha}{1},\elab{\alpha}{2} \} ) \mid
      \cod{\store(\elab{\mesg{w}}{1}) + \store(\elab{\mesg{w}}{2})} = v \}$.
\end{definition}

For full details of the GMW protocol the reader is referred to
\cite{evans2018pragmatic}. Our implementation libary is shown in
Figure \ref{fig-gmw}, and includes encoding functions, where
input secrets are split into shares, $\eand$ and $\exor$ gate
functions, and a decoding function. Note that $\exor$ requires
no interaction between parties, while $\eand$ necessitates and
1-of-4 oblivious transfer. The gate computation is
done entirely in secrect, and the decoding function
is where the declassification occurs-- both parties reveal
their shares of the final gate output $\macgv{z}$.

For example, the following program uses our GMW library to define
a circuit with a single \eand gate and input secrets $\ttt{s1}$ and
$\ttt{s2}$ from client's 1 and 2 respectively:
\begin{verbatimtab}
         let s1 = encodegmw("s1") in
         let s2 = encodegmw("s2") in
         decodegmw(andgmw("z",s1,s2))
\end{verbatimtab}
By convention we will assume that all gates are assigned unique output
identifiers $\ttt{"z"}$, and that all programs are in the form
of a sequence of let-bindings followed by a call to $\decodegmw$
wrapping a circuit.

\paragraph{Oblivious Transfer} \cnote{Here is where we
  wave hands about OT.}

\subsubsection{Correctness Proof with Verification Tactics}

\begin{definition}[Conditional Separation]
  We write $\condsep{\pmf}{X_1}{X_2}{X_3}$ iff for all
  $\store' \in \mems(X_1)$ and $\store \in \mems(X_2 \cup X_3)$
  and letting $X = X_1 \cup X_2 \cup X_3$ we have:
  $$\condd{\pmf}{X}{\store'}(\store) =
  \condd{\pmf}{X}{\store'}(\store_{X_2}) *
  \condd{\pmf}{X}{\store'}(\store_{X_3})$$
\end{definition}

\begin{definition}[Conditional Determinism]  
  We write $\conddetx{\pmf}{X_1}{X_2}$ iff for all
  $\store' \in \mems(X_1)$ there exists 
  $\store \in \mems(X_2)$ such that
  $\condd{\pmf}{X_1 \cup X_2}{\store'}(\store) = 1$.
\end{definition}


\begin{lemma}[GMW Invariant]
  \label{lemma-gmwinvariant}
  Given:
  $$ (\varnothing,e) \redxs (\prog,\decodegmw(E[\mesg{z}])) $$
  Then both of the following conditions hold for all $H$ and $C$ where $\iov(\prog) = S \cup M$:
  \begin{enumerate}
    \item $\condsep{\progtt(\prog)}{S}{\{\macgv{\mesg{z}}\}}{(M_C \cup \{ \elab{\mesg{z}}{1}, \elab{\mesg{z}}{2} \})}$
    \item $\conddetx{\progtt(\prog)}{S}{\{\macgv{\mesg{z}}\}}$
  \end{enumerate}
\end{lemma}

\begin{lemma}[And Gate Tactic]
  \label{lemma-gmwtactic}
  %Define:
  %$$
  %\begin{array}{c}
  %  \prog_{i} \defeq \\
  %  \eassign{\mesg{x}}{1}{\flip{x}}{1}; \eassign{\mesg{x}}{2}{\flip{x}}{2}; \\
  %  \eassign{\mesg{y}}{1}{\flip{y}}{1}; \eassign{\mesg{y}}{2}{\flip{y}}{2} 
  %\end{array}
  %$$
  Given:
  $$
  \begin{array}{c}
  (\varnothing,\andgmw(z,\mesg{x},\mesg{y}) \redxs %\\
  (\prog,\mesg{z})
  \end{array}
  $$
  Then both of the following conditions hold for both $\cid \in \{ 1,2 \}$ where $\iov(\prog) = M$:
  \begin{enumerate}
   \item $\condsep
      {\progtt(\prog)}
      {\{ \macgv{\mesg{x}},\macgv{\mesg{y}} \}}
      {\{ \macgv{\mesg{z}} \}}
      {M_{\{\cid\}} \cup \{ \elab{\mesg{z}}{1},\elab{\mesg{z}}{2} \}}$
    \item
      $\conddetx{\progtt(\prog)}{\{ \macgv{\mesg{x}},\macgv{\mesg{y}} \}}{\{ \macgv{\mesg{z}} \}}$
  \end{enumerate}
\end{lemma}

\begin{proof}
Verified automatically using techniques described in Section \ref{section-bruteforce}.  
\end{proof}

\begin{lemma}
  \label{lemma-conditioning}
  Each of the following hold:
  \begin{enumerate}
    \item Given $\condp{\pmf}{X_1}{\detx{X_2}}$ and
      $\condp{\pmf}{X_2}{\detx{X_3}}$, then $\condp{\pmf}{X_1}{\detx{X_3}}$.
    \item Given $\condp{\pmf}{X_1}{\detx{X_2}}$ and
      $\condsep{\pmf}{X_2}{X_3}{X_4}$, then $\condsep{\pmf}{X_1}{X_3}{X_4}$.
    \item Given $\condsep{\pmf}{X_1}{X_2}{X_3}$ and $\condp{\pmf}{X_1}{\detx{X_2}}$
      and $\condp{\pmf}{X_2}{\detx{X_4}}$, then $\condsep{\pmf}{X_1}{X_4}{X_3}$.
  \end{enumerate}
\end{lemma}

\begin{proof}[Proof of Lemma \ref{lemma-gmwinvariant}]
\begin{mathpar}
  \condsep{\progtt(\prog_1)}{S^1}{\{ \macgv{\mesg{x}} \}}{(M^1_C \cup \{ \elab{\mesg{x}}{1}, \elab{\mesg{x}}{2} \})}
  
  \condsep{\progtt(\prog_2)}{S^2}{\{ \macgv{\mesg{y}} \}}{(M^2_C \cup \{ \elab{\mesg{y}}{1}, \elab{\mesg{y}}{2} \})}
  
  \condsep{\progtt(\prog_3)}{S^1 \cup S^2}{\{ \macgv{\mesg{z}} \}}{(M^1_C \cup M^2_C \cup \{ \elab{\mesg{x}}{2}, \elab{\mesg{y}}{2}, \elab{\mesg{z}}{1}, \elab{\mesg{z}}{2} \})}
\end{mathpar}
\end{proof}

\subsection{2-Party BDOZ}

\input{bdoz}


\begin{definition}
  Given $\prog$ with $\iov(\prog) = S \cup V \cup O$,
  let $X_H \subseteq \{ x \mid x \in (\houtputs \cup O_H) \wedge x \in \dom(\store) \}$.
  Then the \emph{adversarial inputs to $X_H$} is the least set
  $X_C \subseteq \cinputs$ such that $\progtt(\prog) \not\vdash X_C * X_H$.
\end{definition}
\begin{definition}[Cheating Detection]
  \emph{Cheating is detected} in $\prog$ with $\iov(\prog) = S \cup V \cup O$ iff
  for all  $\store \in \aruns(\prog)$,
  letting $X_H = \{ x \mid x \in (\houtputs \cup O_H) \wedge x \in \dom(\store) \}$,
  and letting $X_C$ be the adversarial inputs to $X_H$,
  there exists $\sigma'\in \runs(\prog)$
  with $\store_{X_C} = \store'_{X_C}$.  
\end{definition}

\begin{lemma}
  If cheating is detected in $\prog$, then $\prog$ has integrity.
\end{lemma}
