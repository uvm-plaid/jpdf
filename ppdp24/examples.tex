\section{Examples}
\label{section-examples}

\subsection{2-Party GMW}
\label{section-metalang-gmw}

\input{gmw}

The GMW protocol is a garbled binary circuit protocol. In this section
we will assume the 2-party version, though it generalizes to $n$
parties\cite{XXX}. GMW uses a common technique in MPC, which is to
represent values $v$ as distributed shares $v_1$ and $v_2$ with
$v = v_1 \fplus v_2$. This trick maintains secrecy of $v$
from both parties, and in GMW it is used to maintain the intermediate
values of internal gate outputs in circuits. In related literature
the notation $\macgv{x}$ is used to represent the ``true''
value of $x$ and $[x]$ is often used to represent the share of
given party.

To capture this convention, which is used in many other protocols, we
introduce a new naming convention for ``global view'' elements
$\macgv{\mesg{w}}$, which denote the summed value of
$\elab{\mesg{w}}{1}$ and $\elab{\mesg{w}}{2}$ in a protocol
run. This concept integrates program distributions in the
usual manner, as the probability of the outcome of summation
of two variables in the distribution.
\begin{definition}
  For all $\mesg{w}$ define:
  $$\pmf(\macgv{\mesg{w}} = v) \defeq \sum_{\sigma \in A} \pmf(\sigma)$$
  and define:
  $$\condd{\pmf}{X}{\macgv{\mesg{w}} = v}(\sigma) \defeq  \sum_{\sigma' \in A} \condd{\pmf}{X}{\sigma'}(\sigma)$$
  where $A = \{ \store \in \mems(\{ \elab{\alpha}{1},\elab{\alpha}{2} \} ) \mid
      \cod{\store(\elab{\mesg{w}}{1}) + \store(\elab{\mesg{w}}{2})} = v \}$.
\end{definition}

For full details of the GMW protocol the reader is referred to
\cite{evans2018pragmatic}. Our implementation libary is shown in
Figure \ref{fig-gmw}, and includes encoding functions, where
input secrets are split into shares, $\eand$ and $\exor$ gate
functions, and a decoding function. Note that $\exor$ requires
no interaction between parties, while $\eand$ necessitates and
1-of-4 oblivious transfer. The gate computation is
done entirely in secrect, and the decoding function
is where the declassification occurs-- both parties reveal
their shares of the final gate output $\macgv{z}$.

For example, the following program uses our GMW library to define
a circuit with a single \eand gate and input secrets $\ttt{s1}$ and
$\ttt{s2}$ from client's 1 and 2 respectively:
\begin{verbatimtab}
         let s1 = encodegmw("s1") in
         let s2 = encodegmw("s2") in
         decodegmw(andgmw("z",s1,s2))
\end{verbatimtab}
By convention we will assume that all gates are assigned unique output
identifiers $\ttt{"z"}$, and that all programs are in the form
of a sequence of let-bindings followed by a call to $\decodegmw$
wrapping a circuit.

\paragraph{Oblivious Transfer} \cnote{Here is where we
  wave hands about OT.}

\subsubsection{Correctness Proof with Verification Tactics}


\begin{lemma}
  Define:
  $$
  \begin{array}{c}
    \prog_{i} \defeq \\
    \eassign{\mesg{x}}{1}{\flip{x}}{1}; \eassign{\mesg{x}}{2}{\flip{x}}{2}; \\
    \eassign{\mesg{y}}{1}{\flip{y}}{1}; \eassign{\mesg{y}}{2}{\flip{y}}{2} 
  \end{array}
  $$
  Given:
  $$
  \begin{array}{c}
  (\prog_i,\andgmw(z,\mesg{x},\mesg{y}) \redxs %\\
  (\prog,\mesg{z})
  \end{array}
  $$
  Then both of the following conditions hold, where $\iov(\prog) = M$:
  $$
  \condsep
      {\progtt(\prog)}
      {\{ \macgv{\mesg{x}},\macgv{\mesg{y}} \}}
      {\{ \macgv{\mesg{z}} \}}
      {M_{\{2\}} \cup \{ \elab{\mesg{z}}{1},\elab{\mesg{z}}{2} \}}
  $$
  $$
  \conddetx{\progtt(\prog)}{\{ \macgv{\mesg{x}},\macgv{\mesg{y}} \}}{\{ \macgv{\mesg{z}} \}}    
  $$
\end{lemma}



\begin{lemma}
  If $\condp{\pmf}{X_1}{\detx{X_2}}$ and
  $\condp{\pmf}{X_2}{\detx{X_3}}$ then $\condp{\pmf}{X_1}{\detx{X_3}}$.
\end{lemma}

\begin{lemma}
  Given:
  \begin{mathpar}
    \condsep{\pmf}{X_1}{X_2}{X_3}
    
    \condp{\pmf}{X_1}{\detx{X_2}}

    \condp{\pmf}{X_2}{\detx{X_4}}
  \end{mathpar}
    Then $\condsep{\pmf}{X_1}{X_4}{X_3}$.
\end{lemma}

\begin{lemma}
  $$ (\varnothing,e) \redxs (\prog,\decodegmw(E[\mesg{z}])) $$
  $$\iov(\prog) = S \cup M$$
  $$\condsep{\progtt(\prog)}{S}{\{\macgv{\mesg{z}}\}}{(M_C \cup \{ \elab{\mesg{z}}{1}, \elab{\mesg{z}}{2} \})}$$
  $$\conddetx{\progtt(\prog)}{S}{\{\macgv{\mesg{z}}\}}$$
\end{lemma}

\begin{mathpar}
  \condsep{\progtt(\prog_1)}{S^1}{\{ \macgv{\mesg{x}} \}}{(M^1_C \cup \{ \elab{\mesg{x}}{1}, \elab{\mesg{x}}{2} \})}
  
  \condsep{\progtt(\prog_2)}{S^2}{\{ \macgv{\mesg{y}} \}}{(M^2_C \cup \{ \elab{\mesg{y}}{1}, \elab{\mesg{y}}{2} \})}
  
  \condsep{\progtt(\prog_3)}{S^1 \cup S^2}{\{ \macgv{\mesg{z}} \}}{(M^1_C \cup M^2_C \cup \{ \elab{\mesg{x}}{2}, \elab{\mesg{y}}{2}, \elab{\mesg{z}}{1}, \elab{\mesg{z}}{2} \})}
\end{mathpar}

\subsection{2-Party BDOZ}

\input{bdoz}


\begin{definition}
  Given $\prog$ with $\iov(\prog) = S \cup V \cup O$,
  let $X_H \subseteq \{ x \mid x \in (\houtputs \cup O_H) \wedge x \in \dom(\store) \}$.
  Then the \emph{adversarial inputs to $X_H$} is the least set
  $X_C \subseteq \cinputs$ such that $\progtt(\prog) \not\vdash X_C * X_H$.
\end{definition}
\begin{definition}[Cheating Detection]
  \emph{Cheating is detected} in $\prog$ with $\iov(\prog) = S \cup V \cup O$ iff
  for all  $\store \in \aruns(\prog)$,
  letting $X_H = \{ x \mid x \in (\houtputs \cup O_H) \wedge x \in \dom(\store) \}$,
  and letting $X_C$ be the adversarial inputs to $X_H$,
  there exists $\sigma'\in \runs(\prog)$
  with $\store_{X_C} = \store'_{X_C}$.  
\end{definition}

\begin{lemma}
  If cheating is detected in $\prog$, then $\prog$ has integrity.
\end{lemma}
