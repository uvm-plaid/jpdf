% Inbuilt themes in beamer
\documentclass{beamer}

% Theme choice:
\usetheme{CambridgeUS}
\usecolortheme{default}

\input{slide-macros}

% Title page details: 
\title{Language-Based Security for Low-Level MPC}

\author{Christian Skalka and Joe Near}

\date{September 10, 2024}

\logo{
\includegraphics[width=3cm]{UVM_Logo_Primary_Horiz_G.png}
}

\beamertemplatenavigationsymbolsempty

\begin{document}

% Title page frame
\begin{frame}
    \titlepage 
\end{frame}

% Remove logo from the next slides
\logo{}


% % Outline frame
% \begin{frame}{Outline}
%     \tableofcontents
% \end{frame}

\section{What's an MPC Protocol}

\begin{frame}{The Ideal Functionality}
  A \emph{protocol} $\prog$ implements an \emph{ideal functionality} $\idealf$,
  defined in terms of operations in a prime field $\mathbb{F}_p$.
  \begin{itemize}
  \item The inputs are \cemph{secret values} of \cemph{clients} in a \emph{federation}
    $\setit{1,...,j}$.
  \item The \cemph{output} is made publicly available by $\prog$
  \end{itemize}
  The output may leak secret information to an \cemph{adversary} trying to
  guess secret values.  Consider:
  $$
  \idealf(x,y) = x * y
  $$
  If the output is odd, the adversary knows both secrets must be.  
\end{frame}
 
\begin{frame}{Protocol Implementation}

  Low-level, probabilistic protocols are defined in terms of basic variable types:
  \begin{itemize}
  \item $\secret{x}$: secret values in $\mathbb{F}_p$.
  \item $\mesg{x}$: messages received during the protocol.
  \item $\flip{x}$: uniformly random samples from $\mathbb{F}_p$ (implemented with
    a random tape semantics).
  \end{itemize}
  We can localize variables and expressions to \emph{clients}, and any information
  exchanged between clients must be through messaging.
  \begin{exampleblock}{Toy Example}
    $$
    \begin{array}{rcl@{\qquad}l}
      \mx{x}{1} &:=& \elab{(\secret{x} - \flip{x})}{2}  & \textit{(unicast)}\\
      \mx{y}{*} &:=& \elab{(\flip{y} + \mesg{x})}{1}  & \textit{(broadcast)}
    \end{array}
    $$ 
  \end{exampleblock}
\end{frame}

\begin{frame}{(Passive) Threat Model}
  The adversary wants to guess secrets. In addition to knowing the public
  output, the adversary may also corrupt some subset of clients $C$:
  \begin{itemize}
  \item adversary has access to the secrets of clients in $C$.
  \item adversary has access to messages received by members of $C$ during execution of $\prog$,
    aka \cemph{adversarial views}.
  \end{itemize}

  \begin{alertblock}{Bounded Declassification}
    The ideal functionality defines a declassification ``limit'', any protocol $\prog$
    should not reveal any more through adversarial views.
  \end{alertblock}
\end{frame}

\begin{frame}{Declassification of the Ideal Functionality}

  \begin{exampleblock}{Example: 3-Party xor}
  $$
  \idealf(\sx{1}{1},\sx{2}{2},\sx{3}{3}) =
  \sx{1}{1}\ \exor\ \sx{2}{2}\ \exor\ \sx{3}{3}
  $$
  Suppose in a run of $\prog$ the output of $\prog$ is 1 and $C = \{ 3 \}$ and
  the adversary knows $\sx{3}{3} = 0$, and therefore either:
  $$
  \sx{1}{1} = 0 \wedge \sx{2}{2} = 1
  $$
  or:
  $$
  \sx{1}{1} = 1 \wedge \sx{2}{2} = 0
  $$
  with \cemph{equal probability of .5}. \cemph{Adversarial views from the run of $\prog$ should not
    allow the adversary better guesses.}
  \end{exampleblock}
  
\end{frame}

\section{Conditional Probabilistic Noninterference}
\begin{frame}{Conditional Probabilistic Noninterference}

  \begin{itemize}
    \item The set of all protocol runs under all possible secrets and random tapes
      induces a probability distribution of program variables.
    \item Conditioning on the output and corrupt secrets =  declassification
      bounds.
    \item Conditioning on adversarial views tells us whether they leak information--
      if it changes the distribution of honest secrets.
  \end{itemize}
  
  \begin{alertblock}{Conditional Noninterference}
    The probability of honest secrets conditioned on the protocol output
    should not be changed by conditioning on adversarial views. 
  \end{alertblock}

  \begin{itemize}
  \item Sound for the standard \emph{passive simulator security} model.
  \item A \emph{hyperproperty} that accommodates traditional PL-based security
    mechanisms and theory. 
  \end{itemize}
  
\end{frame}

\section{Example: Shamir Addition}
\begin{frame}{Example: Shamir Addition}

  To implement 3-party summation (xor in $\mathbb{F}_2$), we can use \emph{Shamir addition}.
  Each party first generates \emph{reconstructive shares}.
  
  \begin{block}{Reconstructive Sharing}
    $$
    \begin{array}{lll}
      \elab{\mesg{s1}}{2} &:=& \elab{(\secret{1} \fminus \locflip \fminus \flip{x})}{1} \\ 
      \elab{\mesg{s1}}{3} &:=& \elab{\flip{x}}{1} \\ 
      \elab{\mesg{s2}}{1} &:=& \elab{(\secret{2} \fminus \locflip \fminus \flip{x})}{2} \\ 
      \elab{\mesg{s2}}{3} &:=& \elab{\flip{x}}{2} \\ 
      \elab{\mesg{s3}}{1} &:=& \elab{(\secret{3} \fminus \locflip \fminus \flip{x})}{3} \\ 
      \elab{\mesg{s3}}{2} &:=& \elab{\flip{x}}{3}
    \end{array}
    $$
  \end{block}
  \begin{itemize}
  \item \emph{algebraically} we have $\elab{\mesg{s1}}{2} + \elab{\mesg{s1}}{3} + \elab{\locflip}{1}$, etc.
  \item \emph{probabilistically} any 2 out of three shares are in a uniform random distribution.
  \end{itemize}
  
\end{frame}

\begin{frame}{Example contd.: Public Broadcast Reveal}

  \begin{itemize}
   \item \emph{algebraically} the sum of all shares = $\sx{1}{1} + \sx{2}{2} + \sx{3}{3}$    
  \end{itemize}

  \begin{block}{Broadcast Sum-of-Shares}
    $$
    \begin{array}{lll}
      \mx{ss1}{*} &:=& \elab{(\locflip \fplus \mesg{s2} \fplus \mesg{s3})}{1} \\ 
      \mx{ss2}{*} &:=& \elab{(\mesg{s1} \fplus \locflip \fplus \mesg{s3})}{2} \\
      \mx{ss3}{*} &:=& \elab{(\mesg{s1} \fplus \mesg{s2} \fplus \locflip)}{3} 
    \end{array}
    $$
  \end{block}

  \begin{itemize}
  \item Messages $\mx{ss1}$ through $\mx{ss3}$ are \emph{not} probabilistically independent of inputs
    secrets, but ...
  \item They \emph{are} independent of secrets conditioned on the output!
  \end{itemize}
  
\end{frame}

\begin{frame}{Example contd.: Output}

  The output phase does not reveal additional information, but is
  algebraically correct.
  \begin{block}{Client Outputs}
    $$
    \begin{array}{lll}
      \out{1} &:=& \elab{(\mesg{ss1} \fplus \mesg{ss2} + \mesg{ss3})}{1}\\
      \out{2} &:=& \elab{(\mesg{ss1} \fplus \mesg{ss2} + \mesg{ss3})}{2}\\
      \out{3} &:=& \elab{(\mesg{ss1} \fplus \mesg{ss2} + \mesg{ss3})}{3}
    \end{array}
    $$
  \end{block}
  
  %\begin{exampleblock}{Example Bad Protocol}
  %  If 1 is honest and accidentally broadcasts its local share:
  %  $$
  %  \mx{leak}{*} := \elab{\locflip}{1}
  %  $$
  %  conditioning on adversarial views now yields probability 1 for
  %  either $\sx{1}{1} = 0 \wedge \sx{2}{2} = 1$ or
  %  $\sx{1}{1} = 1 \wedge \sx{2}{2} = 0$.
  %\end{exampleblock}
  
\end{frame}

\end{document}
